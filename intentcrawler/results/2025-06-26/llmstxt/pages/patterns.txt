# Patterns

## FastMCP CLI - FastMCP

URL: https://gofastmcp.com/patterns/cli

--- title FastMCP CLI - FastMCP description Learn how to use the FastMCP command-line interface sitename FastMCP date 2024-05-29 --- Learn how to use the FastMCP command-line interface FastMCP provides a command-line interface CLI that makes it easy to run, develop, and install your MCP servers. The CLI is automatically installed when you install FastMCP. run Run a FastMCP server directly or proxy a remote server. This command runs the server directly in your current Python environment. You are responsible for ensuring all dependencies are available. New in version 2.3.5 The server can be specified in three ways server.py - imports the module and looks for a FastMCP object named mcp , server , or app . Errors if no such object is found.server.pycustom_name - imports and uses the specified server objecthttpserver-urlpath or httpsserver-urlpath - connects to a remote server and creates a proxyWhen using fastmcp run with a local file, it ignores the if __name__  __main__ block entirely. Instead, it finds your server object and calls its run method directly with the transport options you specify. This means you can use fastmcp run to override the transport specified in your code. For example, if your code contains You can run it with Streamable HTTP transport regardless of whats in the __main__ block Examples dev Run a MCP server with the MCP Inspector for testing. This command runs your server in an isolated environment. All dependencies must be explicitly specified using the --with andor --with-editable options. The dev command is a shortcut for testing a server over STDIO only. When the Inspector launches, you may need to This command does not support HTTP testing. To test a server over Streamable HTTP or SSE Example install Install a MCP server in the Claude desktop app. Note that for security reasons, Claude runs every MCP server in a completely isolated environment. Therefore, all dependencies must be explicitly specified using the --with andor --with-editable options following uv conventions or by attaching them to your server in code via the dependencies parameter. uv must be installed and available in your system PATH. Claude Desktop runs in its own isolated environment and needs uv to manage dependencies.uv globally with Homebrew so that Claude Desktop will detect it brew install uv . Installing uv with other methods may not make it accessible to Claude Desktop.The install command currently only sets up servers for STDIO transport. When installed in the Claude desktop app, your server will be run using STDIO regardless of any transport configuration in your code. The install command supports the same file.pyobject notation as the run command server.py - imports the module and looks for a FastMCP object named mcp , server , or app . Errors if no such object is found.server.pycustom_name - imports and uses the specified server objectExamples inspect New in version 2.9.0 Generate a detailed JSON report about a FastMCP server, including information about its tools, prompts, resources, and capabilities. The command supports the same server specification format as run and install  version Display version information about FastMCP and related components.

Keywords: the, server, fastmcp, and, command, run, your, with, install, for

---

## Decorating Methods - FastMCP

URL: https://gofastmcp.com/patterns/decorating-methods

--- title Decorating Methods - FastMCP description Properly use instance methods, class methods, and static methods with FastMCP decorators. sitename FastMCP date 2024-05-29 --- Properly use instance methods, class methods, and static methods with FastMCP decorators. FastMCPs decorator system is designed to work with functions, but you may see unexpected behavior if you try to decorate an instance or class method. This guide explains the correct approach for using methods with all FastMCP decorators tool , resource , and .prompt . When you apply a FastMCP decorator like tool , resource , or prompt to a method, the decorator captures the function at decoration time. For instance methods and class methods, this poses a challenge because This means directly decorating these methods doesnt work as expected. In practice, the LLM would see parameters like self or cls that it cannot provide values for. Additionally, FastMCP decorators return objects Tool, Resource, or Prompt instances rather than the original function. This means that when you decorate a method directly, the method becomes the returned object and is no longer callable by your code Dont do this! The method will no longer be callable from Python, and the tool wont be callable by LLMs. This is another important reason to register methods functionally after defining the class. Dont do this! When the decorator is applied this way, it captures the unbound method. When the LLM later tries to use this component, it will see self as a required parameter, but it wont know what to provide for it, causing errors or unexpected behavior. Do this instead This approach works because obj obj.add , Python creates a bound method where self is already set to that instanceself The behavior of decorating class methods depends on the order of decorators Dont do this decorator order matters classmethod comes first, then mcp.tool  No error is raised, but it wont work correctlymcp.tool comes first, then classmethod  FastMCP will detect this and raise a helpful ValueError with guidanceDo this instead This works because classmethod decorator is applied properly during class definitionMyClass.from_string , Python provides a special method object that automatically binds the class to the cls parametercls parameterStatic methods work with FastMCP decorators, but this is not recommended because the FastMCP decorator will not return a callable method. Therefore, you should register static methods the same way as other methods. This is not recommended, though it will work. This works because staticmethod converts the method to a regular function, which the FastMCP decorator can then properly process. However, this is not recommended because the FastMCP decorator will not return a callable staticmethod. Therefore, you should register static methods the same way as other methods. Prefer this pattern You can automatically register instance methods when creating an object This pattern is useful when The class automatically registers its methods during initialization, ensuring theyre properly bound to the instance before registration. The current behavior of FastMCP decorators with methods is ValueError with guidanceFor class and instance methods, you should register them after creating the instance or class to ensure proper method binding. This ensures that the methods are properly bound before being registered. Understanding these patterns allows you to effectively organize your components into classes while maintaining proper method binding, giving you the benefits of object-oriented design without sacrificing the simplicity of FastMCPs decorator system.

Keywords: the, methods, this, fastmcp, method, class, decorator, you, instance, and

---

## HTTP Requests - FastMCP

URL: https://gofastmcp.com/patterns/http-requests

--- title HTTP Requests - FastMCP description Accessing and using HTTP requests in FastMCP servers sitename FastMCP date 2024-05-29 --- New in version 2.2.11 Overview When running FastMCP as a web server, your MCP tools, resources, and prompts might need to access the underlying HTTP request information, such as headers, client IP, or query parameters. FastMCP provides a clean way to access HTTP request information through a dependency function. Accessing HTTP Requests The recommended way to access the current HTTP request is through the get_http_request dependency function from fastmcp import FastMCP from fastmcp.server.dependencies import get_http_request from starlette.requests import Request mcp  FastMCPnameHTTP Request Demo mcp.tool async def user_agent_info - dict Return information about the user agent.  Get the HTTP request request Request  get_http_request  Access request data user_agent  request.headers.getuser-agent, Unknown client_ip  request.client.host if request.client else Unknown return  user_agent user_agent, client_ip client_ip, path request.url.path,  This approach works anywhere within a requests execution flow, not just within your MCP function. Its useful when - You need access to HTTP information in helper functions - Youre calling nested functions that need HTTP request data - Youre working with middleware or other request processing code If you only need request headers and want to avoid potential errors, you can use the get_http_headers helper from fastmcp import FastMCP from fastmcp.server.dependencies import get_http_headers mcp  FastMCPnameHeaders Demo mcp.tool async def safe_header_info - dict Safely get header information without raising errors.  Get headers returns empty dict if no request context headers  get_http_headers  Get authorization header auth_header  headers.getauthorization,  is_bearer  auth_header.startswithBearer  return  user_agent headers.getuser-agent, Unknown, content_type headers.getcontent-type, Unknown, has_auth boolauth_header, auth_type Bearer if is_bearer else Other if auth_header else None, headers_count lenheaders  By default, get_http_headers excludes problematic headers like host and content-length . To include all headers, use get_http_headersinclude_allTrue . Important Notes - HTTP requests are only available when FastMCP is running as part of a web application - Accessing the HTTP request with get_http_request outside of a web request context will raise a RuntimeError - The get_http_headers function never raises errors - it returns an empty dict when no request context is available - The get_http_request function returns a standard Starlette Request object Responses are generated using AI and may contain mistakes.

Keywords: request, fastmcp, http, the, headers, requests, mcp, and, access, information

---

## Testing MCP Servers - FastMCP

URL: https://gofastmcp.com/patterns/testing

--- title Testing MCP Servers - FastMCP description Learn how to test your FastMCP servers effectively sitename FastMCP date 2024-05-29 --- Learn how to test your FastMCP servers effectively Testing your MCP servers thoroughly is essential for ensuring they work correctly when deployed. FastMCP makes this easy through a variety of testing patterns. The most efficient way to test an MCP server is to pass your FastMCP server instance directly to a Client. This enables in-memory testing without having to start a separate server process, which is particularly useful because managing an MCP server programmatically can be challenging. Here is an example of using a Client to test a server with pytest This pattern creates a direct connection between the client and server, allowing you to test your servers functionality efficiently.

Keywords: fastmcp, server, servers, test, your, testing, mcp, this, client, learn

---

## Tool Transformation - FastMCP

URL: https://gofastmcp.com/patterns/tool-transformation

--- title Tool Transformation - FastMCP description Create enhanced tool variants with modified schemas, argument mappings, and custom behavior. sitename FastMCP date 2024-05-29 --- Create enhanced tool variants with modified schemas, argument mappings, and custom behavior. New in version 2.8.0 Tool transformation allows you to create new, enhanced tools from existing ones. This powerful feature enables you to adapt tools for different contexts, simplify complex interfaces, or add custom logic without duplicating code. Often, an existing tool is almost perfect for your use case, but it might have q instead of query .Instead of rewriting the tool from scratch, you can transform it to fit your needs. The primary way to create a transformed tool is with the Tool.from_tool class method. At its simplest, you can use it to change a tools top-level metadata like its name , description , or tags . In the following simple example, we take a generic search tool and adjust its name and description to help an LLM client better understand its purpose. When you transform a tool, the original tool remains registered on the server. To avoid confusing an LLM with two similar tools, you can disable the original one Now, clients see a tool named find_products with a clear, domain-specific purpose and relevant tags, even though it still uses the original generic search functions logic. The Tool.from_tool class method is the primary way to create a transformed tool. It takes the following parameters tool  The tool to transform. This is the only required argument.name  An optional name for the new tool.description  An optional description for the new tool.transform_args  A dictionary of ArgTransform objects, one for each argument you want to modify.transform_fn  An optional function that will be called instead of the parent tools logic.tags  An optional set of tags for the new tool.annotations  An optional set of ToolAnnotations for the new tool.serializer  An optional function that will be called to serialize the result of the new tool.The result is a new TransformedTool object that wraps the parent tool and applies the transformations you specify. You can add this tool to your MCP server using its add_tool method. To modify a tools parameters, provide a dictionary of ArgTransform objects to the transform_args parameter of Tool.from_tool . Each key is the name of the original argument you want to modify. You only need to provide a transform_args entry for arguments you want to modify. All other arguments will be passed through unchanged. To modify an argument, you need to create an ArgTransform object. This object has the following parameters name  The new name for the argument.description  The new description for the argument.default  The new default value for the argument.default_factory  A function that will be called to generate a default value for the argument. This is useful for arguments that need to be generated for each tool call, such as timestamps or unique IDs.hide  Whether to hide the argument from the LLM.required  Whether the argument is required, usually used to make an optional argument be required instead.type  The new type for the argument.Certain combinations of parameters are not allowed. For example, you can only use default_factory with hideTrue , because dynamic defaults cannot be represented in a JSON schema for the client. You can only set requiredTrue for arguments that do not declare a default value. By far the most common reason to transform a tool, after its own description, is to improve its argument descriptions. A good description is crucial for helping an LLM understand how to use a parameter correctly. This is especially important when wrapping tools from external APIs, whose argument descriptions may be missing or written for developers, not LLMs. In this example, we add a helpful description to the user_id argument At times, you may want to rename an argument to make it more intuitive for an LLM. For example, in the following example, we take a generic q argument and expand it to search_query  You can update the default value for any argument using the default parameter. Here, we change the default value of the y argument to 10 Default values are especially useful in combination with hidden arguments. Sometimes a tool requires arguments that shouldnt be exposed to the LLM, such as API keys, configuration flags, or internal IDs. You can hide these parameters using hideTrue . Note that you can only hide arguments that have a default value or for which you provide a new default, because the LLM cant provide a value at call time. To pass a constant value to the parent tool, combine hideTrue with defaultvalue . The LLM now only sees the to , subject , and body parameters. The api_key is supplied automatically from an environment variable. For values that must be generated for each tool call like timestamps or unique IDs, use default_factory , which is called with no arguments every time the tool is called. For example, default_factory can only be used with hideTrue . This is because visible parameters need static defaults that can be represented in a JSON schema for the client. In rare cases where you want to make an optional argument required, you can set requiredTrue . This has no effect if the argument was already required. With great power comes great responsibility. Modifying tool behavior is a very advanced feature. In addition to changing a tools schema, advanced users can also modify its behavior. This is useful for adding validation logic, or for post-processing the tools output. The from_tool method takes a transform_fn parameter, which is an async function that replaces the parent tools logic and gives you complete control over the tools execution. The transform_fn is an async function that completely replaces the parent tools logic. Critically, the transform functions arguments are used to determine the new tools final schema. Any arguments that are not already present in the parent tool schema OR the transform_args will be added to the new tools schema. Note that when transform_args and your function have the same argument name, the transform_args metadata will take precedence, if provided. The name  docstring of the transform_fn are ignored. Only its arguments are used to determine the final schema. Most of the time, you dont want to completely replace the parent tools behavior. Instead, you want to add validation, modify inputs, or post-process outputs while still leveraging the parent tools core functionality. For this, FastMCP provides the special forward and forward_raw functions. Both forward and forward_raw are async functions that let you call the parent tool from within your transform_fn  forward recommended Automatically handles argument mapping based on your ArgTransform configurations. Call it with the transformed argument names.forward_raw  Bypasses all transformation and calls the parent tool directly with its original argument names. This is rarely needed unless youre doing complex argument manipulation, perhaps without arg_transforms .The most common transformation pattern is to validate potentially renamed arguments before calling the parent tool. Heres an example that validates that x and y are positive before calling the parent tool In the simplest case, your parent tool and your transform function have the same arguments. You can call forward with the same argument names as the parent tool In the simplest case, your parent tool and your transform function have the same arguments. You can call forward with the same argument names as the parent tool When your transformed tool has different argument names than the parent tool, you can call forward with the renamed arguments and it will automatically map the arguments to the parent tools arguments Finally, you can use forward_raw to bypass all argument mapping and call the parent tool directly with its original argument names. If your transform_fn includes kwargs in its signature, it will receive all arguments from the parent tool after ArgTransform configurations have been applied. This is powerful for creating flexible validation functions that dont require you to add every argument to the function signature. In the following example, we wrap a parent tool that accepts two arguments x and y . These are renamed to a and b in the transformed tool, and the transform only validates a , passing the other argument through as kwargs . In the above example, kwargs receives the renamed argument b , not the original argument y . It is therefore recommended to use with forward , not forward_raw . Tool transformation is a flexible feature that supports many powerful patterns. Here are a few common use cases to give you ideas. This is one of the most common reasons to use tool transformation. Tools from remote servers via a proxy or generated from an OpenAPI spec are often too generic for direct use by an LLM. You can use transformation to create a simpler, more intuitive version for your specific needs. You can chain transformations by using an already transformed tool as the parent for a new transformation. This lets you build up complex behaviors in layers, for example, first renaming arguments, and then adding validation logic to the renamed tool. You can write functions that act as factories, generating specialized versions of a tool for different contexts. For example, you could create a get_my_data tool that is specific to the currently logged-in user by hiding the user_id parameter and providing it automatically.

Keywords: the, tool, for, argument, you, and, that, parent, can, arguments

---

