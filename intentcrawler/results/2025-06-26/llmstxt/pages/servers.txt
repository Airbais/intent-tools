# Servers

## Bearer Token Authentication - FastMCP

URL: https://gofastmcp.com/servers/auth/bearer

--- title Bearer Token Authentication - FastMCP description Secure your FastMCP servers HTTP endpoints by validating JWT Bearer tokens. sitename FastMCP date 2024-05-29 --- Secure your FastMCP servers HTTP endpoints by validating JWT Bearer tokens. New in version 2.6.0 Authentication and authorization are only relevant for HTTP-based transports. The MCP specification requires servers to implement full OAuth 2.1 authorization flows with dynamic client registration, server metadata discovery, and complete token endpoints. FastMCPs Bearer Token authentication provides a simpler, more practical alternative by directly validating pre-issued JWT tokensideal for service-to-service communication and programmatic environments where full OAuth flows may be impractical, and in accordance with how the MCP ecosystem is pragmatically evolving. However, please note that since it doesnt implement the full OAuth 2.1 flow, this implementation does not strictly comply with the MCP specification. Bearer Token authentication is a common way to secure HTTP-based APIs. In this model, the client sends a token usually a JSON Web Token or JWT in the Authorization header with the Bearer scheme. The server then validates this token to grant or deny access. FastMCP supports Bearer Token authentication for its HTTP-based transports http and sse , allowing you to protect your server from unauthorized access. FastMCP uses asymmetric encryption for token validation, which provides a clean security separation between token issuers and FastMCP servers. This approach means This design allows you to integrate FastMCP servers into existing authentication infrastructures without compromising security boundaries. To enable Bearer Token validation on your FastMCP server, use the BearerAuthProvider class. This provider validates incoming JWTs by verifying signatures, checking expiration, and optionally validating claims. The BearerAuthProvider validates tokens it does not issue them or implement any part of an OAuth flow. Youll need to generate tokens separately, either using FastMCP utilities or an external Identity Provider IdP or OAuth 2.1 Authorization Server. To configure bearer token authentication, instantiate a BearerAuthProvider instance and pass it to the auth parameter of the FastMCP instance. The BearerAuthProvider requires either a static public key or a JWKS URI but not both! in order to verify the tokens signature. All other parameters are optional  if they are provided, they will be used as additional validation criteria. RSA public key in PEM format for static key validation. Required if jwks_uri is not provided URL for JSON Web Key Set endpoint. Required if public_key is not provided Expected JWT iss claim value Expected JWT aud claim value Global scopes required for all requests If you have a public key in PEM format, you can provide it to the BearerAuthProvider as a string. JWKS is recommended for production as it supports automatic key rotation and multiple signing keys. For development and testing, FastMCP provides the RSAKeyPair utility class to generate tokens without needing an external OAuth provider. The RSAKeyPair utility is intended for development and testing only. For production, use a proper OAuth 2.1 Authorization Server or Identity Provider. The create_token method accepts these parameters JWT subject claim usually user ID JWT issuer claim JWT audience claim OAuth scopes to include Token expiration time in seconds Extra claims to include in the token Key ID for JWKS lookup Once authenticated, your tools, resources, or prompts can access token information using the get_access_token dependency function

Keywords: the, token, fastmcp, for, and, bearer, jwt, oauth, authentication, key

---

## Server Composition - FastMCP

URL: https://gofastmcp.com/servers/composition

--- title Server Composition - FastMCP description Combine multiple FastMCP servers into a single, larger application using mounting and importing. sitename FastMCP date 2024-05-29 --- New in version 2.2.0 As your MCP applications grow, you might want to organize your tools, resources, and prompts into logical modules or reuse existing server components. FastMCP supports composition through two methods import_server  For a one-time copy of components with prefixing static composition. mount  For creating a live link where the main server delegates requests to the subserver dynamic composition. Why Compose Servers? - Modularity Break down large applications into smaller, focused servers e.g., a WeatherServer , a DatabaseServer , a CalendarServer . - Reusability Create common utility servers e.g., a TextProcessingServer  and mount them wherever needed. - Teamwork Different teams can work on separate FastMCP servers that are later combined. - Organization Keep related functionality grouped together logically. Importing vs Mounting The choice of importing or mounting depends on your use case and requirements. Proxy Servers FastMCP supports MCP proxying, which allows you to mirror a local or remote server in a local FastMCP instance. Proxies are fully compatible with both importing and mounting. New in version 2.4.0 You can also create proxies from configuration dictionaries that follow the MCPConfig schema, which is useful for quickly connecting to one or more remote servers. See the Proxy Servers documentation for details on configuration-based proxying. Note that MCPConfig follows an emerging standard and its format may evolve over time. Importing Static Composition The import_server method copies all components tools, resources, templates, prompts from one FastMCP instance the subserver into another the main server. An optional prefix can be provided to avoid naming conflicts. If no prefix is provided, components are imported without modification. When multiple servers are imported with the same prefix or no prefix, the most recently imported servers components take precedence. from fastmcp import FastMCP import asyncio  Define subservers weather_mcp  FastMCPnameWeatherService weather_mcp.tool def get_forecastcity str - dict Get weather forecast. return city city, forecast Sunny weather_mcp.resourcedatacitiessupported def list_supported_cities - liststr List cities with weather support. return London, Paris, Tokyo  Define main server main_mcp  FastMCPnameMainApp  Import subserver async def setup await main_mcp.import_serverweather_mcp, prefixweather  Result main_mcp now contains prefixed components  - Tool weather_get_forecast  - Resource dataweathercitiessupported if __name__  __main__ asyncio.runsetup main_mcp.run How Importing Works When you call await main_mcp.import_serversubserver, prefixwhatever  - Tools All tools from subserver are added to main_mcp with names prefixed using prefix_ . subserver.toolnamemy_tool becomes main_mcp.toolnameprefix_my_tool . - Resources All resources are added with URIs prefixed in the format protocolprefixpath . subserver.resourceuridatainfo becomes main_mcp.resourceuridataprefixinfo . - Resource Templates Templates are prefixed similarly to resources. subserver.resourceuridataid becomes main_mcp.resourceuridataprefixid . - Prompts All prompts are added with names prefixed using prefix_ . subserver.promptnamemy_prompt becomes main_mcp.promptnameprefix_my_prompt . Note that import_server performs a one-time copy of components. Changes made to the subserver after importing will not be reflected in main_mcp . The subserver s lifespan context is also not executed by the main server. The prefix parameter is optional. If omitted, components are imported without modification. Importing Without Prefixes New in version 2.9.0 You can also import servers without specifying a prefix, which copies components using their original names from fastmcp import FastMCP import asyncio  Define subservers weather_mcp  FastMCPnameWeatherService weather_mcp.tool def get_forecastcity str - dict Get weather forecast. return city city, forecast Sunny weather_mcp.resourcedatacitiessupported def list_supported_cities - liststr List cities with weather support. return London, Paris, Tokyo  Define main server main_mcp  FastMCPnameMainApp  Import subserver async def setup  Import without prefix - components keep original names await main_mcp.import_serverweather_mcp  Result main_mcp now contains  - Tool get_forecast original name preserved  - Resource datacitiessupported original URI preserved if __name__  __main__ asyncio.runsetup main_mcp.run Conflict Resolution New in version 2.9.0 When importing multiple servers with the same prefix, or no prefix, components from the most recently imported server take precedence. Mounting Live Linking The mount method creates a live link between the main_mcp server and the subserver . Instead of copying components, requests for components matching the optional prefix are delegated to the subserver at runtime. If no prefix is provided, the subservers components are accessible without prefixing. When multiple servers are mounted with the same prefix or no prefix, the most recently mounted server takes precedence for conflicting component names. import asyncio from fastmcp import FastMCP, Client  Define subserver dynamic_mcp  FastMCPnameDynamicService dynamic_mcp.tool def initial_tool Initial tool demonstration. return Initial Tool Exists  Mount subserver synchronous operation main_mcp  FastMCPnameMainAppLive main_mcp.mountdynamic_mcp, prefixdynamic  Add a tool AFTER mounting - it will be accessible through main_mcp dynamic_mcp.tool def added_later Tool added after mounting. return Tool Added Dynamically!  Testing access to mounted tools async def test_dynamic_mount tools  await main_mcp.get_tools printAvailable tools, listtools.keys  Shows dynamic_initial_tool, dynamic_added_later async with Clientmain_mcp as client result  await client.call_tooldynamic_added_later printResult, result0.text  Shows Tool Added Dynamically! if __name__  __main__ asyncio.runtest_dynamic_mount How Mounting Works When mounting is configured - Live Link The parent server establishes a connection to the mounted server. - Dynamic Updates Changes to the mounted server are immediately reflected when accessed through the parent. - Prefixed Access The parent server uses prefixes to route requests to the mounted server. - Delegation Requests for components matching the prefix are delegated to the mounted server at runtime. The same prefixing rules apply as with import_server for naming tools, resources, templates, and prompts. The prefix parameter is optional. If omitted, components are mounted without modification. Mounting Without Prefixes New in version 2.9.0 You can also mount servers without specifying a prefix, which makes components accessible without prefixing. This works identically to importing without prefixes, including conflict resolution. Direct vs. Proxy Mounting New in version 2.2.7 FastMCP supports two mounting modes - Direct Mounting default The parent server directly accesses the mounted servers objects in memory. - No client lifecycle events occur on the mounted server - The mounted servers lifespan context is not executed - Communication is handled through direct method calls - Proxy Mounting The parent server treats the mounted server as a separate entity and communicates with it through a client interface. - Full client lifecycle events occur on the mounted server - The mounted servers lifespan is executed when a client connects - Communication happens via an in-memory Client transport  Direct mounting default when no custom lifespan main_mcp.mountapi_server, prefixapi  Proxy mounting preserves full client lifecycle main_mcp.mountapi_server, prefixapi, as_proxyTrue  Mounting without a prefix components accessible without prefixing main_mcp.mountapi_server FastMCP automatically uses proxy mounting when the mounted server has a custom lifespan, but you can override this behavior with the as_proxy parameter. Interaction with Proxy Servers When using FastMCP.as_proxy to create a proxy server, mounting that server will always use proxy mounting  Create a proxy for a remote server remote_proxy  FastMCP.as_proxyClienthttpexample.commcp  Mount the proxy always uses proxy mounting main_server.mountremote_proxy, prefixremote New in version 2.4.0 When mounting or importing servers, resource URIs are usually prefixed to avoid naming conflicts. FastMCP supports two different formats for resource prefixes In path format, prefixes are added to the path component of the URI resourceprefixpathtoresource This is the default format since FastMCP 2.4. This format is recommended because it avoids issues with URI protocol restrictions like underscores not being allowed in protocol names. In protocol format, prefixes are added as part of the protocol prefixresourcepathtoresource This was the default format in FastMCP before 2.4. While still supported, its not recommended for new code as it can cause problems with prefix names that arent valid in URI protocols. You can configure the prefix format globally in code import fastmcp fastmcp.settings.resource_prefix_format  protocol Or via environment variable FASTMCP_RESOURCE_PREFIX_FORMATprotocol Or per-server from fastmcp import FastMCP  Create a server that uses legacy protocol format server  FastMCPLegacyServer, resource_prefix_formatprotocol  Create a server that uses new path format server  FastMCPNewServer, resource_prefix_formatpath When mounting or importing servers, the prefix format of the parent server is used. Responses are generated using AI and may contain mistakes.

Keywords: the, server, fastmcp, mounting, servers, prefix, are, components, with, subserver

---

## MCP Context - FastMCP

URL: https://gofastmcp.com/servers/context

--- title MCP Context - FastMCP description Access MCP capabilities like logging, progress, and resources within your MCP objects. sitename FastMCP date 2024-05-29 --- When defining FastMCP tools, resources, resource templates, or prompts, your functions might need to interact with the underlying MCP session or access server capabilities. FastMCP provides the Context object for this purpose. What Is Context? The Context object provides a clean interface to access MCP features within your functions, including - Logging Send debug, info, warning, and error messages back to the client - Progress Reporting Update the client on the progress of long-running operations - Resource Access Read data from resources registered with the server - LLM Sampling Request the clients LLM to generate text based on provided messages - Request Information Access metadata about the current request - Server Access When needed, access the underlying FastMCP server instance Accessing the Context Via Dependency Injection To use the context object within any of your functions, simply add a parameter to your function signature and type-hint it as Context . FastMCP will automatically inject the context instance when your function is called. Key Points - The parameter name e.g., ctx , context  doesnt matter, only the type hint Context is important. - The context parameter can be placed anywhere in your functions signature it will not be exposed to MCP clients as a valid parameter. - The context is optional - functions that dont need it can omit the parameter entirely. - Context methods are async, so your function usually needs to be async as well. - The type hint can be a union  Context  None  or use Annotated and it will still work properly. - Context is only available during a request attempting to use context methods outside a request will raise errors. If you need to debug or call your context methods outside of a request, you can type your variable as Context  NoneNone to avoid missing argument errors. from fastmcp import FastMCP, Context mcp  FastMCPnameContextDemo mcp.tool async def process_filefile_uri str, ctx Context - str Processes a file, using context for logging and resource access.  Context is available as the ctx parameter return Processed file Resources and Templates New in version 2.2.5 mcp.resourceresourceuser-data async def get_user_datactx Context - dict Fetch personalized user data based on the request context.  Context is available as the ctx parameter return user_id example mcp.resourceresourceusersuser_idprofile async def get_user_profileuser_id str, ctx Context - dict Fetch user profile with context-aware logging.  Context is available as the ctx parameter return id user_id Prompts New in version 2.2.5 mcp.prompt async def data_analysis_requestdataset str, ctx Context - str Generate a request to analyze data with contextual information.  Context is available as the ctx parameter return fPlease analyze the following dataset dataset Via Dependency Function New in version 2.2.11 While the simplest way to access context is through function parameter injection as shown above, there are cases where you need to access the context in code that may not be easy to modify to accept a context parameter, or that is nested deeper within your function calls. FastMCP provides dependency functions that allow you to retrieve the active context from anywhere within a server requests execution flow from fastmcp import FastMCP, Context from fastmcp.server.dependencies import get_context mcp  FastMCPnameDependencyDemo  Utility function that needs context but doesnt receive it as a parameter async def process_datadata listfloat - dict  Get the active context - only works when called within a request ctx  get_context await ctx.infofProcessing lendata data points mcp.tool async def analyze_datasetdataset_name str - dict  Call utility function that uses context internally data  load_datadataset_name await process_datadata Important Notes - The get_context function should only be used within the context of a server request. Calling it outside of a request will raise a RuntimeError . - The get_context function is server-only and should not be used in client code. Context Capabilities Logging Send log messages back to the MCP client. This is useful for debugging and providing visibility into function execution during a request. mcp.tool async def analyze_datadata listfloat, ctx Context - dict Analyze numerical data with logging. await ctx.debugStarting analysis of numerical data await ctx.infofAnalyzing lendata data points try result  sumdata  lendata await ctx.infofAnalysis complete, average result return average result, count lendata except ZeroDivisionError await ctx.warningEmpty data list provided return error Empty data list except Exception as e await ctx.errorfAnalysis failed stre raise Available Logging Methods ctx.debugmessage str  Low-level details useful for debugging ctx.infomessage str  General information about execution ctx.warningmessage str  Potential issues that didnt prevent execution ctx.errormessage str  Errors that occurred during execution ctx.loglevel Literaldebug, info, warning, error, message str, logger_name str  None  None  Generic log method supporting custom logger names Progress Reporting For long-running operations, notify the client about the progress. This allows clients to display progress indicators and provide a better user experience. mcp.tool async def process_itemsitems liststr, ctx Context - dict Process a list of items with progress updates. total  lenitems results   for i, item in enumerateitems  Report progress as percentage await ctx.report_progressprogressi, totaltotal  Process the item simulated with a sleep await asyncio.sleep0.1 results.appenditem.upper  Report 100 completion await ctx.report_progressprogresstotal, totaltotal return processed lenresults, results results Method signature ctx.report_progressprogress float, total float  None  None progress  Current progress value e.g., 24 total  Optional total value e.g., 100. If provided, clients may interpret this as a percentage. Progress reporting requires the client to have sent a progressToken in the initial request. If the client doesnt support progress reporting, these calls will have no effect. Resource Access Read data from resources registered with your FastMCP server. This allows functions to access files, configuration, or dynamically generated content. mcp.tool async def summarize_documentdocument_uri str, ctx Context - str Summarize a document by its resource URI.  Read the document content content_list  await ctx.read_resourcedocument_uri if not content_list return Document is empty document_text  content_list0.content  Example Generate a simple summary length-based words  document_text.split total_words  lenwords await ctx.infofDocument has total_words words  Return a simple summary if total_words  100 summary   .joinwords100  ... return fSummary total_words words total summary else return fFull document total_words words document_text Method signature ctx.read_resourceuri str  AnyUrl - listReadResourceContents uri  The resource URI to read - Returns a list of resource content parts usually containing just one item The returned content is typically accessed via content_list0.content and can be text or binary data depending on the resource. LLM Sampling New in version 2.0.0 Request the clients LLM to generate text based on provided messages. This is useful when your function needs to leverage the LLMs capabilities to process data or generate responses. mcp.tool async def analyze_sentimenttext str, ctx Context - dict Analyze the sentiment of a text using the clients LLM.  Create a sampling prompt asking for sentiment analysis prompt  fAnalyze the sentiment of the following text as positive, negative, or neutral. Just output a single word - positive, negative, or neutral. Text to analyze text  Send the sampling request to the clients LLM provide a hint for the model you want to use response  await ctx.sampleprompt, model_preferencesclaude-3-sonnet  Process the LLMs response sentiment  response.text.strip.lower  Map to standard sentiment values if positive in sentiment sentiment  positive elif negative in sentiment sentiment  negative else sentiment  neutral return text text, sentiment sentiment Method signature ctx.samplemessages str  liststr  SamplingMessage, system_prompt str  None  None, temperature float  None  None, max_tokens int  None  None, model_preferences ModelPreferences  str  liststr  None  None - TextContent  ImageContent messages  A string or list of stringsmessage objects to send to the LLM system_prompt  Optional system prompt to guide the LLMs behavior temperature  Optional sampling temperature controls randomness max_tokens  Optional maximum number of tokens to generate defaults to 512 model_preferences  Optional model selection preferences e.g., a model hint string, list of hints, or a ModelPreferences object - Returns the LLMs response as TextContent or ImageContent When providing a simple string, its treated as a user message. For more complex scenarios, you can provide a list of messages with different roles. mcp.tool async def generate_exampleconcept str, ctx Context - str Generate a Python code example for a given concept.  Using a system prompt and a user message response  await ctx.sample messagesfWrite a simple Python code example demonstrating concept., system_promptYou are an expert Python programmer. Provide concise, working code examples without explanations., temperature0.7, max_tokens300  code_example  response.text return fpythonncode_examplen See Client Sampling for more details on how clients handle these requests. Component Changes New in version 2.9.1 FastMCP automatically sends list change notifications when components such as tools, resources, or prompts are added, removed, enabled, or disabled. In rare cases where you need to manually trigger these notifications, you can use the context methods mcp.tool async def custom_tool_managementctx Context - str Example of manual notification after custom tool changes.  After making custom changes to tools await ctx.send_tool_list_changed await ctx.send_resource_list_changed await ctx.send_prompt_list_changed return Notifications sent These methods are primarily used internally by FastMCPs automatic notification system and most users will not need to invoke them directly. Access metadata about the current request and client. mcp.tool async def request_infoctx Context - dict Return information about the current request. return  request_id ctx.request_id, client_id ctx.client_id or Unknown client  Available Properties ctx.request_id - str  Get the unique ID for the current MCP request ctx.client_id - str  None  Get the ID of the client making the request, if provided during initialization ctx.session_id - str  None  Get the MCP session ID for session-based data sharing HTTP transports only Advanced Access FastMCP Server and Sessions mcp.tool async def advanced_toolctx Context - str Demonstrate advanced context access.  Access the FastMCP server instance server_name  ctx.fastmcp.name  Low-level session access rarely needed session  ctx.session request_context  ctx.request_context return fServer server_name HTTP Requests New in version 2.2.7 The ctx.get_http_request method is deprecated and will be removed in a future version. Please use the get_http_request dependency function instead. See the HTTP Requests pattern for more details. For web applications, you can access the underlying HTTP request mcp.tool async def handle_web_requestctx Context - dict Access HTTP request information from the Starlette request. request  ctx.get_http_request  Access HTTP headers, query parameters, etc. user_agent  request.headers.getuser-agent, Unknown client_ip  request.client.host if request.client else Unknown return  user_agent user_agent, client_ip client_ip, path request.url.path,  Advanced Properties Reference ctx.fastmcp - FastMCP  Access the server instance the context belongs to ctx.session  Access the raw mcp.server.session.ServerSession object ctx.request_context  Access the raw mcp.shared.context.RequestContext object Direct use of session or request_context requires understanding the low-level MCP Python SDK and may be less stable than using the methods provided directly on the Context object. Responses are generated using AI and may contain mistakes.

Keywords: the, context, ctx, mcp, request, str, access, fastmcp, return, and

---

## MCP Middleware - FastMCP

URL: https://gofastmcp.com/servers/middleware

--- title MCP Middleware - FastMCP description Add cross-cutting functionality to your MCP server with middleware that can inspect, modify, and respond to all MCP requests and responses. sitename FastMCP date 2024-05-29 --- New in version 2.9.0 MCP middleware is a powerful concept that allows you to add cross-cutting functionality to your FastMCP server. Unlike traditional web middleware, MCP middleware is designed specifically for the Model Context Protocol, providing hooks for different types of MCP operations like tool calls, resource reads, and prompt requests. MCP middleware is a FastMCP-specific concept and is not part of the official MCP protocol specification. This middleware system is designed to work with FastMCP servers and may not be compatible with other MCP implementations. MCP middleware is a brand new concept and may be subject to breaking changes in future versions. What is MCP Middleware? MCP middleware lets you intercept and modify MCP requests and responses as they flow through your server. Think of it as a pipeline where each piece of middleware can inspect whats happening, make changes, and then pass control to the next middleware in the chain. Common use cases for MCP middleware include - Authentication and Authorization Verify client permissions before executing operations - Logging and Monitoring Track usage patterns and performance metrics - Rate Limiting Control request frequency per client or operation type - RequestResponse Transformation Modify data before it reaches tools or after it leaves - Caching Store frequently requested data to improve performance - Error Handling Provide consistent error responses across your server How Middleware Works FastMCP middleware operates on a pipeline model. When a request comes in, it flows through your middleware in the order they were added to the server. Each middleware can - Inspect the incoming request and its context - Modify the request before passing it to the next middleware or handler - Execute the next middlewarehandler in the chain by calling call_next - Inspect and modify the response before returning it - Handle errors that occur during processing The key insight is that middleware forms a chain where each piece decides whether to continue processing or stop the chain entirely. If youre familiar with ASGI middleware, the basic structure of FastMCP middleware will feel familiar. At its core, middleware is a callable class that receives a context object containing information about the current JSON-RPC message and a handler function to continue the middleware chain. Its important to understand that MCP operates on the JSON-RPC specification. While FastMCP presents requests and responses in a familiar way, these are fundamentally JSON-RPC messages, not HTTP requestresponse pairs like you might be used to in web applications. FastMCP middleware works with all transport types, including local stdio transport and HTTP transports, though not all middleware implementations are compatible across all transports e.g., middleware that inspects HTTP headers wont work with stdio transport. The most fundamental way to implement middleware is by overriding the __call__ method on the Middleware base class from fastmcp.server.middleware import Middleware, MiddlewareContext class RawMiddlewareMiddleware async def __call__self, context MiddlewareContext, call_next  This method receives ALL messages regardless of type printfRaw middleware processing context.method result  await call_nextcontext printfRaw middleware completed context.method return result This gives you complete control over every message that flows through your server, but requires you to handle all message types manually. Middleware Hooks To make it easier for users to target specific types of messages, FastMCP middleware provides a variety of specialized hooks. Instead of implementing the raw __call__ method, you can override specific hook methods that are called only for certain types of operations, allowing you to target exactly the level of specificity you need for your middleware logic. Hook Hierarchy and Execution Order FastMCP provides multiple hooks that are called with varying levels of specificity. Understanding this hierarchy is crucial for effective middleware design. When a request comes in, multiple hooks may be called for the same request, going from general to specific on_message - Called for ALL MCP messages both requests and notifications on_request or on_notification - Called based on the message type - Operation-specific hooks - Called for specific MCP operations like on_call_tool For example, when a client calls a tool, your middleware will receive three separate hook calls - First on_message because its any MCP message - Second on_request because tool calls expect responses - Third on_call_tool because its specifically a tool execution This hierarchy allows you to target your middleware logic with the right level of specificity. Use on_message for broad concerns like logging, on_request for authentication, and on_call_tool for tool-specific logic like performance monitoring. Available Hooks on_message  Called for all MCP messages requests and notifications on_request  Called specifically for MCP requests that expect responses on_notification  Called specifically for MCP notifications fire-and-forget on_call_tool  Called when tools are being executed on_read_resource  Called when resources are being read on_get_prompt  Called when prompts are being retrieved on_list_tools  Called when listing available tools on_list_resources  Called when listing available resources on_list_resource_templates  Called when listing resource templates on_list_prompts  Called when listing available prompts Component Access in Middleware Understanding how to access component information tools, resources, prompts in middleware is crucial for building powerful middleware functionality. The access patterns differ significantly between listing operations and execution operations. Listing Operations vs Execution Operations FastMCP middleware handles two types of operations differently Listing Operations on_list_tools , on_list_resources , on_list_prompts , etc. - Middleware receives FastMCP component objects with full metadata - These objects include FastMCP-specific properties like tags that arent part of the MCP specification - The result contains complete component information before its converted to MCP format - Tags and other metadata are stripped when finally returned to the MCP client Execution Operations on_call_tool , on_read_resource , on_get_prompt  - Middleware runs before the component is executed - The middleware result is either the execution result or an error if the component wasnt found - Component metadata isnt directly available in the hook parameters If you need to check component properties like tags during execution operations, use the FastMCP server instance available through the context from fastmcp.server.middleware import Middleware, MiddlewareContext from fastmcp.exceptions import ToolError class TagBasedMiddlewareMiddleware async def on_call_toolself, context MiddlewareContext, call_next  Access the tool object to check its metadata if context.fastmcp_context try tool  await context.fastmcp_context.fastmcp.get_toolcontext.message.name  Check if this tool has a private tag if private in tool.tags raise ToolErrorAccess denied private tool  Check if tool is enabled if not tool.enabled raise ToolErrorTool is currently disabled except Exception  Tool not found or other error - let execution continue  and handle the error naturally pass return await call_nextcontext The same pattern works for resources and prompts from fastmcp.server.middleware import Middleware, MiddlewareContext from fastmcp.exceptions import ResourceError, PromptError class ComponentAccessMiddlewareMiddleware async def on_read_resourceself, context MiddlewareContext, call_next if context.fastmcp_context try resource  await context.fastmcp_context.fastmcp.get_resourcecontext.message.uri if restricted in resource.tags raise ResourceErrorAccess denied restricted resource except Exception pass return await call_nextcontext async def on_get_promptself, context MiddlewareContext, call_next if context.fastmcp_context try prompt  await context.fastmcp_context.fastmcp.get_promptcontext.message.name if not prompt.enabled raise PromptErrorPrompt is currently disabled except Exception pass return await call_nextcontext Working with Listing Results For listing operations, you can inspect and modify the FastMCP components directly from fastmcp.server.middleware import Middleware, MiddlewareContext, ListToolsResult class ListingFilterMiddlewareMiddleware async def on_list_toolsself, context MiddlewareContext, call_next result  await call_nextcontext  Filter out tools with private tag filtered_tools   name tool for name, tool in result.tools.items if private not in tool.tags   Return modified result return ListToolsResulttoolsfiltered_tools This filtering happens before the components are converted to MCP format and returned to the client, so the tags which are FastMCP-specific are naturally stripped in the final response. Anatomy of a Hook Every middleware hook follows the same pattern. Lets examine the on_message hook to understand the structure async def on_messageself, context MiddlewareContext, call_next  1. Pre-processing Inspect and optionally modify the request printfProcessing context.method  2. Chain continuation Call the next middlewarehandler result  await call_nextcontext  3. Post-processing Inspect and optionally modify the response printfCompleted context.method  4. Return the result potentially modified return result Hook Parameters Every hook receives two parameters - context MiddlewareContext - Contains information about the current request context.method - The MCP method name e.g., toolscall context.source - Where the request came from client or server context.type - Message type request or notification context.message - The MCP message data context.timestamp - When the request was received context.fastmcp_context - FastMCP Context object if available - call_next - A function that continues the middleware chain. You must call this to proceed, unless you want to stop processing entirely. Control Flow You have complete control over the request flow - Continue processing Call await call_nextcontext to proceed - Modify the request Change the context before calling call_next - Modify the response Change the result after calling call_next - Stop the chain Dont call call_next rarely needed - Handle errors Wrap call_next in trycatch blocks Creating Middleware FastMCP middleware is implemented by subclassing the Middleware base class and overriding the hooks you need. You only need to implement the hooks that are relevant to your use case. from fastmcp import FastMCP from fastmcp.server.middleware import Middleware, MiddlewareContext class LoggingMiddlewareMiddleware Middleware that logs all MCP operations. async def on_messageself, context MiddlewareContext, call_next Called for all MCP messages. printfProcessing context.method from context.source result  await call_nextcontext printfCompleted context.method return result  Add middleware to your server mcp  FastMCPMyServer mcp.add_middlewareLoggingMiddleware This creates a basic logging middleware that will print information about every request that flows through your server. Adding Middleware to Your Server Single Middleware Adding middleware to your server is straightforward mcp  FastMCPMyServer mcp.add_middlewareLoggingMiddleware Multiple Middleware Middleware executes in the order its added to the server. The first middleware added runs first on the way in, and last on the way out mcp  FastMCPMyServer mcp.add_middlewareAuthenticationMiddlewaresecret-token mcp.add_middlewarePerformanceMiddleware mcp.add_middlewareLoggingMiddleware This creates the following execution flow - AuthenticationMiddleware pre-processing - PerformanceMiddleware pre-processing - LoggingMiddleware pre-processing - Actual toolresource handler - LoggingMiddleware post-processing - PerformanceMiddleware post-processing - AuthenticationMiddleware post-processing Server Composition and Middleware When using Server Composition with mount or import_server , middleware behavior follows these rules - Parent server middleware runs for all requests, including those routed to mounted servers - Mounted server middleware only runs for requests handled by that specific server - Middleware order is preserved within each server This allows you to create layered middleware architectures where parent servers handle cross-cutting concerns like authentication, while child servers focus on domain-specific middleware.  Parent server with middleware parent  FastMCPParent parent.add_middlewareAuthenticationMiddlewaretoken  Child server with its own middleware child  FastMCPChild child.add_middlewareLoggingMiddleware child.tool def child_tool - str return from child  Mount the child server parent.mountchild, prefixchild When a client calls child_tool, the request will flow through the parents authentication middleware first, then route to the child server where it will go through the childs logging middleware. Built-in Middleware Examples FastMCP includes several middleware implementations that demonstrate best practices and provide immediately useful functionality. Lets explore how each type works by building simplified versions, then see how to use the full implementations. Timing Middleware Performance monitoring is essential for understanding your servers behavior and identifying bottlenecks. FastMCP includes timing middleware at fastmcp.server.middleware.timing . Heres an example of how it works import time from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleTimingMiddlewareMiddleware async def on_requestself, context MiddlewareContext, call_next start_time  time.perf_counter try result  await call_nextcontext duration_ms  time.perf_counter - start_time  1000 printfRequest context.method completed in duration_ms.2fms return result except Exception as e duration_ms  time.perf_counter - start_time  1000 printfRequest context.method failed after duration_ms.2fms e raise To use the full version with proper logging and configuration from fastmcp.server.middleware.timing import  TimingMiddleware, DetailedTimingMiddleware   Basic timing for all requests mcp.add_middlewareTimingMiddleware  Detailed per-operation timing tools, resources, prompts mcp.add_middlewareDetailedTimingMiddleware The built-in versions include custom logger support, proper formatting, and DetailedTimingMiddleware provides operation-specific hooks like on_call_tool and on_read_resource for granular timing. Logging Middleware Request and response logging is crucial for debugging, monitoring, and understanding usage patterns in your MCP server. FastMCP provides comprehensive logging middleware at fastmcp.server.middleware.logging . Heres an example of how it works from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleLoggingMiddlewareMiddleware async def on_messageself, context MiddlewareContext, call_next printfProcessing context.method from context.source try result  await call_nextcontext printfCompleted context.method return result except Exception as e printfFailed context.method e raise To use the full versions with advanced features from fastmcp.server.middleware.logging import  LoggingMiddleware, StructuredLoggingMiddleware   Human-readable logging with payload support mcp.add_middlewareLoggingMiddleware include_payloadsTrue, max_payload_length1000   JSON-structured logging for log aggregation tools mcp.add_middlewareStructuredLoggingMiddlewareinclude_payloadsTrue The built-in versions include payload logging, structured JSON output, custom logger support, payload size limits, and operation-specific hooks for granular control. Rate Limiting Middleware Rate limiting is essential for protecting your server from abuse, ensuring fair resource usage, and maintaining performance under load. FastMCP includes sophisticated rate limiting middleware at fastmcp.server.middleware.rate_limiting . Heres an example of how it works import time from collections import defaultdict from fastmcp.server.middleware import Middleware, MiddlewareContext from mcp import McpError from mcp.types import ErrorData class SimpleRateLimitMiddlewareMiddleware def __init__self, requests_per_minute int  60 self.requests_per_minute  requests_per_minute self.client_requests  defaultdictlist async def on_requestself, context MiddlewareContext, call_next current_time  time.time client_id  default  In practice, extract from headers or context  Clean old requests and check limit cutoff_time  current_time - 60 self.client_requestsclient_id   req_time for req_time in self.client_requestsclient_id if req_time  cutoff_time  if lenself.client_requestsclient_id  self.requests_per_minute raise McpErrorErrorDatacode-32000, messageRate limit exceeded self.client_requestsclient_id.appendcurrent_time return await call_nextcontext To use the full versions with advanced algorithms from fastmcp.server.middleware.rate_limiting import  RateLimitingMiddleware, SlidingWindowRateLimitingMiddleware   Token bucket rate limiting allows controlled bursts mcp.add_middlewareRateLimitingMiddleware max_requests_per_second10.0, burst_capacity20   Sliding window rate limiting precise time-based control mcp.add_middlewareSlidingWindowRateLimitingMiddleware max_requests100, window_minutes1  The built-in versions include token bucket algorithms, per-client identification, global rate limiting, and async-safe implementations with configurable client identification functions. Error Handling Middleware Consistent error handling and recovery is critical for robust MCP servers. FastMCP provides comprehensive error handling middleware at fastmcp.server.middleware.error_handling . Heres an example of how it works import logging from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleErrorHandlingMiddlewareMiddleware def __init__self self.logger  logging.getLoggererrors self.error_counts   async def on_messageself, context MiddlewareContext, call_next try return await call_nextcontext except Exception as error  Log the error and track statistics error_key  ftypeerror.__name__context.method self.error_countserror_key  self.error_counts.geterror_key, 0  1 self.logger.errorfError in context.method typeerror.__name__ error raise To use the full versions with advanced features from fastmcp.server.middleware.error_handling import  ErrorHandlingMiddleware, RetryMiddleware   Comprehensive error logging and transformation mcp.add_middlewareErrorHandlingMiddleware include_tracebackTrue, transform_errorsTrue, error_callbackmy_error_callback   Automatic retry with exponential backoff mcp.add_middlewareRetryMiddleware max_retries3, retry_exceptionsConnectionError, TimeoutError  The built-in versions include error transformation, custom callbacks, configurable retry logic, and proper MCP error formatting. Combining Middleware These middleware work together seamlessly from fastmcp import FastMCP from fastmcp.server.middleware.timing import TimingMiddleware from fastmcp.server.middleware.logging import LoggingMiddleware from fastmcp.server.middleware.rate_limiting import RateLimitingMiddleware from fastmcp.server.middleware.error_handling import ErrorHandlingMiddleware mcp  FastMCPProduction Server  Add middleware in logical order mcp.add_middlewareErrorHandlingMiddleware  Handle errors first mcp.add_middlewareRateLimitingMiddlewaremax_requests_per_second50 mcp.add_middlewareTimingMiddleware  Time actual execution mcp.add_middlewareLoggingMiddleware  Log everything mcp.tool def my_tooldata str - str return fProcessed data This configuration provides comprehensive monitoring, protection, and observability for your MCP server. Custom Middleware Example You can also create custom middleware by extending the base class from fastmcp.server.middleware import Middleware, MiddlewareContext class CustomHeaderMiddlewareMiddleware async def on_requestself, context MiddlewareContext, call_next  Add custom logic here printfProcessing context.method result  await call_nextcontext printfCompleted context.method return result mcp.add_middlewareCustomHeaderMiddleware Responses are generated using AI and may contain mistakes.

Keywords: middleware, the, mcp, fastmcp, and, server, context, for, from, import

---

## OpenAPI Integration - FastMCP

URL: https://gofastmcp.com/servers/openapi

--- title OpenAPI Integration - FastMCP description Generate MCP servers from OpenAPI specs and FastAPI apps sitename FastMCP date 2024-05-29 --- Generate MCP servers from OpenAPI specs and FastAPI apps New in version2.0.0 FastMCP can automatically generate an MCP server from an OpenAPI specification or FastAPI app. Instead of manually creating tools and resources, you provide an OpenAPI spec and FastMCP intelligently converts your API endpoints into the appropriate MCP components. To convert an OpenAPI specification to an MCP server, you can use the FastMCP.from_openapi class method. This method takes an OpenAPI specification and an async HTTPX client that can be used to make requests to the API, and returns an MCP server. Heres an example Copy Ask AI import httpxfrom fastmcp import FastMCP Create an HTTP client for your APIclient  httpx.AsyncClientbase_urlhttpsapi.example.com Load your OpenAPI spec openapi_spec  httpx.gethttpsapi.example.comopenapi.json.json Create the MCP servermcp  FastMCP.from_openapi openapi_specopenapi_spec, clientclient, nameMy API Serverif __name__  __main__ mcp.run Thats it! Your entire API is now available as an MCP server. Clients can discover and interact with your API endpoints through the MCP protocol, with full schema validation and type safety. By default, FastMCP converts every endpoint in your OpenAPI specification into an MCP Tool. This provides a simple, predictable starting point that ensures all your APIs functionality is immediately available to the vast majority of LLM clients which only support MCP tools. While this is a pragmatic default for maximum compatibility, you can easily customize this behavior. Internally, FastMCP uses an ordered list of RouteMap objects to determine how to map OpenAPI routes to various MCP component types. Each RouteMap specifies a combination of methods, patterns, and tags, as well as a corresponding MCP component type. Each OpenAPI route is checked against each RouteMap in order, and the first one that matches every criteria is used to determine its converted MCP type. A special type, EXCLUDE, can be used to exclude routes from the MCP server entirely. Methods HTTP methods to match e.g. GET, POST or  for all Pattern Regex pattern to match the route path e.g. rusers. or r. for all Tags A set of OpenAPI tags that must all be present. An empty set  means no tag filtering, so the route matches regardless of its tags. MCP type What MCP component type to create TOOL, RESOURCE, RESOURCE_TEMPLATE, or EXCLUDE MCP tags A set of custom tags to add to components created from matching routes Here is FastMCPs default rule Copy Ask AI from fastmcp.server.openapi import RouteMap, MCPTypeDEFAULT_ROUTE_MAPPINGS    All routes become tools RouteMapmcp_typeMCPType.TOOL, When creating your FastMCP server, you can customize routing behavior by providing your own list of RouteMap objects. Your custom maps are processed before the default route maps, and routes will be assigned to the first matching custom map. For example, prior to FastMCP 2.8.0, GET requests were automatically mapped to Resource and ResourceTemplate components based on whether they had path parameters. This was changed solely for client compatibility reasons. You can restore this behavior by providing custom route maps Copy Ask AI from fastmcp import FastMCPfrom fastmcp.server.openapi import RouteMap, MCPType Restore pre-2.8.0 semantic mappingsemantic_maps    GET requests with path parameters become ResourceTemplates RouteMapmethodsGET, patternr..., mcp_typeMCPType.RESOURCE_TEMPLATE,  All other GET requests become Resources RouteMapmethodsGET, patternr., mcp_typeMCPType.RESOURCE,mcp  FastMCP.from_openapi ..., route_mapssemantic_maps, With these maps, GET requests are handled semantically, and all other methods POST, PUT, etc. will fall through to the default rule and become Tools. Here is a more complete example that uses custom route maps to convert all GET endpoints under analytics to tools while excluding all admin endpoints and all routes tagged internal. All other routes will be handled by the default rules Or you can use a catch-all rule to exclude everything that your maps dont handle explicitly Copy Ask AI from fastmcp import FastMCPfrom fastmcp.server.openapi import RouteMap, MCPTypemcp  FastMCP.from_openapi ..., route_maps  custom mapping logic goes here ...,  exclude all remaining routes RouteMapmcp_typeMCPType.EXCLUDE, , Using a catch-all exclusion rule will prevent the default route mappings from being applied, since it will match every remaining route. This is useful if you want to explicitly allow-list certain routes. For advanced use cases that require more complex logic, you can provide a route_map_fn callable. After the route map logic is applied, this function is called on each matched route and its assigned MCP component type. It can optionally return a different component type to override the mapped assignment. If it returns None, the assigned type is used. In addition to more precise targeting of methods, patterns, and tags, this function can access any additional OpenAPI metadata about the route. The route_map_fnis called on routes that matched MCPType.EXCLUDE in your custom maps, giving you an opportunity to override the exclusion. Copy Ask AI from fastmcp import FastMCPfrom fastmcp.server.openapi import RouteMap, MCPType, HTTPRoutedef custom_route_mapperroute HTTPRoute, mcp_type MCPType - MCPType  None Advanced route type mapping.  Convert all admin routes to tools regardless of HTTP method if admin in route.path return MCPType.TOOL elif internal in route.tags return MCPType.EXCLUDE  Convert user detail routes to templates even if theyre POST elif route.path.startswithusers and route.method  POST return MCPType.RESOURCE_TEMPLATE  Use defaults for all other routes return Nonemcp  FastMCP.from_openapi ..., route_map_fncustom_route_mapper, FastMCP provides several ways to add tags to your MCP components, allowing you to categorize and organize them for better discoverability and filtering. Tags are combined from multiple sources to create the final set of tags on each component. You can add custom tags to components created from specific routes using the mcp_tags parameter in RouteMap. These tags will be applied to all components created from routes that match that particular route map. Copy Ask AI from fastmcp import FastMCPfrom fastmcp.server.openapi import RouteMap, MCPTypemcp  FastMCP.from_openapi ..., route_maps  Add custom tags to all POST endpoints RouteMap methodsPOST, patternr., mcp_typeMCPType.TOOL, mcp_tagswrite-operation, api-mutation ,  Add different tags to detail view endpoints RouteMap methodsGET, patternr..., mcp_typeMCPType.RESOURCE_TEMPLATE, mcp_tagsdetail-view, parameterized ,  Add tags to list endpoints RouteMap methodsGET, patternr., mcp_typeMCPType.RESOURCE, mcp_tagslist-data, collection , , You can add tags to all components by providing a tags parameter when creating your FastMCP server with from_openapi or from_fastapi. These global tags will be applied to every component created from your OpenAPI specification. FastMCP automatically generates names for MCP components based on the OpenAPI specification. By default, it uses the operationId from your OpenAPI spec, up to the first double underscore __. All component names are automatically Slugified Spaces and special characters are converted to underscores or removed Truncated Limited to 56 characters maximum to ensure compatibility Unique If multiple components have the same name, a number is automatically appended to make them unique For more control over component names, you can provide an mcp_names dictionary that maps operationId values to your desired names. The operationId must be exactly as it appears in the OpenAPI spec. The provided name will always be slugified and truncated. By default, FastMCP creates MCP components using a variety of metadata from the OpenAPI spec, such as incorporating the OpenAPI description into the MCP component description. At times you may want to modify those MCP components in a variety of ways, such as adding LLM-specific instructions or tags. For fine-grained customization, you can provide a mcp_component_fn when creating the MCP server. After each MCP component has been created, this function is called on it and has the opportunity to modify it in-place. Your mcp_component_fn is expected to modify the component in-place, not to return a new component. The result of the function is ignored. Copy Ask AI from fastmcp import FastMCPfrom fastmcp.server.openapi import  HTTPRoute, OpenAPITool, OpenAPIResource, OpenAPIResourceTemplate,def customize_components route HTTPRoute, component OpenAPITool  OpenAPIResource  OpenAPIResourceTemplate, - None  Add custom tags to all components component.tags.addopenapi  Customize based on component type if isinstancecomponent, OpenAPITool component.description  f component.description via API if isinstancecomponent, OpenAPIResource component.description  f component.description component.tags.adddatamcp  FastMCP.from_openapi ..., mcp_component_fncustomize_components, By default, FastMCP only includes query parameters that have non-empty values. Parameters with None values or empty strings are automatically filtered out. Copy Ask AI  When calling this tool...await client.call_toolsearch_products,  category electronics,   Included min_price 100,   Included max_price None,   Excluded brand ,   Excluded The HTTP request will be GET products?categoryelectronicsmin_price100

Keywords: the, fastmcp, mcp, openapi, and, tags, all, component, from, your

---

## Prompts - FastMCP

URL: https://gofastmcp.com/servers/prompts

--- title Prompts - FastMCP description Create reusable, parameterized prompt templates for MCP clients. sitename FastMCP date 2024-05-29 --- Create reusable, parameterized prompt templates for MCP clients. Prompts are reusable message templates that help LLMs generate structured, purposeful responses. FastMCP simplifies defining these templates, primarily using the mcp.prompt decorator. Prompts provide parameterized message templates for LLMs. When a client requests a prompt This allows you to define consistent, reusable templates that LLMs can use across different clients and contexts. prompt DecoratorThe most common way to define a prompt is by decorating a Python function. The decorator uses the function name as the prompts identifier. Key Concepts ask_about_topic .Functions with args or kwargs are not supported as prompts. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isnt possible with variable argument lists. While FastMCP infers the name and description from your function, you can override these and add additional metadata using arguments to the mcp.prompt decorator Sets the explicit prompt name exposed via MCP. If not provided, uses the function name Provides the description exposed via MCP. If set, the functions docstring is ignored for this purpose A set of strings used to categorize the prompt. Clients might use tags to filter or group available prompts A boolean to enable or disable the prompt. See Disabling Prompts for more information New in version 2.9.0 The MCP specification requires that all prompt arguments be passed as strings, but FastMCP allows you to use typed annotations for better developer experience. When you use complex types like listint or dictstr, str , FastMCP Since the MCP specification only allows string arguments, clients need to know what string format to use for complex types. FastMCP solves this by automatically enhancing the argument descriptions with JSON schema information, making it clear to both humans and LLMs how to format their arguments. MCP clients will call this prompt with string arguments But you can still call it directly with proper types Keep your type annotations simple when using this feature. Complex nested types or custom classes may not convert reliably from JSON strings. The automatically generated schema descriptions are the only guidance users receive about the expected format. Good choices listint , dictstr, str , float , bool Avoid Complex Pydantic models, deeply nested structures, custom classes FastMCP intelligently handles different return types from your prompt function str  Automatically converted to a single PromptMessage .PromptMessage  Used directly as provided. Note a more user-friendly Message constructor is available that can accept raw strings instead of TextContent objects.listPromptMessage  str  Used as a sequence of messages a conversation.Any  If the return type is not one of the above, the return value is attempted to be converted to a string and used as a PromptMessage .Parameters in your function signature are considered required unless they have a default value. In this example, the client must provide data_uri . If analysis_type or include_charts are omitted, their default values will be used. New in version 2.8.0 You can control the visibility and availability of prompts by enabling or disabling them. Disabled prompts will not appear in the list of available prompts, and attempting to call a disabled prompt will result in an Unknown prompt error. By default, all prompts are enabled. You can disable a prompt upon creation using the enabled parameter in the decorator You can also toggle a prompts state programmatically after it has been created FastMCP seamlessly supports both standard def  and asynchronous async def  functions as prompts. Use async def when your prompt function performs IO operations like network requests, database queries, file IO, or external service calls. New in version 2.2.5 Prompts can access additional MCP information and features through the Context object. To access it, add a parameter to your prompt function with a type annotation of Context  For full documentation on the Context object and all its capabilities, see the Context documentation. New in version 2.9.1 FastMCP automatically sends notificationspromptslist_changed notifications to connected clients when prompts are added, enabled, or disabled. This allows clients to stay up-to-date with the current prompt set without manually polling for changes. Notifications are only sent when these operations occur within an active MCP request context e.g., when called from within a tool or other MCP operation. Operations performed during server initialization do not trigger notifications. Clients can handle these notifications using a message handler to automatically refresh their prompt lists or update their interfaces. New in version 2.1.0 You can configure how the FastMCP server handles attempts to register multiple prompts with the same name. Use the on_duplicate_prompts setting during FastMCP initialization. The duplicate behavior options are warn default Logs a warning, and the new prompt replaces the old one.error  Raises a ValueError , preventing the duplicate registration.replace  Silently replaces the existing prompt with the new one.ignore  Keeps the original prompt and ignores the new registration attempt.

Keywords: the, prompt, prompts, fastmcp, mcp, and, for, can, clients, are

---

## Proxy Servers - FastMCP

URL: https://gofastmcp.com/servers/proxy

--- title Proxy Servers - FastMCP description Use FastMCP to act as an intermediary or change transport for other MCP servers. sitename FastMCP date 2024-05-29 --- New in version 2.0.0 FastMCP provides a powerful proxying capability that allows one FastMCP server instance to act as a frontend for another MCP server which could be remote, running on a different transport, or even another FastMCP instance. This is achieved using the FastMCP.as_proxy class method. as_proxy accepts either an existing Client or any argument that can be passed to a Client as its transport parametersuch as another FastMCP instance, a URL to a remote server, or an MCP configuration dictionary. What is Proxying? Proxying means setting up a FastMCP server that doesnt implement its own tools or resources directly. Instead, when it receives a request like toolscall or resourcesread , it forwards that request to a backend MCP server, receives the response, and then relays that response back to the original client. Use Cases - Transport Bridging Expose a server running on one transport e.g., a remote SSE server via a different transport e.g., local Stdio for Claude Desktop. - Adding Functionality Insert a layer in front of an existing server to add caching, logging, authentication, or modify requestsresponses though direct modification requires subclassing FastMCPProxy . - Security Boundary Use the proxy as a controlled gateway to an internal server. - Simplifying Client Configuration Provide a single, stable endpoint the proxy even if the backend servers location or transport changes. Creating a Proxy The easiest way to create a proxy is using the FastMCP.as_proxy class method. This creates a standard FastMCP server that forwards requests to another MCP server. from fastmcp import FastMCP  Provide the backend in any form accepted by Client proxy_server  FastMCP.as_proxy backend_server.py,  Could also be a FastMCP instance, config dict, or a remote URL nameMyProxyServer  Optional settings for the proxy   Or create the Client yourself for custom configuration backend_client  Clientbackend_server.py proxy_from_client  FastMCP.as_proxybackend_client How as_proxy Works - It connects to the backend server using the provided client. - It discovers all the tools, resources, resource templates, and prompts available on the backend server. - It creates corresponding proxy components that forward requests to the backend. - It returns a standard FastMCP server instance that can be used like any other. Currently, proxying focuses primarily on exposing the major MCP objects tools, resources, templates, and prompts. Some advanced MCP features like notifications and sampling are not fully supported in proxies in the current version. Support for these additional features may be added in future releases. Bridging Transports A common use case is to bridge transports. For example, making a remote SSE server available locally via Stdio from fastmcp import FastMCP  Target a remote SSE server directly by URL proxy  FastMCP.as_proxyhttpexample.commcpsse, nameSSE to Stdio Proxy  The proxy can now be used with any transport  No special handling needed - it works like any FastMCP server In-Memory Proxies You can also proxy an in-memory FastMCP instance, which is useful for adjusting the configuration or behavior of a server you dont completely control. from fastmcp import FastMCP  Original server original_server  FastMCPnameOriginal original_server.tool def tool_a - str return A  Create a proxy of the original server directly proxy  FastMCP.as_proxy original_server, nameProxy Server   proxy is now a regular FastMCP server that forwards  requests to original_server Configuration-Based Proxies New in version 2.4.0 You can create a proxy directly from a configuration dictionary that follows the MCPConfig schema. This is useful for quickly setting up proxies to remote servers without manually configuring each connection detail. from fastmcp import FastMCP  Create a proxy directly from a config dictionary config   mcpServers  default   For single server configs, default is commonly used url httpsexample.commcp, transport http     Create a proxy to the configured server proxy  FastMCP.as_proxyconfig, nameConfig-Based Proxy  Run the proxy with stdio transport for local access if __name__  __main__ proxy.run The MCPConfig format follows an emerging standard for MCP server configuration and may evolve as the specification matures. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change. You can also use MCPConfig to create a proxy to multiple servers. When multiple servers are specified, they are automatically mounted with their config names as prefixes, providing a unified interface to all servers from fastmcp import FastMCP  Multi-server configuration config   mcpServers  weather  url httpsweather-api.example.commcp, transport http , calendar  url httpscalendar-api.example.commcp, transport http     Create a proxy to multiple servers composite_proxy  FastMCP.as_proxyconfig, nameComposite Proxy  Tools and resources are accessible with prefixes  - weather_get_forecast, calendar_add_event  - weatherweathericonssunny, calendarcalendareventstoday FastMCPProxy Class Internally, FastMCP.as_proxy uses the FastMCPProxy class. You generally dont need to interact with this class directly, but its available if needed. Using the class directly might be necessary for advanced scenarios, like subclassing FastMCPProxy to add custom logic before or after forwarding requests. Responses are generated using AI and may contain mistakes.

Keywords: fastmcp, the, server, proxy, for, transport, that, servers, mcp, configuration

---

## Resources & Templates - FastMCP

URL: https://gofastmcp.com/servers/resources

--- title Resources  Templates - FastMCP description Expose data sources and dynamic content generators to your MCP client. sitename FastMCP date 2024-05-29 --- Expose data sources and dynamic content generators to your MCP client. Resources represent data or files that an MCP client can read, and resource templates extend this concept by allowing clients to request dynamically generated resources based on parameters passed in the URI. FastMCP simplifies defining both static and dynamic resources, primarily using the mcp.resource decorator. Resources provide read-only access to data for the LLM or client application. When a client requests a resource URI This allows LLMs to access files, database content, configuration, or dynamically generated information relevant to the conversation. resource DecoratorThe most common way to define a resource is by decorating a Python function. The decorator requires the resources unique URI. Key Concepts resource is the unique URI e.g., resourcegreeting  clients use to request this data.get_greeting , get_config  is only executed when a client specifically requests that resource URI via resourcesread .get_greeting .You can customize the resources properties using arguments in the mcp.resource decorator The unique identifier for the resource A human-readable name. If not provided, defaults to function name Explanation of the resource. If not provided, defaults to docstring Specifies the content type. FastMCP often infers a default like textplain or applicationjson , but explicit is better for non-text types A set of strings for categorization, potentially used by clients for filtering A boolean to enable or disable the resource. See Disabling Resources for more information FastMCP automatically converts your functions return value into the appropriate MCP resource content str  Sent as TextResourceContents with mime_typetextplain by default.dict , list , pydantic.BaseModel  Automatically serialized to a JSON string and sent as TextResourceContents with mime_typeapplicationjson by default.bytes  Base64 encoded and sent as BlobResourceContents . You should specify an appropriate mime_type e.g., imagepng , applicationoctet-stream .None  Results in an empty resource content list being returned.New in version 2.8.0 You can control the visibility and availability of resources and templates by enabling or disabling them. Disabled resources will not appear in the list of available resources or templates, and attempting to read a disabled resource will result in an Unknown resource error. By default, all resources are enabled. You can disable a resource upon creation using the enabled parameter in the decorator You can also toggle a resources state programmatically after it has been created New in version 2.2.5 Resources and resource templates can access additional MCP information and features through the Context object. To access it, add a parameter to your resource function with a type annotation of Context  For full documentation on the Context object and all its capabilities, see the Context documentation. Use async def for resource functions that perform IO operations e.g., reading from a database or network to avoid blocking the server. While mcp.resource is ideal for dynamic content, you can directly register pre-defined resources like static files or simple text using mcp.add_resource and concrete Resource subclasses. Common Resource Classes TextResource  For simple string content.BinaryResource  For raw bytes content.FileResource  Reads content from a local file path. Handles textbinary modes and lazy reading.HttpResource  Fetches content from an HTTPS URL requires httpx .DirectoryResource  Lists files in a local directory returns JSON.FunctionResource  Internal class used by mcp.resource .Use these when the content is static or sourced directly from a fileURL, bypassing the need for a dedicated Python function. New in version 2.2.0 When adding resources directly with mcp.add_resource , you can optionally provide a custom storage key Note that this parameter is only available when using add_resource directly and not through the resource decorator, as URIs are provided explicitly when using the decorator. New in version 2.9.1 FastMCP automatically sends notificationsresourceslist_changed notifications to connected clients when resources or templates are added, enabled, or disabled. This allows clients to stay up-to-date with the current resource set without manually polling for changes. Notifications are only sent when these operations occur within an active MCP request context e.g., when called from within a tool or other MCP operation. Operations performed during server initialization do not trigger notifications. Clients can handle these notifications using a message handler to automatically refresh their resource lists or update their interfaces. Resource Templates allow clients to request resources whose content depends on parameters embedded in the URI. Define a template using the same mcp.resource decorator, but include parameter_name placeholders in the URI string and add corresponding arguments to your function signature. Resource templates share most configuration options with regular resources name, description, mime_type, tags, but add the ability to define URI parameters that map to function parameters. Resource templates generate a new resource for each unique set of parameters, which means that resources can be dynamically created on-demand. For example, if the resource template userprofilename is registered, MCP clients could request userprofileford or userprofilemarvin to retrieve either of those two user profiles as resources, without having to register each resource individually. Functions with args are not supported as resource templates. However, unlike tools and prompts, resource templates do support kwargs because the URI template defines specific parameter names that will be collected and passed as keyword arguments. Here is a complete example that shows how to define two resource templates With these two templates defined, clients can request a variety of resources weatherlondoncurrent  Returns weather for Londonweatherpariscurrent  Returns weather for Parisreposjlowinfastmcpinfo  Returns info about the jlowinfastmcp repositoryreposprefecthqprefectinfo  Returns info about the prefecthqprefect repositoryNew in version 2.2.4 Please note FastMCPs support for wildcard parameters is an extension of the Model Context Protocol standard, which otherwise follows RFC 6570. Since all template processing happens in the FastMCP server, this should not cause any compatibility issues with other MCP implementations. Resource templates support wildcard parameters that can match multiple path segments. While standard parameters param  only match a single path segment and dont cross  boundaries, wildcard parameters param  can capture multiple segments including slashes. Wildcards capture all subsequent path segments up until the defined part of the URI template whether literal or another parameter. This allows you to have multiple wildcard parameters in a single URI template. Wildcard parameters are useful when Note that like regular parameters, each wildcard parameter must still be a named parameter in your function signature, and all required function parameters must appear in the URI template. New in version 2.2.0 When creating resource templates, FastMCP enforces two rules for the relationship between URI template parameters and function parameters However, function parameters with default values dont need to be included in the URI template. When a client requests a resource, FastMCP will This allows for flexible API designs. For example, a simple search template with optional parameters With this template, clients can request searchpython and the function will be called with querypython, max_results10, include_archivedFalse . MCP Developers can still call the underlying search_resources function directly with more specific parameters. An even more powerful pattern is registering a single function with multiple URI templates, allowing different ways to access the same data Now an LLM or client can retrieve user information in two different ways usersemailaliceexample.com  Looks up user by email with nameNoneusersnameBob  Looks up user by name with emailNoneIn this stacked decorator pattern name parameter is only provided when using the usersnamename templateemail parameter is only provided when using the usersemailemail templateNone when not included in the URITemplates provide a powerful way to expose parameterized data access points following REST-like principles. New in version 2.4.1 If your resource function encounters an error, you can raise a standard Python exception ValueError , TypeError , FileNotFoundError , custom exceptions, etc. or a FastMCP ResourceError . By default, all exceptions including their details are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately. If you want to mask internal error details for security reasons, you can mask_error_detailsTrue parameter when creating your FastMCP instanceResourceError to explicitly control what error information is sent to clientsWhen mask_error_detailsTrue , only error messages from ResourceError will include details, other exceptions will be converted to a generic message. New in version 2.1.0 You can configure how the FastMCP server handles attempts to register multiple resources or templates with the same URI. Use the on_duplicate_resources setting during FastMCP initialization. The duplicate behavior options are warn default Logs a warning, and the new resourcetemplate replaces the old one.error  Raises a ValueError , preventing the duplicate registration.replace  Silently replaces the existing resourcetemplate with the new one.ignore  Keeps the original resourcetemplate and ignores the new registration attempt.

Keywords: the, resource, and, resources, for, can, with, mcp, parameters, templates

---

## The FastMCP Server - FastMCP

URL: https://gofastmcp.com/servers/server

--- title The FastMCP Server - FastMCP description The core FastMCP server class for building MCP applications with tools, resources, and prompts. sitename FastMCP date 2024-05-29 --- The core FastMCP server class for building MCP applications with tools, resources, and prompts. The central piece of a FastMCP application is the FastMCP server class. This class acts as the main container for your applications tools, resources, and prompts, and manages communication with MCP clients. Instantiating a server is straightforward. You typically provide a name for your server, which helps identify it in client applications or logs. The FastMCP constructor accepts several arguments A human-readable name for your server Description of how to interact with this server. These instructions help clients understand the servers purpose and available functionality An async context manager function for server startup and shutdown logic A set of strings to tag the server itself A list of tools or functions to convert to tools to add to the server. In some cases, providing tools programmatically may be more convenient than using the mcp.tool decorator Keyword arguments corresponding to additional ServerSettings configuration FastMCP servers expose several types of components to the client Tools are functions that the client can call to perform actions or access external systems. See Tools for detailed documentation. Resources expose data sources that the client can read. See Resources  Templates for detailed documentation. Resource templates are parameterized resources that allow the client to request specific data. See Resources  Templates for detailed documentation. Prompts are reusable message templates for guiding the LLM. See Prompts for detailed documentation. New in version 2.8.0 FastMCP supports tag-based filtering to selectively expose components based on configurable includeexclude tag sets. This is useful for creating different views of your server for different environments or users. Components can be tagged when defined using the tags parameter The filtering logic works as follows To ensure a component is never exposed, you can set enabledFalse on the component itself. To learn more, see the component-specific documentation. You configure tag-based filtering when creating your server This filtering applies to all component types tools, resources, resource templates, and prompts and affects both listing and access. FastMCP servers need a transport mechanism to communicate with clients. You typically start your server by calling the mcp.run method on your FastMCP instance, often within an if __name__  __main__ block in your main server script. This pattern ensures compatibility with various MCP clients. FastMCP supports several transport options The server can also be run using the FastMCP CLI. For detailed information on each transport, how to configure them host, port, paths, and when to use which, please refer to the Running Your FastMCP Server guide. New in version 2.2.0 FastMCP supports composing multiple servers together using import_server static copy and mount live link. This allows you to organize large applications into modular components or reuse existing servers. See the Server Composition guide for full details, best practices, and examples. New in version 2.0.0 FastMCP can act as a proxy for any MCP server local or remote using FastMCP.as_proxy , letting you bridge transports or add a frontend to existing servers. For example, you can expose a remote SSE server locally via stdio, or vice versa. See the Proxying Servers guide for details and advanced usage. Servers can be configured using a combination of initialization arguments, global settings, and transport-specific settings. Server-specific settings are passed when creating the FastMCP instance and control server behavior Optional server dependencies list with package specifications Only expose components with at least one matching tag Hide components with any matching tag How to handle duplicate tool registrations How to handle duplicate resource registrations How to handle duplicate prompt registrations Global settings affect all FastMCP servers and can be configured via environment variables prefixed with FASTMCP_  or in a .env file Common global settings include log_level  Logging level DEBUG, INFO, WARNING, ERROR, CRITICAL, set with FASTMCP_LOG_LEVEL mask_error_details  Whether to hide detailed error information from clients, set with FASTMCP_MASK_ERROR_DETAILS resource_prefix_format  How to format resource prefixes path or protocol, set with FASTMCP_RESOURCE_PREFIX_FORMAT Transport settings are provided when running the server and control network behavior Settings can be configured via environment variables New in version 2.2.7 By default, FastMCP serializes tool return values to JSON when they need to be converted to text. You can customize this behavior by providing a tool_serializer function when creating your server The serializer function takes any data object and returns a string representation. This is applied to all non-string return values from your tools. Tools that already return strings bypass the serializer. This customization is useful when you want to If the serializer function raises an exception, the tool will fall back to the default JSON serialization to avoid breaking the server.

Keywords: the, server, fastmcp, for, and, with, tools, your, can, this

---

## Tools - FastMCP

URL: https://gofastmcp.com/servers/tools

--- title Tools - FastMCP description Expose functions as executable capabilities for your MCP client. sitename FastMCP date 2023-04-15 --- Expose functions as executable capabilities for your MCP client. Tools are the core building blocks that allow your LLM to interact with external systems, execute code, and access data that isnt in its training data. In FastMCP, tools are Python functions exposed to LLMs through the MCP protocol. Tools in FastMCP transform regular Python functions into capabilities that LLMs can invoke during conversations. When an LLM decides to use a tool It sends a request with parameters based on the tools schema. FastMCP validates these parameters against your functions signature. Your function executes with the validated inputs. The result is returned to the LLM, which can use it in its response. This allows LLMs to perform tasks like querying databases, calling APIs, making calculations, or accessing filesextending their capabilities beyond whats in their training data. Creating a tool is as simple as decorating a Python function with mcp.tool Copy Ask AI from fastmcp import FastMCPmcp  FastMCPnameCalculatorServermcp.tooldef adda int, b int - int Adds two integer numbers together. return a  b When this tool is registered, FastMCP automatically Uses the function name add as the tool name. Uses the functions docstring Adds two integer numbers... as the tool description. Generates an input schema based on the functions parameters and type annotations. Handles parameter validation and error reporting. The way you define your Python function dictates how the tool appears and behaves for the LLM client. Functions with args or kwargs are not supported as tools. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isnt possible with variable argument lists. While FastMCP infers the name and description from your function, you can override these and add additional metadata using arguments to the mcp.tool decorator Copy Ask AI mcp.tool namefind_products,  Custom tool name for the LLM descriptionSearch the product catalog with optional category filtering.,  Custom description tagscatalog, search,  Optional tags for organizationfilteringdef search_products_implementationquery str, category str  None  None - listdict Internal function description ignored if description is provided above.  Implementation... printfSearching for query in category category return id 2, name Another Product You can provide additional metadata about parameters using Pydantics Field class with Annotated. This approach is preferred as its more modern and keeps type hints separate from validation rules Copy Ask AI from typing import Annotatedfrom pydantic import Fieldmcp.tooldef process_image image_url Annotatedstr, FielddescriptionURL of the image to process, resize Annotatedbool, FielddescriptionWhether to resize the image  False, width Annotatedint, FielddescriptionTarget width in pixels, ge1, le2000  800, format Annotated Literaljpeg, png, webp, FielddescriptionOutput image format   jpeg - dict Process an image with optional resizing.  Implementation... You can also use the Field as a default value, though the Annotated approach is preferred Copy Ask AI mcp.tooldef search_database query str  FielddescriptionSearch query string, limit int  Field10, descriptionMaximum number of results, ge1, le100 - list Search the database with the provided query.  Implementation... Field provides several validation and documentation features description Human-readable explanation of the parameter shown to LLMs gegtlelt Greaterless than or equal constraints min_lengthmax_length String or collection length constraints FastMCP follows Pythons standard function parameter conventions. Parameters without default values are required, while those with default values are optional. Copy Ask AI mcp.tooldef search_products query str,  Required - no default value max_results int  10,  Optional - has default value sort_by str  relevance,  Optional - has default value category str  None  None  Optional - can be None - listdict Search the product catalog.  Implementation... In this example, the LLM must provide a query parameter, while max_results, sort_by, and category will use their default values if not explicitly provided. You can exclude certain arguments from the tool schema shown to the LLM. This is useful for arguments that are injected at runtime such as state, user_id, or credentials and should not be exposed to the LLM or client. Only arguments with default values can be excluded attempting to exclude a required argument will raise an error. Example Copy Ask AI mcp.tool nameget_user_details, exclude_argsuser_iddef get_user_detailsuser_id str  None - str  user_id will be injected by the server, not provided by the LLM ... With this configuration, user_id will not appear in the tools parameter schema, but can still be set by the server or framework at runtime. You can control the visibility and availability of tools by enabling or disabling them. This is useful for feature flagging, maintenance, or dynamically changing the toolset available to a client. Disabled tools will not appear in the list of available tools returned by list_tools, and attempting to call a disabled tool will result in an Unknown tool error, just as if the tool did not exist. By default, all tools are enabled. You can disable a tool upon creation using the enabled parameter in the decorator Copy Ask AI mcp.toolenabledFalsedef maintenance_tool This tool is currently under maintenance. return This tool is disabled. You can also toggle a tools state programmatically after it has been created Copy Ask AI mcp.tooldef dynamic_tool return I am a dynamic tool. Disable and re-enable the tooldynamic_tool.disabledynamic_tool.enable FastMCP seamlessly supports both standard def and asynchronous async def functions as tools. Copy Ask AI  Synchronous tool suitable for CPU-bound or quick tasksmcp.tooldef calculate_distancelat1 float, lon1 float, lat2 float, lon2 float - float Calculate the distance between two coordinates.  Implementation... return 42.5 Asynchronous tool ideal for IO-bound operationsmcp.toolasync def fetch_weathercity str - dict Retrieve current weather conditions for a city.  Use async def for operations involving network calls, file IO, etc.  This prevents blocking the server while waiting for external operations. async with aiohttp.ClientSession as session async with session.getfhttpsapi.example.comweathercity as response  Check response status before returning response.raise_for_status return await response.json Use async def when your tool needs to perform operations that might wait for external systems network requests, database queries, file access to keep your server responsive. FastMCP automatically converts the value returned by your function into the appropriate MCP content format for the client str Sent as TextContent. dict, list, Pydantic BaseModel Serialized to a JSON string and sent as TextContent. bytes Base64 encoded and sent as BlobResourceContents often within an EmbeddedResource. fastmcp.utilities.types.Image A helper class for easily returning image data. Sent as ImageContent. fastmcp.utilities.types.Audio A helper class for easily returning audio data. Sent as AudioContent. fastmcp.utilities.types.File A helper class for easily returning binary data as base64-encoded content. Sent as EmbeddedResource. A list of any of the above Automatically converts each item appropriately. None Results in an empty response no content is sent back to the client. FastMCP will attempt to serialize other types to a string if possible. At this time, FastMCP responds only to your tools return value, not its return annotation. Copy Ask AI from fastmcp import FastMCPfrom fastmcp.utilities.types import Imageimport iotry from PIL import Image as PILImageexcept ImportError raise ImportErrorPlease install the pillow library to run this example.mcp  FastMCPImage Demomcp.tooldef generate_imagewidth int, height int, color str - Image Generates a solid color image.  Create image using Pillow img  PILImage.newRGB, width, height, colorcolor  Save to a bytes buffer buffer  io.BytesIO img.savebuffer, formatPNG img_bytes  buffer.getvalue  Return using FastMCPs Image helper return Imagedataimg_bytes, formatpngmcp.tooldef do_nothing - None This tool performs an action but returns no data. printPerforming a side effect... return None If your tool encounters an error, you can raise a standard Python exception ValueError, TypeError, FileNotFoundError, custom exceptions, etc. or a FastMCP ToolError. By default, all exceptions including their details are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately. If you want to mask internal error details for security reasons, you can Use the mask_error_detailsTrue parameter when creating your FastMCP instance Or use ToolError to explicitly control what error information is sent to clients Copy Ask AI from fastmcp import FastMCPfrom fastmcp.exceptions import ToolErrormcp.tooldef dividea float, b float - float Divide a by b. if b  0  Error messages from ToolError are always sent to clients,  regardless of mask_error_details setting raise ToolErrorDivision by zero is not allowed.  If mask_error_detailsTrue, this message would be masked if not isinstancea, int, float or not isinstanceb, int, float raise TypeErrorBoth arguments must be numbers. return a  b When mask_error_detailsTrue, only error messages from ToolError will include details, other exceptions will be converted to a generic message. FastMCP allows you to add specialized metadata to your tools through annotations. These annotations communicate how tools behave to client applications without consuming token context in LLM prompts. Annotations serve several purposes in client applications Adding user-friendly titles for display purposes Indicating whether tools modify data or systems Describing the safety profile of tools destructive vs. non-destructive Signaling if tools interact with external systems You can add annotations to a tool using the annotations parameter in the mcp.tool decorator Copy Ask AI mcp.tool annotations title Calculate Sum, readOnlyHint True, openWorldHint False def calculate_suma float, b float - float Add two numbers together. return a  b FastMCP supports these standard annotations Remember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and safety controls, but wont enforce security boundaries on their own. Always focus on making your annotations accurately represent what your tool actually does. FastMCP automatically sends notificationstoolslist_changed notifications to connected clients when tools are added, removed, enabled, or disabled. This allows clients to stay up-to-date with the current tool set without manually polling for changes. Notifications are only sent when these operations occur within an active MCP request context e.g., when called from within a tool or other MCP operation. Operations performed during server initialization do not trigger notifications. Clients can handle these notifications using a message handler to automatically refresh their tool lists or update their interfaces. Tools can access MCP features like logging, reading resources, or reporting progress through the Context object. To use it, add a parameter to your tool function with the type hint Context. Copy Ask AI from fastmcp import FastMCP, Contextmcp  FastMCPnameContextDemomcp.toolasync def process_datadata_uri str, ctx Context - dict Process data from a resource with progress reporting. await ctx.infofProcessing data from data_uri  Read a resource resource  await ctx.read_resourcedata_uri data  resource0.content if resource else   Report progress await ctx.report_progressprogress50, total100  Example request to the clients LLM for help summary  await ctx.samplefSummarize this in 10 words data200 await ctx.report_progressprogress100, total100 return  length lendata, summary summary.text  FastMCP supports a wide variety of parameter types to give you flexibility when designing your tools. FastMCP generally supports all types that Pydantic supports as fields, including all Pydantic custom types. This means you can use any type that can be validated and parsed by Pydantic in your tool parameters. FastMCP supports type coercion when possible. This means that if a client sends data that doesnt match the expected type, FastMCP will attempt to convert it to the appropriate type. For example, if a client sends a string for a parameter annotated as int, FastMCP will attempt to convert it to an integer. If the conversion is not possible, FastMCP will return a validation error. The most common parameter types are Pythons built-in scalar types Copy Ask AI mcp.tooldef process_values name str,  Text data count int,  Integer numbers amount float,  Floating point numbers enabled bool  Boolean values TrueFalse Process various value types.  Implementation... These types provide clear expectations to the LLM about what values are acceptable and allow FastMCP to validate inputs properly. Even if a client provides a string like 42, it will be coerced to an integer for parameters annotated as int. FastMCP supports various date and time types from the datetime module Copy Ask AI from datetime import datetime, date, timedeltamcp.tooldef process_date_time event_date date,  ISO format date string or date object event_time datetime,  ISO format datetime string or datetime object duration timedelta  timedeltahours1  Integer seconds or timedelta - str Process date and time information.  Types are automatically converted from strings assert isinstanceevent_date, date assert isinstanceevent_time, datetime assert isinstanceduration, timedelta return fEvent on event_date at event_time for duration datetime - Accepts ISO format strings e.g., 2023-04-15T143000 date - Accepts ISO format date strings e.g., 2023-04-15 timedelta - Accepts integer seconds or timedelta objects FastMCP supports all standard Python collection types Copy Ask AI mcp.tooldef analyze_data values listfloat,  List of numbers properties dictstr, str,  Dictionary with string keys and values unique_ids setint,  Set of unique integers coordinates tuplefloat, float,  Tuple with fixed structure mixed_data dictstr, listint  Nested collections Analyze collections of data.  Implementation... All collection types can be used as parameter annotations listT - Ordered sequence of items dictK, V - Key-value mapping setT - Unordered collection of unique items tupleT1, T2, ... - Fixed-length sequence with potentially different types Collection types can be nested and combined to represent complex data structures. JSON strings that match the expected structure will be automatically parsed and converted to the appropriate Python collection type. For more structured sets of constrained values, use Pythons Enum class Copy Ask AI from enum import Enumclass ColorEnum RED  red GREEN  green BLUE  bluemcp.tooldef process_image image_path str, color_filter Color  Color.RED Process an image with a color filter.  Implementation...  color_filter will be a Color enum member When using Enum types Clients should provide the enums value e.g., red, not the enum member name e.g., RED FastMCP automatically coerces the string value into the appropriate Enum object Your function receives the actual Enum member e.g., Color.RED Validation errors are raised for values not in the enum mcp.tooldef process_binarydata bytes Process binary data directly. The client can send a binary string, which will be converted directly to bytes.   Implementation using binary data data_length  lendata  ... When you annotate a parameter as bytes, FastMCP will Convert raw strings directly to bytes Validate that the input can be properly represented as bytes FastMCP does not automatically decode base64-encoded strings for bytes parameters. If you need to accept base64-encoded data, you should handle the decoding manually as shown below. from typing import Annotatedfrom pydantic import Fieldmcp.tooldef process_image_data image_data Annotatedstr, FielddescriptionBase64-encoded image data Process an image from base64-encoded string. The client is expected to provide base64-encoded data as a string. Youll need to decode it manually.   Manual base64 decoding import base64 binary_data  base64.b64decodeimage_data  Process binary_data... This approach is recommended when you expect to receive base64-encoded binary data from clients. The Path type from the pathlib module can be used for file system paths Copy Ask AI from pathlib import Pathmcp.tooldef process_filepath Path - str Process a file at the given path. assert isinstancepath, Path  Path is properly converted return fProcessing file at path When a client sends a string path, FastMCP automatically converts it to a Path object. For complex, structured data with nested fields and validation, use Pydantic models Copy Ask AI from pydantic import BaseModel, Fieldfrom typing import Optionalclass UserBaseModel username str email str  FielddescriptionUsers email address age int  None  None is_active bool  Truemcp.tooldef create_useruser User Create a new user in the system.  The input is automatically validated against the User model  Even if provided as a JSON string or dict  Implementation... Using Pydantic models provides Clear, self-documenting structure for complex inputs Built-in data validation Automatic generation of detailed JSON schemas for the LLM Automatic conversion from dictJSON input Clients can provide data for Pydantic model parameters as either FastMCP supports robust parameter validation through Pydantics Field class. This is especially useful to ensure that input values meet specific requirements beyond just their type. Note that fields can be used outside Pydantic models to provide metadata and validation constraints. The preferred approach is using Annotated with Field Copy Ask AI from typing import Annotatedfrom pydantic import Fieldmcp.tooldef analyze_metrics  Numbers with range constraints count Annotatedint, Fieldge0, le100,  0  count  100 ratio Annotatedfloat, Fieldgt0, lt1.0,  0  ratio  1.0  String with pattern and length constraints user_id Annotatedstr, Field patternrA-Z2d4,  Must match regex pattern descriptionUser ID in format XX0000 ,  String with length constraints comment Annotatedstr, Fieldmin_length3, max_length500  ,  Numeric constraints factor Annotatedint, Fieldmultiple_of5  10,  Must be multiple of 5 Analyze metrics with validated parameters.  Implementation... You can also use Field as a default value, though the Annotated approach is preferred Copy Ask AI mcp.tooldef validate_data  Value constraints age int  Fieldge0, lt120,  0  age  120  String constraints email str  Fieldpatternrw.-w.-.w,  Email pattern  Collection constraints tags liststr  Fieldmin_length1, max_length10  1-10 tags Process data with field validations.  Implementation... Common validation options include When a client sends invalid data, FastMCP will return a validation error explaining why the parameter failed validation. You can control how the FastMCP server behaves if you try to register multiple tools with the same name. This is configured using the on_duplicate_tools argument when creating the FastMCP instance. Copy Ask AI from fastmcp import FastMCPmcp  FastMCP nameStrictServer,  Configure behavior for duplicate tool names on_duplicate_toolserrormcp.tooldef my_tool return Version 1 This will now raise a ValueError because my_tool already exists and on_duplicate_tools is set to error. mcp.tool def my_tool return Version 2 The duplicate behavior options are warn default Logs a warning and the new tool replaces the old one. error Raises a ValueError, preventing the duplicate registration. replace Silently replaces the existing tool with the new one. ignore Keeps the original tool and ignores the new registration attempt. FastMCP 1.0 and  2.2.10 relied on a crutch that attempted to work around LLM limitations by automatically parsing stringified JSON in tool arguments e.g., converting 1,2,3 to 1,2,3. As of FastMCP 2.2.10, this behavior is disabled by default because it circumvents type validation and can lead to unexpected type coercion issues e.g. parsing true as a bool and attempting to call a tool that expected a string, which would fail type validation. Most modern LLMs correctly format JSON, but if working with models that unnecessarily stringify JSON as was the case with Claude Desktop in late 2024, you can re-enable this behavior on your server by setting the environment variable FASTMCP_TOOL_ATTEMPT_PARSE_JSON_ARGS1. We strongly recommend leaving this disabled unless necessary. Assistant Responses are generated using AI and may contain mistakes.

Keywords: the, fastmcp, tool, for, and, with, can, this, from, data

---

