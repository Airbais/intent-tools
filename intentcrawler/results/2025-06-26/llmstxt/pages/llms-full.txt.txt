# Llms-Full.Txt

## https://gofastmcp.com/llms-full.txt

URL: https://gofastmcp.com/llms-full.txt

--- date 2023-04-15 ---  null Source httpsgofastmcp.comchangelog  v2.9.0 Stuck in the Middleware With Youhttpsgithub.comjlowinfastmcpreleasestagv2.9.0 FastMCP 2.9 introduces two important features that push beyond the basic MCP protocol MCP Middleware and server-side type conversion.  MCP Middleware MCP middleware lets you intercept and modify requests and responses at the protocol level, giving you powerful capabilities for logging, authentication, validation, and more. This is particularly useful for building production-ready MCP servers that need sophisticated request handling.  Server-side Type Conversion This release also introduces server-side type conversion for prompt arguments, ensuring that data is properly formatted before being passed to your functions. This reduces the burden on individual tools and prompts to handle type validation and conversion.  Whats Changed  New Features   Add File utility for binary data by gorocodehttpsgithub.comgorocode in 843httpsgithub.comjlowinfastmcppull843  Consolidate prefix logic into FastMCP methods by jlowinhttpsgithub.comjlowin in 861httpsgithub.comjlowinfastmcppull861  Add MCP Middleware by jlowinhttpsgithub.comjlowin in 870httpsgithub.comjlowinfastmcppull870  Implement server-side type conversion for prompt arguments by jlowinhttpsgithub.comjlowin in 908httpsgithub.comjlowinfastmcppull908  Enhancements   Fix tool description indentation issue by zfflxxhttpsgithub.comzfflxx in 845httpsgithub.comjlowinfastmcppull845  Add version parameter to FastMCP constructor by mkyutanihttpsgithub.commkyutani in 842httpsgithub.comjlowinfastmcppull842  Update version to not be positional by jlowinhttpsgithub.comjlowin in 848httpsgithub.comjlowinfastmcppull848  Add key to component by jlowinhttpsgithub.comjlowin in 869httpsgithub.comjlowinfastmcppull869  Add session_id property to Context for data sharing by jlowinhttpsgithub.comjlowin in 881httpsgithub.comjlowinfastmcppull881  Fix CORS documentation example by jlowinhttpsgithub.comjlowin in 895httpsgithub.comjlowinfastmcppull895  Fixes   report_progress missing passing related_request_id causes notifications not working by alexseehttpsgithub.comalexsee in 838httpsgithub.comjlowinfastmcppull838  Fix JWT issuer validation to support string values per RFC 7519 by jlowinhttpsgithub.comjlowin in 892httpsgithub.comjlowinfastmcppull892  Fix BearerAuthProvider audience type annotations by jlowinhttpsgithub.comjlowin in 894httpsgithub.comjlowinfastmcppull894  Docs   Add CLAUDE.md development guidelines by jlowinhttpsgithub.comjlowin in 880httpsgithub.comjlowinfastmcppull880  Update context docs for session_id property by jlowinhttpsgithub.comjlowin in 882httpsgithub.comjlowinfastmcppull882  Add API reference by zzstoatzzhttpsgithub.comzzstoatzz in 893httpsgithub.comjlowinfastmcppull893  Fix API ref rendering by zzstoatzzhttpsgithub.comzzstoatzz in 900httpsgithub.comjlowinfastmcppull900  Simplify docs nav by jlowinhttpsgithub.comjlowin in 902httpsgithub.comjlowinfastmcppull902  Add fastmcp inspect command by jlowinhttpsgithub.comjlowin in 904httpsgithub.comjlowinfastmcppull904  Update client docs by jlowinhttpsgithub.comjlowin in 912httpsgithub.comjlowinfastmcppull912  Update docs nav by jlowinhttpsgithub.comjlowin in 913httpsgithub.comjlowinfastmcppull913  Update integration documentation for Claude Desktop, ChatGPT, and Claude Code by jlowinhttpsgithub.comjlowin in 915httpsgithub.comjlowinfastmcppull915  Add http as an alias for streamable http by jlowinhttpsgithub.comjlowin in 917httpsgithub.comjlowinfastmcppull917  Clean up parameter documentation by jlowinhttpsgithub.comjlowin in 918httpsgithub.comjlowinfastmcppull918  Add middleware examples for timing, logging, rate limiting, and error handling by jlowinhttpsgithub.comjlowin in 919httpsgithub.comjlowinfastmcppull919  ControlFlow  FastMCP rename by jlowinhttpsgithub.comjlowin in 922httpsgithub.comjlowinfastmcppull922  Examples  Contrib   Add contrib.mcp_mixin support for annotations by rsp2khttpsgithub.comrsp2k in 860httpsgithub.comjlowinfastmcppull860  Add ATProto Bluesky MCP Server Example by zzstoatzzhttpsgithub.comzzstoatzz in 916httpsgithub.comjlowinfastmcppull916  Fix path in atproto example pyproject by zzstoatzzhttpsgithub.comzzstoatzz in 920httpsgithub.comjlowinfastmcppull920  Remove uv source in example by zzstoatzzhttpsgithub.comzzstoatzz in 921httpsgithub.comjlowinfastmcppull921  New Contributors  alexseehttpsgithub.comalexsee made their first contribution in 838httpsgithub.comjlowinfastmcppull838  zfflxxhttpsgithub.comzfflxx made their first contribution in 845httpsgithub.comjlowinfastmcppull845  mkyutanihttpsgithub.commkyutani made their first contribution in 842httpsgithub.comjlowinfastmcppull842  gorocodehttpsgithub.comgorocode made their first contribution in 843httpsgithub.comjlowinfastmcppull843  rsp2khttpsgithub.comrsp2k made their first contribution in 860httpsgithub.comjlowinfastmcppull860  owtaylorhttpsgithub.comowtaylor made their first contribution in 897httpsgithub.comjlowinfastmcppull897  Jason-CKYhttpsgithub.comJason-CKY made their first contribution in 906httpsgithub.comjlowinfastmcppull906 Full Changelog v2.8.1...v2.9.0httpsgithub.comjlowinfastmcpcomparev2.8.1...v2.9.0  v2.8.1 Sound Judgementhttpsgithub.comjlowinfastmcpreleasestagv2.8.1 2.8.1 introduces audio support, as well as minor fixes and updates for deprecated features.  Audio Support This release adds support for audio content in MCP tools and resources, expanding FastMCPs multimedia capabilities beyond text and images.  Whats Changed  New Features   Add audio support by jlowinhttpsgithub.comjlowin in 833httpsgithub.comjlowinfastmcppull833  Enhancements   Add flag for disabling deprecation warnings by jlowinhttpsgithub.comjlowin in 802httpsgithub.comjlowinfastmcppull802  Add examples to Tool Arg Param transformation by strawgatehttpsgithub.comstrawgate in 806httpsgithub.comjlowinfastmcppull806  Fixes   Restore .settings access as deprecated by jlowinhttpsgithub.comjlowin in 800httpsgithub.comjlowinfastmcppull800  Ensure handling of false http kwargs correctly removed unused kwarg by jlowinhttpsgithub.comjlowin in 804httpsgithub.comjlowinfastmcppull804  Bump mcp 1.9.4 by jlowinhttpsgithub.comjlowin in 835httpsgithub.comjlowinfastmcppull835  Docs   Update changelog for 2.8.0 by jlowinhttpsgithub.comjlowin in 794httpsgithub.comjlowinfastmcppull794  Update welcome docs by jlowinhttpsgithub.comjlowin in 808httpsgithub.comjlowinfastmcppull808  Update headers in docs by jlowinhttpsgithub.comjlowin in 809httpsgithub.comjlowinfastmcppull809  Add MCP group to tutorials by jlowinhttpsgithub.comjlowin in 810httpsgithub.comjlowinfastmcppull810  Add Community section to documentation by zzstoatzzhttpsgithub.comzzstoatzz in 819httpsgithub.comjlowinfastmcppull819  Add 2.8 update by jlowinhttpsgithub.comjlowin in 821httpsgithub.comjlowinfastmcppull821  Embed YouTube videos in community showcase by zzstoatzzhttpsgithub.comzzstoatzz in 820httpsgithub.comjlowinfastmcppull820  Other Changes   Ensure http args are passed through by jlowinhttpsgithub.comjlowin in 803httpsgithub.comjlowinfastmcppull803  Fix install link in readme by jlowinhttpsgithub.comjlowin in 836httpsgithub.comjlowinfastmcppull836 Full Changelog v2.8.0...v2.8.1httpsgithub.comjlowinfastmcpcomparev2.8.0...v2.8.1  v2.8.0 Transform and Roll Outhttpsgithub.comjlowinfastmcpreleasestagv2.8.0 FastMCP 2.8.0 introduces powerful new ways to customize and control your MCP servers!  Tool Transformation The highlight of this release is first-class Tool Transformationpatternstool-transformation, a new feature that lets you create enhanced variations of existing tools. You can now easily rename arguments, hide parameters, modify descriptions, and even wrap tools with custom validation or post-processing logicall without rewriting the original code. This makes it easier than ever to adapt generic tools for specific LLM use cases or to simplify complex APIs. Huge thanks to strawgatehttpsgithub.comstrawgate for partnering on this, starting with 591httpsgithub.comjlowinfastmcpdiscussions591 and 599httpsgithub.comjlowinfastmcppull599 and continuing offline.  Component Control This release also gives you more granular control over which components are exposed to clients. With new tag-based filteringserversfastmcptag-based-filtering, you can selectively enable or disable tools, resources, and prompts based on tags, perfect for managing different environments or user permissions. Complementing this, every component now supports being programmatically enabled or disabledserverstoolsdisabling-tools, offering dynamic control over your servers capabilities.  Tools-by-Default Finally, to improve compatibility with a wider range of LLM clients, this release changes the default behavior for OpenAPI integration all API endpoints are now converted to Tools by default. This is a breaking change but pragmatically necessitated by the fact that the majority of MCP clients available today are, sadly, only compatible with MCP tools. Therefore, this change significantly simplifies the out-of-the-box experience and ensures your entire API is immediately accessible to any tool-using agent.  Whats Changed  New Features   First-class tool transformation by jlowinhttpsgithub.comjlowin in 745httpsgithub.comjlowinfastmcppull745  Support enabledisable for all FastMCP components tools, prompts, resources, templates by jlowinhttpsgithub.comjlowin in 781httpsgithub.comjlowinfastmcppull781  Add support for tag-based component filtering by jlowinhttpsgithub.comjlowin in 748httpsgithub.comjlowinfastmcppull748  Allow tag assignments for OpenAPI by jlowinhttpsgithub.comjlowin in 791httpsgithub.comjlowinfastmcppull791  Enhancements   Create common base class for components by jlowinhttpsgithub.comjlowin in 776httpsgithub.comjlowinfastmcppull776  Move components to own file add resource by jlowinhttpsgithub.comjlowin in 777httpsgithub.comjlowinfastmcppull777  Update FastMCP component with eq and repr by jlowinhttpsgithub.comjlowin in 779httpsgithub.comjlowinfastmcppull779  Remove open-ended and server-specific settings by jlowinhttpsgithub.comjlowin in 750httpsgithub.comjlowinfastmcppull750  Fixes   Ensure client is only initialized once by jlowinhttpsgithub.comjlowin in 758httpsgithub.comjlowinfastmcppull758  Fix field validator for resource by jlowinhttpsgithub.comjlowin in 778httpsgithub.comjlowinfastmcppull778  Ensure proxies can overwrite remote tools without falling back to the remote by jlowinhttpsgithub.comjlowin in 782httpsgithub.comjlowinfastmcppull782  Breaking Changes   Treat all openapi routes as tools by jlowinhttpsgithub.comjlowin in 788httpsgithub.comjlowinfastmcppull788  Fix issue with global OpenAPI tags by jlowinhttpsgithub.comjlowin in 792httpsgithub.comjlowinfastmcppull792  Docs   Minor docs updates by jlowinhttpsgithub.comjlowin in 755httpsgithub.comjlowinfastmcppull755  Add 2.7 update by jlowinhttpsgithub.comjlowin in 756httpsgithub.comjlowinfastmcppull756  Reduce 2.7 image size by jlowinhttpsgithub.comjlowin in 757httpsgithub.comjlowinfastmcppull757  Update updates.mdx by jlowinhttpsgithub.comjlowin in 765httpsgithub.comjlowinfastmcppull765  Hide docs sidebar scrollbar by default by jlowinhttpsgithub.comjlowin in 766httpsgithub.comjlowinfastmcppull766  Add stop vibe testing to tutorials by jlowinhttpsgithub.comjlowin in 767httpsgithub.comjlowinfastmcppull767  Add docs links by jlowinhttpsgithub.comjlowin in 768httpsgithub.comjlowinfastmcppull768  Fix updated variable name under Gemini remote client by yranganahttpsgithub.comyrangana in 769httpsgithub.comjlowinfastmcppull769  Revert Hide docs sidebar scrollbar by default by jlowinhttpsgithub.comjlowin in 770httpsgithub.comjlowinfastmcppull770  Add updates by jlowinhttpsgithub.comjlowin in 773httpsgithub.comjlowinfastmcppull773  Add tutorials by jlowinhttpsgithub.comjlowin in 783httpsgithub.comjlowinfastmcppull783  Update LLM-friendly docs by jlowinhttpsgithub.comjlowin in 784httpsgithub.comjlowinfastmcppull784  Update oauth.mdx by JeremyCraigMartinezhttpsgithub.comJeremyCraigMartinez in 787httpsgithub.comjlowinfastmcppull787  Add changelog by jlowinhttpsgithub.comjlowin in 789httpsgithub.comjlowinfastmcppull789  Add tutorials by jlowinhttpsgithub.comjlowin in 790httpsgithub.comjlowinfastmcppull790  Add docs for tag-based filtering by jlowinhttpsgithub.comjlowin in 793httpsgithub.comjlowinfastmcppull793  Other Changes   Create dependabot.yml by jlowinhttpsgithub.comjlowin in 759httpsgithub.comjlowinfastmcppull759  Bump astral-shsetup-uv from 3 to 6 by dependabothttpsgithub.comdependabot in 760httpsgithub.comjlowinfastmcppull760  Add dependencies section to release by jlowinhttpsgithub.comjlowin in 761httpsgithub.comjlowinfastmcppull761  Remove extra imports for MCPConfig by Maanas-Vermahttpsgithub.comMaanas-Verma in 763httpsgithub.comjlowinfastmcppull763  Split out enhancements in release notes by jlowinhttpsgithub.comjlowin in 764httpsgithub.comjlowinfastmcppull764  New Contributors  dependabothttpsgithub.comdependabot made their first contribution in 760httpsgithub.comjlowinfastmcppull760  Maanas-Vermahttpsgithub.comMaanas-Verma made their first contribution in 763httpsgithub.comjlowinfastmcppull763  JeremyCraigMartinezhttpsgithub.comJeremyCraigMartinez made their first contribution in 787httpsgithub.comjlowinfastmcppull787 Full Changelog v2.7.1...v2.8.0httpsgithub.comjlowinfastmcpcomparev2.7.1...v2.8.0  v2.7.1 The Bearer Necessitieshttpsgithub.comjlowinfastmcpreleasestagv2.7.1 This release primarily contains a fix for parsing string tokens that are provided to FastMCP clients.  New Features   Respect cache setting, set default to 1 second by jlowinhttpsgithub.comjlowin in 747httpsgithub.comjlowinfastmcppull747  Fixes   Ensure event store is properly typed by jlowinhttpsgithub.comjlowin in 753httpsgithub.comjlowinfastmcppull753  Fix passing token string to client auth  add auth to MCPConfig clients by jlowinhttpsgithub.comjlowin in 754httpsgithub.comjlowinfastmcppull754  Docs   Docs  fix client to mcp_client in Gemini example by yranganahttpsgithub.comyrangana in 734httpsgithub.comjlowinfastmcppull734  update add tool docstring by strawgatehttpsgithub.comstrawgate in 739httpsgithub.comjlowinfastmcppull739  Fix contrib link by richardkmichaelhttpsgithub.comrichardkmichael in 749httpsgithub.comjlowinfastmcppull749  Other Changes   Switch Pydantic defaults to kwargs by strawgatehttpsgithub.comstrawgate in 731httpsgithub.comjlowinfastmcppull731  Fix Typo in CLI module by wfclark5httpsgithub.comwfclark5 in 737httpsgithub.comjlowinfastmcppull737  chore fix prompt docstring by danb27httpsgithub.comdanb27 in 752httpsgithub.comjlowinfastmcppull752  Add accept to excluded headers by jlowinhttpsgithub.comjlowin in 751httpsgithub.comjlowinfastmcppull751  New Contributors  wfclark5httpsgithub.comwfclark5 made their first contribution in 737httpsgithub.comjlowinfastmcppull737  richardkmichaelhttpsgithub.comrichardkmichael made their first contribution in 749httpsgithub.comjlowinfastmcppull749  danb27httpsgithub.comdanb27 made their first contribution in 752httpsgithub.comjlowinfastmcppull752 Full Changelog v2.7.0...v2.7.1httpsgithub.comjlowinfastmcpcomparev2.7.0...v2.7.1  v2.7.0 Pare Programminghttpsgithub.comjlowinfastmcpreleasestagv2.7.0 This is primarily a housekeeping release to remove or deprecate cruft thats accumulated since v1. Primarily, this release refactors FastMCPs internals in preparation for features planned in the next few major releases. However please note that as a result, this release has some minor breaking changes which is why its 2.7, not 2.6.2, in accordance with repo guidelines though not to the core user-facing APIs.  Breaking Changes   decorators return the objects they create, not the decorated function  websockets is an optional dependency  methods on the server for automatically converting functions into toolsresourcesprompts have been deprecated in favor of using the decorators directly  New Features   allow passing flags to servers by zzstoatzzhttpsgithub.comzzstoatzz in 690httpsgithub.comjlowinfastmcppull690  replace ref pointing to componentsschemas with defs by phateffecthttpsgithub.comphateffect in 697httpsgithub.comjlowinfastmcppull697  Split Tool into Tool and FunctionTool by jlowinhttpsgithub.comjlowin in 700httpsgithub.comjlowinfastmcppull700  Use strict basemodel for Prompt relax from_function deprecation by jlowinhttpsgithub.comjlowin in 701httpsgithub.comjlowinfastmcppull701  Formalize resourcefunctionresource replationship by jlowinhttpsgithub.comjlowin in 702httpsgithub.comjlowinfastmcppull702  Formalize templatefunctiontemplate split by jlowinhttpsgithub.comjlowin in 703httpsgithub.comjlowinfastmcppull703  Support flexible tool decorator call patterns by jlowinhttpsgithub.comjlowin in 706httpsgithub.comjlowinfastmcppull706  Ensure deprecation warnings have stacklevel2 by jlowinhttpsgithub.comjlowin in 710httpsgithub.comjlowinfastmcppull710  Allow naked prompt decorator by jlowinhttpsgithub.comjlowin in 711httpsgithub.comjlowinfastmcppull711  Fixes   Updates  Fixes for Tool Content Conversion by strawgatehttpsgithub.comstrawgate in 642httpsgithub.comjlowinfastmcppull642  Fix pr labeler permissions by jlowinhttpsgithub.comjlowin in 708httpsgithub.comjlowinfastmcppull708  remove -n auto by jlowinhttpsgithub.comjlowin in 709httpsgithub.comjlowinfastmcppull709  Fix links in README.md by alainivarshttpsgithub.comalainivars in 723httpsgithub.comjlowinfastmcppull723 Happily, this release DOES permit the use of naked decorators to align with Pythonic practice python mcp.tool def my_tool ...  Full Changelog v2.6.2...v2.7.0httpsgithub.comjlowinfastmcpcomparev2.6.2...v2.7.0  v2.6.1 Blast Auth second ignitionhttpsgithub.comjlowinfastmcpreleasestagv2.6.1 This is a patch release to restore py.typed in 686.  Docs   Update readme by jlowinhttpsgithub.comjlowin in 679httpsgithub.comjlowinfastmcppull679  Add gemini tutorial by jlowinhttpsgithub.comjlowin in 680httpsgithub.comjlowinfastmcppull680  Fix  fix path error to CLI Documentation by yranganahttpsgithub.comyrangana in 684httpsgithub.comjlowinfastmcppull684  Update auth docs by jlowinhttpsgithub.comjlowin in 687httpsgithub.comjlowinfastmcppull687  Other Changes   Remove deprecation notice by jlowinhttpsgithub.comjlowin in 677httpsgithub.comjlowinfastmcppull677  Delete server.py by jlowinhttpsgithub.comjlowin in 681httpsgithub.comjlowinfastmcppull681  Restore py.typed by jlowinhttpsgithub.comjlowin in 686httpsgithub.comjlowinfastmcppull686  New Contributors  yranganahttpsgithub.comyrangana made their first contribution in 684httpsgithub.comjlowinfastmcppull684 Full Changelog v2.6.0...v2.6.1httpsgithub.comjlowinfastmcpcomparev2.6.0...v2.6.1  v2.6.0 Blast Authhttpsgithub.comjlowinfastmcpreleasestagv2.6.0  New Features   Introduce MCP client oauth flow by jlowinhttpsgithub.comjlowin in 478httpsgithub.comjlowinfastmcppull478  Support providing tools at init by jlowinhttpsgithub.comjlowin in 647httpsgithub.comjlowinfastmcppull647  Simplify code for running servers in processes during tests by jlowinhttpsgithub.comjlowin in 649httpsgithub.comjlowinfastmcppull649  Add basic bearer auth for server and client by jlowinhttpsgithub.comjlowin in 650httpsgithub.comjlowinfastmcppull650  Support configuring bearer auth from env vars by jlowinhttpsgithub.comjlowin in 652httpsgithub.comjlowinfastmcppull652  feattool add support for excluding arguments from tool definition by deepak-stratforgehttpsgithub.comdeepak-stratforge in 626httpsgithub.comjlowinfastmcppull626  Add docs for server  client auth by jlowinhttpsgithub.comjlowin in 655httpsgithub.comjlowinfastmcppull655  Fixes   fix Support concurrency in FastMcpProxy and Client by Sillocanhttpsgithub.comSillocan in 635httpsgithub.comjlowinfastmcppull635  Ensure Client.close cleans up client context appropriately by jlowinhttpsgithub.comjlowin in 643httpsgithub.comjlowinfastmcppull643  Update client.mdx ClientError namespace by mjkayehttpsgithub.commjkaye in 657httpsgithub.comjlowinfastmcppull657  Docs   Make FastMCPTransport support simulated Streamable HTTP Transport didnt work by jlowinhttpsgithub.comjlowin in 645httpsgithub.comjlowinfastmcppull645  Document exclude_args by jlowinhttpsgithub.comjlowin in 653httpsgithub.comjlowinfastmcppull653  Update welcome by jlowinhttpsgithub.comjlowin in 673httpsgithub.comjlowinfastmcppull673  Add Anthropic  Claude desktop integration guides by jlowinhttpsgithub.comjlowin in 674httpsgithub.comjlowinfastmcppull674  Minor docs design updates by jlowinhttpsgithub.comjlowin in 676httpsgithub.comjlowinfastmcppull676  Other Changes   Update test typing by jlowinhttpsgithub.comjlowin in 646httpsgithub.comjlowinfastmcppull646  Add OpenAI integration docs by jlowinhttpsgithub.comjlowin in 660httpsgithub.comjlowinfastmcppull660  New Contributors  Sillocanhttpsgithub.comSillocan made their first contribution in 635httpsgithub.comjlowinfastmcppull635  deepak-stratforgehttpsgithub.comdeepak-stratforge made their first contribution in 626httpsgithub.comjlowinfastmcppull626  mjkayehttpsgithub.commjkaye made their first contribution in 657httpsgithub.comjlowinfastmcppull657 Full Changelog v2.5.2...v2.6.0httpsgithub.comjlowinfastmcpcomparev2.5.2...v2.6.0  v2.5.2 Stayin Alivehttpsgithub.comjlowinfastmcpreleasestagv2.5.2  New Features   Add graceful error handling for unreachable mounted servers by davenpihttpsgithub.comdavenpi in 605httpsgithub.comjlowinfastmcppull605  Improve type inference from client transport by jlowinhttpsgithub.comjlowin in 623httpsgithub.comjlowinfastmcppull623  Add keep_alive param to reuse subprocess by jlowinhttpsgithub.comjlowin in 624httpsgithub.comjlowinfastmcppull624  Fixes   Fix handling tools without descriptions by jlowinhttpsgithub.comjlowin in 610httpsgithub.comjlowinfastmcppull610  Dont print env vars to console when format is wrong by jlowinhttpsgithub.comjlowin in 615httpsgithub.comjlowinfastmcppull615  Ensure behavior-affecting headers are excluded when forwarding proxiesopenapi by jlowinhttpsgithub.comjlowin in 620httpsgithub.comjlowinfastmcppull620  Docs   Add notes about uv and claude desktop by jlowinhttpsgithub.comjlowin in 597httpsgithub.comjlowinfastmcppull597  Other Changes   add init_timeout for mcp client by jfourethttpsgithub.comjfouret in 607httpsgithub.comjlowinfastmcppull607  Add init_timeout for mcp client incl settings by jlowinhttpsgithub.comjlowin in 609httpsgithub.comjlowinfastmcppull609  Support for uppercase letters at the log level by ksawarayhttpsgithub.comksawaray in 625httpsgithub.comjlowinfastmcppull625  New Contributors  jfourethttpsgithub.comjfouret made their first contribution in 607httpsgithub.comjlowinfastmcppull607  ksawarayhttpsgithub.comksawaray made their first contribution in 625httpsgithub.comjlowinfastmcppull625 Full Changelog v2.5.1...v2.5.2httpsgithub.comjlowinfastmcpcomparev2.5.1...v2.5.2  v2.5.1 Route Awakening Part 2httpsgithub.comjlowinfastmcpreleasestagv2.5.1  Fixes   Ensure content-length is always stripped from client headers by jlowinhttpsgithub.comjlowin in 589httpsgithub.comjlowinfastmcppull589  Docs   Fix redundant section of docs by jlowinhttpsgithub.comjlowin in 583httpsgithub.comjlowinfastmcppull583 Full Changelog v2.5.0...v2.5.1httpsgithub.comjlowinfastmcpcomparev2.5.0...v2.5.1  v2.5.0 Route Awakeninghttpsgithub.comjlowinfastmcpreleasestagv2.5.0 This release introduces completely new tools for generating and customizing MCP servers from OpenAPI specs and FastAPI apps, including popular requests like mechanisms for determining what routes map to what MCP components renaming routes and customizing the generated MCP components.  New Features   Add FastMCP 1.0 server support for in-memory Client  Testing by jlowinhttpsgithub.comjlowin in 539httpsgithub.comjlowinfastmcppull539  Minor addition add transport to stdio server in mcpconfig, with default by jlowinhttpsgithub.comjlowin in 555httpsgithub.comjlowinfastmcppull555  Raise an error if a Client is created with no servers in config by jlowinhttpsgithub.comjlowin in 554httpsgithub.comjlowinfastmcppull554  Expose model preferences in Context.sample for flexible model selection. by davenpihttpsgithub.comdavenpi in 542httpsgithub.comjlowinfastmcppull542  Ensure custom routes are respected by jlowinhttpsgithub.comjlowin in 558httpsgithub.comjlowinfastmcppull558  Add client method to send cancellation notifications by davenpihttpsgithub.comdavenpi in 563httpsgithub.comjlowinfastmcppull563  Enhance route map logic for includeexclude OpenAPI routes by jlowinhttpsgithub.comjlowin in 564httpsgithub.comjlowinfastmcppull564  Add tag-based route maps by jlowinhttpsgithub.comjlowin in 565httpsgithub.comjlowinfastmcppull565  Add advanced control of openAPI route creation by jlowinhttpsgithub.comjlowin in 566httpsgithub.comjlowinfastmcppull566  Make error masking configurable by jlowinhttpsgithub.comjlowin in 550httpsgithub.comjlowinfastmcppull550  Ensure client headers are passed through to remote servers by jlowinhttpsgithub.comjlowin in 575httpsgithub.comjlowinfastmcppull575  Use lowercase name for headers when comparing by jlowinhttpsgithub.comjlowin in 576httpsgithub.comjlowinfastmcppull576  Permit more flexible name generation for OpenAPI servers by jlowinhttpsgithub.comjlowin in 578httpsgithub.comjlowinfastmcppull578  Ensure that toolstemplatesprompts are compatible with callable objects by jlowinhttpsgithub.comjlowin in 579httpsgithub.comjlowinfastmcppull579  Docs   Add version badge for prefix formats by jlowinhttpsgithub.comjlowin in 537httpsgithub.comjlowinfastmcppull537  Add versioning note to docs by jlowinhttpsgithub.comjlowin in 551httpsgithub.comjlowinfastmcppull551  Bump 2.3.6 references to 2.4.0 by jlowinhttpsgithub.comjlowin in 567httpsgithub.comjlowinfastmcppull567 Full Changelog v2.4.0...v2.5.0httpsgithub.comjlowinfastmcpcomparev2.4.0...v2.5.0  v2.4.0 Config and Conquerhttpsgithub.comjlowinfastmcpreleasestagv2.4.0 Note this release includes a backwards-incompatible change to how resources are prefixed when mounted in composed servers. However, it is only backwards-incompatible if users were running tests or manually loading resources by prefixed key LLMs should not have any issue discovering the new route. See Resource Prefix Formatshttpsgofastmcp.comserverscompositionresource-prefix-formats for more.  New Features   Allow  Methods and all routes as tools shortcuts by jlowinhttpsgithub.comjlowin in 520httpsgithub.comjlowinfastmcppull520  Improved support for config dicts by jlowinhttpsgithub.comjlowin in 522httpsgithub.comjlowinfastmcppull522  Support creating clients from MCP config dicts, including multi-server clients by jlowinhttpsgithub.comjlowin in 527httpsgithub.comjlowinfastmcppull527  Make resource prefix format configurable by jlowinhttpsgithub.comjlowin in 534httpsgithub.comjlowinfastmcppull534  Fixes   Avoid hanging on initializing server session by jlowinhttpsgithub.comjlowin in 523httpsgithub.comjlowinfastmcppull523  Breaking Changes   Remove customizable separators improve resource separator by jlowinhttpsgithub.comjlowin in 526httpsgithub.comjlowinfastmcppull526  Docs   Improve client documentation by jlowinhttpsgithub.comjlowin in 517httpsgithub.comjlowinfastmcppull517  Other Changes   Ensure openapi path params are handled properly by jlowinhttpsgithub.comjlowin in 519httpsgithub.comjlowinfastmcppull519  better error when missing lifespan by zzstoatzzhttpsgithub.comzzstoatzz in 521httpsgithub.comjlowinfastmcppull521 Full Changelog v2.3.5...v2.4.0httpsgithub.comjlowinfastmcpcomparev2.3.5...v2.4.0  v2.3.5 Making Progresshttpsgithub.comjlowinfastmcpreleasestagv2.3.5  New Features   support messages in progress notifications by rickygenhealthhttpsgithub.comrickygenhealth in 471httpsgithub.comjlowinfastmcppull471  feat Add middleware option in server.run by Maxi91fhttpsgithub.comMaxi91f in 475httpsgithub.comjlowinfastmcppull475  Add lifespan property to app by jlowinhttpsgithub.comjlowin in 483httpsgithub.comjlowinfastmcppull483  Update fastmcp run to work with remote servers by jlowinhttpsgithub.comjlowin in 491httpsgithub.comjlowinfastmcppull491  Add FastMCP.as_proxy by jlowinhttpsgithub.comjlowin in 490httpsgithub.comjlowinfastmcppull490  Infer sse transport from urls containing sse by jlowinhttpsgithub.comjlowin in 512httpsgithub.comjlowinfastmcppull512  Add progress handler to client by jlowinhttpsgithub.comjlowin in 513httpsgithub.comjlowinfastmcppull513  Store the initialize result on the client by jlowinhttpsgithub.comjlowin in 509httpsgithub.comjlowinfastmcppull509  Fixes   Remove patch and use upstream SSEServerTransport by jlowinhttpsgithub.comjlowin in 425httpsgithub.comjlowinfastmcppull425  Docs   Update transport docs by jlowinhttpsgithub.comjlowin in 458httpsgithub.comjlowinfastmcppull458  update proxy docs  example by zzstoatzzhttpsgithub.comzzstoatzz in 460httpsgithub.comjlowinfastmcppull460  docasgi Change custom route example to PlainTextResponse by mcw0933httpsgithub.commcw0933 in 477httpsgithub.comjlowinfastmcppull477  Store FastMCP instance on app.state.fastmcp_server by jlowinhttpsgithub.comjlowin in 489httpsgithub.comjlowinfastmcppull489  Improve AGENTS.md overview by jlowinhttpsgithub.comjlowin in 492httpsgithub.comjlowinfastmcppull492  Update release numbers for anticipated version by jlowinhttpsgithub.comjlowin in 516httpsgithub.comjlowinfastmcppull516  Other Changes   run tests on all PRs by jlowinhttpsgithub.comjlowin in 468httpsgithub.comjlowinfastmcppull468  add null check by zzstoatzzhttpsgithub.comzzstoatzz in 473httpsgithub.comjlowinfastmcppull473  strict typing for server.py by zzstoatzzhttpsgithub.comzzstoatzz in 476httpsgithub.comjlowinfastmcppull476  Docquickstart Fix import statements by mai-nakagawahttpsgithub.commai-nakagawa in 479httpsgithub.comjlowinfastmcppull479  Add labeler by jlowinhttpsgithub.comjlowin in 484httpsgithub.comjlowinfastmcppull484  Fix flaky timeout test by increasing timeout 474 by davenpihttpsgithub.comdavenpi in 486httpsgithub.comjlowinfastmcppull486  Skipping test_permission_error if runner is root. by ZiadAmerrhttpsgithub.comZiadAmerr in 502httpsgithub.comjlowinfastmcppull502  allow passing full uvicorn config by zzstoatzzhttpsgithub.comzzstoatzz in 504httpsgithub.comjlowinfastmcppull504  Skip timeout tests on windows by jlowinhttpsgithub.comjlowin in 514httpsgithub.comjlowinfastmcppull514  New Contributors  rickygenhealthhttpsgithub.comrickygenhealth made their first contribution in 471httpsgithub.comjlowinfastmcppull471  Maxi91fhttpsgithub.comMaxi91f made their first contribution in 475httpsgithub.comjlowinfastmcppull475  mcw0933httpsgithub.commcw0933 made their first contribution in 477httpsgithub.comjlowinfastmcppull477  mai-nakagawahttpsgithub.commai-nakagawa made their first contribution in 479httpsgithub.comjlowinfastmcppull479  ZiadAmerrhttpsgithub.comZiadAmerr made their first contribution in 502httpsgithub.comjlowinfastmcppull502 Full Changelog v2.3.4...v2.3.5httpsgithub.comjlowinfastmcpcomparev2.3.4...v2.3.5  v2.3.4 Error Today, Gone Tomorrowhttpsgithub.comjlowinfastmcpreleasestagv2.3.4  New Features   logging stack trace for easier debugging by jbkohhttpsgithub.comjbkoh in 413httpsgithub.comjlowinfastmcppull413  add missing StreamableHttpTransport in client exports by yihuanghttpsgithub.comyihuang in 408httpsgithub.comjlowinfastmcppull408  Improve error handling for tools and resources by jlowinhttpsgithub.comjlowin in 434httpsgithub.comjlowinfastmcppull434  feat add support for removing tools from server by davenpihttpsgithub.comdavenpi in 437httpsgithub.comjlowinfastmcppull437  Prune titles from JSONSchemas by jlowinhttpsgithub.comjlowin in 449httpsgithub.comjlowinfastmcppull449  Declare toolsChanged capability for stdio server. by davenpihttpsgithub.comdavenpi in 450httpsgithub.comjlowinfastmcppull450  Improve handling of exceptiongroups when raised in clients by jlowinhttpsgithub.comjlowin in 452httpsgithub.comjlowinfastmcppull452  Add timeout support to client by jlowinhttpsgithub.comjlowin in 455httpsgithub.comjlowinfastmcppull455  Fixes   Pin to mcp 1.8.1 to resolve callback deadlocks with SHTTP by jlowinhttpsgithub.comjlowin in 427httpsgithub.comjlowinfastmcppull427  Add reprs for OpenAPI objects by jlowinhttpsgithub.comjlowin in 447httpsgithub.comjlowinfastmcppull447  Ensure openapi defs for structured objects are loaded properly by jlowinhttpsgithub.comjlowin in 448httpsgithub.comjlowinfastmcppull448  Ensure tests run against correct python version by jlowinhttpsgithub.comjlowin in 454httpsgithub.comjlowinfastmcppull454  Ensure result is only returned if a new key was found by jlowinhttpsgithub.comjlowin in 456httpsgithub.comjlowinfastmcppull456  Docs   Add documentation for tool removal by jlowinhttpsgithub.comjlowin in 440httpsgithub.comjlowinfastmcppull440  Other Changes   Deprecate passing settings to the FastMCP instance by jlowinhttpsgithub.comjlowin in 424httpsgithub.comjlowinfastmcppull424  Add path prefix to test by jlowinhttpsgithub.comjlowin in 432httpsgithub.comjlowinfastmcppull432  New Contributors  jbkohhttpsgithub.comjbkoh made their first contribution in 413httpsgithub.comjlowinfastmcppull413  davenpihttpsgithub.comdavenpi made their first contribution in 437httpsgithub.comjlowinfastmcppull437 Full Changelog v2.3.3...v2.3.4httpsgithub.comjlowinfastmcpcomparev2.3.3...v2.3.4  v2.3.3 SSE you laterhttpsgithub.comjlowinfastmcpreleasestagv2.3.3 This is a hotfix for a bug introduced in 2.3.2 that broke SSE servers  Fixes   Fix bug that sets message path and sse path to same value by jlowinhttpsgithub.comjlowin in 405httpsgithub.comjlowinfastmcppull405  Docs   Update composition docs by jlowinhttpsgithub.comjlowin in 403httpsgithub.comjlowinfastmcppull403  Other Changes   Add test for no prefix when importing by jlowinhttpsgithub.comjlowin in 404httpsgithub.comjlowinfastmcppull404 Full Changelog v2.3.2...v2.3.3httpsgithub.comjlowinfastmcpcomparev2.3.2...v2.3.3  v2.3.2 Stuck in the Middleware With Youhttpsgithub.comjlowinfastmcpreleasestagv2.3.2  New Features   Allow users to pass middleware to starlette app constructors by jlowinhttpsgithub.comjlowin in 398httpsgithub.comjlowinfastmcppull398  Deprecate transport-specific methods on FastMCP server by jlowinhttpsgithub.comjlowin in 401httpsgithub.comjlowinfastmcppull401  Docs   Update CLI docs by jlowinhttpsgithub.comjlowin in 402httpsgithub.comjlowinfastmcppull402  Other Changes   Adding 23 tests for CLI by didier-durandhttpsgithub.comdidier-durand in 394httpsgithub.comjlowinfastmcppull394 Full Changelog v2.3.1...v2.3.2httpsgithub.comjlowinfastmcpcomparev2.3.1...v2.3.2  v2.3.1 For Good-nests Sakehttpsgithub.comjlowinfastmcpreleasestagv2.3.1 This release primarily patches a long-standing bug with nested ASGI SSE servers.  Fixes   Fix tool result serialization when the tool returns a list by strawgatehttpsgithub.comstrawgate in 379httpsgithub.comjlowinfastmcppull379  Ensure FastMCP handles nested SSE and SHTTP apps properly in ASGI frameworks by jlowinhttpsgithub.comjlowin in 390httpsgithub.comjlowinfastmcppull390  Docs   Update transport docs by jlowinhttpsgithub.comjlowin in 377httpsgithub.comjlowinfastmcppull377  Add llms.txt to docs by jlowinhttpsgithub.comjlowin in 384httpsgithub.comjlowinfastmcppull384  Fixing various text typos by didier-durandhttpsgithub.comdidier-durand in 385httpsgithub.comjlowinfastmcppull385  Other Changes   Adding a few tests to Image type by didier-durandhttpsgithub.comdidier-durand in 387httpsgithub.comjlowinfastmcppull387  Adding tests for TimedCache by didier-durandhttpsgithub.comdidier-durand in 388httpsgithub.comjlowinfastmcppull388  New Contributors  didier-durandhttpsgithub.comdidier-durand made their first contribution in 385httpsgithub.comjlowinfastmcppull385 Full Changelog v2.3.0...v2.3.1httpsgithub.comjlowinfastmcpcomparev2.3.0...v2.3.1  v2.3.0 Stream Me Up, Scottyhttpsgithub.comjlowinfastmcpreleasestagv2.3.0  New Features   Add streaming support for HTTP transport by jlowinhttpsgithub.comjlowin in 365httpsgithub.comjlowinfastmcppull365  Support streaming HTTP transport in clients by jlowinhttpsgithub.comjlowin in 366httpsgithub.comjlowinfastmcppull366  Add streaming support to CLI by jlowinhttpsgithub.comjlowin in 367httpsgithub.comjlowinfastmcppull367  Fixes   Fix streaming transport initialization by jlowinhttpsgithub.comjlowin in 368httpsgithub.comjlowinfastmcppull368  Docs   Update transport documentation for streaming support by jlowinhttpsgithub.comjlowin in 369httpsgithub.comjlowinfastmcppull369 Full Changelog v2.2.10...v2.3.0httpsgithub.comjlowinfastmcpcomparev2.2.10...v2.3.0  v2.2.10 Thats JSON Bournehttpsgithub.comjlowinfastmcpreleasestagv2.2.10  Fixes   Disable automatic JSON parsing of tool args by jlowinhttpsgithub.comjlowin in 341httpsgithub.comjlowinfastmcppull341  Fix prompt test by jlowinhttpsgithub.comjlowin in 342httpsgithub.comjlowinfastmcppull342  Other Changes   Update docs.json by jlowinhttpsgithub.comjlowin in 338httpsgithub.comjlowinfastmcppull338  Add test coverage  tests on 4 examples by alainivarshttpsgithub.comalainivars in 306httpsgithub.comjlowinfastmcppull306  New Contributors  alainivarshttpsgithub.comalainivars made their first contribution in 306httpsgithub.comjlowinfastmcppull306 Full Changelog v2.2.9...v2.2.10httpsgithub.comjlowinfastmcpcomparev2.2.9...v2.2.10  v2.2.9 Str-ing the Pot Hotfixhttpsgithub.comjlowinfastmcpreleasestagv2.2.9 This release is a hotfix for the issue detailed in 330  Fixes   Prevent invalid resource URIs by jlowinhttpsgithub.comjlowin in 336httpsgithub.comjlowinfastmcppull336  Coerce numbers to str by jlowinhttpsgithub.comjlowin in 337httpsgithub.comjlowinfastmcppull337  Docs   Add client badge by jlowinhttpsgithub.comjlowin in 327httpsgithub.comjlowinfastmcppull327  Update bug.yml by jlowinhttpsgithub.comjlowin in 328httpsgithub.comjlowinfastmcppull328  Other Changes   Update quickstart.mdx example to include import by discdiverhttpsgithub.comdiscdiver in 329httpsgithub.comjlowinfastmcppull329  New Contributors  discdiverhttpsgithub.comdiscdiver made their first contribution in 329httpsgithub.comjlowinfastmcppull329 Full Changelog v2.2.8...v2.2.9httpsgithub.comjlowinfastmcpcomparev2.2.8...v2.2.9  v2.2.8 Parse and Recreationhttpsgithub.comjlowinfastmcpreleasestagv2.2.8  New Features   Replace custom parsing with TypeAdapter by jlowinhttpsgithub.comjlowin in 314httpsgithub.comjlowinfastmcppull314  Handle argskwargs appropriately for various components by jlowinhttpsgithub.comjlowin in 317httpsgithub.comjlowinfastmcppull317  Add timeout-graceful-shutdown as a default config for SSE app by jlowinhttpsgithub.comjlowin in 323httpsgithub.comjlowinfastmcppull323  Ensure prompts return descriptions by jlowinhttpsgithub.comjlowin in 325httpsgithub.comjlowinfastmcppull325  Fixes   Ensure that tool serialization has a graceful fallback by jlowinhttpsgithub.comjlowin in 310httpsgithub.comjlowinfastmcppull310  Docs   Update docs for clarity by jlowinhttpsgithub.comjlowin in 312httpsgithub.comjlowinfastmcppull312  Other Changes   Remove is_async attribute by jlowinhttpsgithub.comjlowin in 315httpsgithub.comjlowinfastmcppull315  Dry out retrieving context kwarg by jlowinhttpsgithub.comjlowin in 316httpsgithub.comjlowinfastmcppull316 Full Changelog v2.2.7...v2.2.8httpsgithub.comjlowinfastmcpcomparev2.2.7...v2.2.8  v2.2.7 You Auth to Know Betterhttpsgithub.comjlowinfastmcpreleasestagv2.2.7  New Features   use pydantic_core.to_json by jlowinhttpsgithub.comjlowin in 290httpsgithub.comjlowinfastmcppull290  Ensure openapi descriptions are included in tool details by jlowinhttpsgithub.comjlowin in 293httpsgithub.comjlowinfastmcppull293  Bump mcp to 1.7.1 by jlowinhttpsgithub.comjlowin in 298httpsgithub.comjlowinfastmcppull298  Add support for tool annotations by jlowinhttpsgithub.comjlowin in 299httpsgithub.comjlowinfastmcppull299  Add auth support by jlowinhttpsgithub.comjlowin in 300httpsgithub.comjlowinfastmcppull300  Add low-level methods to client by jlowinhttpsgithub.comjlowin in 301httpsgithub.comjlowinfastmcppull301  Add method for retrieving current starlette request to FastMCP context by jlowinhttpsgithub.comjlowin in 302httpsgithub.comjlowinfastmcppull302  get_starlette_request  get_http_request by jlowinhttpsgithub.comjlowin in 303httpsgithub.comjlowinfastmcppull303  Support custom Serializer for Tools by strawgatehttpsgithub.comstrawgate in 308httpsgithub.comjlowinfastmcppull308  Support proxy mount by jlowinhttpsgithub.comjlowin in 309httpsgithub.comjlowinfastmcppull309  Other Changes   Improve context injection type checks by jlowinhttpsgithub.comjlowin in 291httpsgithub.comjlowinfastmcppull291  add readme to smarthome example by zzstoatzzhttpsgithub.comzzstoatzz in 294httpsgithub.comjlowinfastmcppull294 Full Changelog v2.2.6...v2.2.7httpsgithub.comjlowinfastmcpcomparev2.2.6...v2.2.7  v2.2.6 The REST is Historyhttpsgithub.comjlowinfastmcpreleasestagv2.2.6  New Features   Added feature  Load MCP server using config by sandipan1httpsgithub.comsandipan1 in 260httpsgithub.comjlowinfastmcppull260  small typing fixes by zzstoatzzhttpsgithub.comzzstoatzz in 237httpsgithub.comjlowinfastmcppull237  Expose configurable timeout for OpenAPI by jlowinhttpsgithub.comjlowin in 279httpsgithub.comjlowinfastmcppull279  Lower websockets pin for compatibility by jlowinhttpsgithub.comjlowin in 286httpsgithub.comjlowinfastmcppull286  Improve OpenAPI param handling by jlowinhttpsgithub.comjlowin in 287httpsgithub.comjlowinfastmcppull287  Fixes   Ensure openapi tool responses are properly converted by jlowinhttpsgithub.comjlowin in 283httpsgithub.comjlowinfastmcppull283  Fix OpenAPI examples by jlowinhttpsgithub.comjlowin in 285httpsgithub.comjlowinfastmcppull285  Fix client docs for advanced features, add tests for logging by jlowinhttpsgithub.comjlowin in 284httpsgithub.comjlowinfastmcppull284  Other Changes   add testing doc by jlowinhttpsgithub.comjlowin in 264httpsgithub.comjlowinfastmcppull264  267 Fix openapi template resource to support multiple path parameters by jeger-athttpsgithub.comjeger-at in 278httpsgithub.comjlowinfastmcppull278  New Contributors  sandipan1httpsgithub.comsandipan1 made their first contribution in 260httpsgithub.comjlowinfastmcppull260  jeger-athttpsgithub.comjeger-at made their first contribution in 278httpsgithub.comjlowinfastmcppull278 Full Changelog v2.2.5...v2.2.6httpsgithub.comjlowinfastmcpcomparev2.2.5...v2.2.6  v2.2.5 Context Switchinghttpsgithub.comjlowinfastmcpreleasestagv2.2.5  New Features   Add tests for tool return types improve serialization behavior by jlowinhttpsgithub.comjlowin in 262httpsgithub.comjlowinfastmcppull262  Support context injection in resources, templates, and prompts like tools by jlowinhttpsgithub.comjlowin in 263httpsgithub.comjlowinfastmcppull263  Docs   Update wildcards to 2.2.4 by jlowinhttpsgithub.comjlowin in 257httpsgithub.comjlowinfastmcppull257  Update note in templates docs by jlowinhttpsgithub.comjlowin in 258httpsgithub.comjlowinfastmcppull258  Significant documentation and test expansion for tool input types by jlowinhttpsgithub.comjlowin in 261httpsgithub.comjlowinfastmcppull261 Full Changelog v2.2.4...v2.2.5httpsgithub.comjlowinfastmcpcomparev2.2.4...v2.2.5  v2.2.4 The Wild Side, Actuallyhttpsgithub.comjlowinfastmcpreleasestagv2.2.4 The wildcard URI templates exposed in v2.2.3 were blocked by a server-level check which is removed in this release.  New Features   Allow customization of inspector proxy port, ui port, and version by jlowinhttpsgithub.comjlowin in 253httpsgithub.comjlowinfastmcppull253  Fixes   fix unintended type convert by cutekibryhttpsgithub.comcutekibry in 252httpsgithub.comjlowinfastmcppull252  Ensure openapi resources return valid responses by jlowinhttpsgithub.comjlowin in 254httpsgithub.comjlowinfastmcppull254  Ensure servers expose template wildcards by jlowinhttpsgithub.comjlowin in 256httpsgithub.comjlowinfastmcppull256  Docs   Update README.md Grammar error by TechWithTyhttpsgithub.comTechWithTy in 249httpsgithub.comjlowinfastmcppull249  Other Changes   Add resource template tests by jlowinhttpsgithub.comjlowin in 255httpsgithub.comjlowinfastmcppull255  New Contributors  TechWithTyhttpsgithub.comTechWithTy made their first contribution in 249httpsgithub.comjlowinfastmcppull249  cutekibryhttpsgithub.comcutekibry made their first contribution in 252httpsgithub.comjlowinfastmcppull252 Full Changelog v2.2.3...v2.2.4httpsgithub.comjlowinfastmcpcomparev2.2.3...v2.2.4  v2.2.3 The Wild Sidehttpsgithub.comjlowinfastmcpreleasestagv2.2.3  New Features   Add wildcard params for resource templates by jlowinhttpsgithub.comjlowin in 246httpsgithub.comjlowinfastmcppull246  Docs   Indicate that Image class is for returns by jlowinhttpsgithub.comjlowin in 242httpsgithub.comjlowinfastmcppull242  Update mermaid diagram by jlowinhttpsgithub.comjlowin in 243httpsgithub.comjlowinfastmcppull243  Other Changes   update version badges by jlowinhttpsgithub.comjlowin in 248httpsgithub.comjlowinfastmcppull248 Full Changelog v2.2.2...v2.2.3httpsgithub.comjlowinfastmcpcomparev2.2.2...v2.2.3  v2.2.2 Prompt and Circumstancehttpsgithub.comjlowinfastmcpreleasestagv2.2.2  New Features   Add prompt support by jlowinhttpsgithub.comjlowin in 235httpsgithub.comjlowinfastmcppull235  Fixes   Ensure that resource templates are properly exposed by jlowinhttpsgithub.comjlowin in 238httpsgithub.comjlowinfastmcppull238  Docs   Update docs for prompts by jlowinhttpsgithub.comjlowin in 236httpsgithub.comjlowinfastmcppull236  Other Changes   Add prompt tests by jlowinhttpsgithub.comjlowin in 239httpsgithub.comjlowinfastmcppull239 Full Changelog v2.2.1...v2.2.2httpsgithub.comjlowinfastmcpcomparev2.2.1...v2.2.2  v2.2.1 Template for Successhttpsgithub.comjlowinfastmcpreleasestagv2.2.1  New Features   Add resource templates by jlowinhttpsgithub.comjlowin in 230httpsgithub.comjlowinfastmcppull230  Fixes   Ensure that resource templates are properly exposed by jlowinhttpsgithub.comjlowin in 231httpsgithub.comjlowinfastmcppull231  Docs   Update docs for resource templates by jlowinhttpsgithub.comjlowin in 232httpsgithub.comjlowinfastmcppull232  Other Changes   Add resource template tests by jlowinhttpsgithub.comjlowin in 233httpsgithub.comjlowinfastmcppull233 Full Changelog v2.2.0...v2.2.1httpsgithub.comjlowinfastmcpcomparev2.2.0...v2.2.1  v2.2.0 Compose Yourselfhttpsgithub.comjlowinfastmcpreleasestagv2.2.0  New Features   Add support for mounting FastMCP servers by jlowinhttpsgithub.comjlowin in 175httpsgithub.comjlowinfastmcppull175  Add support for duplicate behavior  ignore by jlowinhttpsgithub.comjlowin in 169httpsgithub.comjlowinfastmcppull169  Breaking Changes   Refactor MCP composition by jlowinhttpsgithub.comjlowin in 176httpsgithub.comjlowinfastmcppull176  Docs   Improve integration documentation by jlowinhttpsgithub.comjlowin in 184httpsgithub.comjlowinfastmcppull184  Improve documentation by jlowinhttpsgithub.comjlowin in 185httpsgithub.comjlowinfastmcppull185  Other Changes   Add transport kwargs for mcp.run and fastmcp run by jlowinhttpsgithub.comjlowin in 161httpsgithub.comjlowinfastmcppull161  Allow resource templates to have optional  excluded arguments by jlowinhttpsgithub.comjlowin in 164httpsgithub.comjlowinfastmcppull164  Update resources.mdx by jlowinhttpsgithub.comjlowin in 165httpsgithub.comjlowinfastmcppull165  New Contributors  kongqi404httpsgithub.comkongqi404 made their first contribution in 181httpsgithub.comjlowinfastmcppull181 Full Changelog v2.1.2...v2.2.0httpsgithub.comjlowinfastmcpcomparev2.1.2...v2.2.0  v2.1.2 Copy That, Good Buddyhttpsgithub.comjlowinfastmcpreleasestagv2.1.2 The main improvement in this release is a fix that allows FastAPI  OpenAPI-generated servers to be mounted as sub-servers.  Fixes   Ensure objects are copied properly and test mounting fastapi by jlowinhttpsgithub.comjlowin in 153httpsgithub.comjlowinfastmcppull153  Docs   Fix broken links in docs by jlowinhttpsgithub.comjlowin in 154httpsgithub.comjlowinfastmcppull154  Other Changes   Update README.md by jlowinhttpsgithub.comjlowin in 149httpsgithub.comjlowinfastmcppull149  Only apply log config to FastMCP loggers by jlowinhttpsgithub.comjlowin in 155httpsgithub.comjlowinfastmcppull155  Update pyproject.toml by jlowinhttpsgithub.comjlowin in 156httpsgithub.comjlowinfastmcppull156 Full Changelog v2.1.1...v2.1.2httpsgithub.comjlowinfastmcpcomparev2.1.1...v2.1.2  v2.1.1 Doc Holidayhttpsgithub.comjlowinfastmcpreleasestagv2.1.1 FastMCPs docs are now available at gofastmcp.com.  Docs   Add docs by jlowinhttpsgithub.comjlowin in 136httpsgithub.comjlowinfastmcppull136  Add docs link to readme by jlowinhttpsgithub.comjlowin in 137httpsgithub.comjlowinfastmcppull137  Minor docs updates by jlowinhttpsgithub.comjlowin in 138httpsgithub.comjlowinfastmcppull138  Fixes   fix branch name in example by zzstoatzzhttpsgithub.comzzstoatzz in 140httpsgithub.comjlowinfastmcppull140  Other Changes   smart home example by zzstoatzzhttpsgithub.comzzstoatzz in 115httpsgithub.comjlowinfastmcppull115  Remove mac os tests by jlowinhttpsgithub.comjlowin in 142httpsgithub.comjlowinfastmcppull142  Expand support for various method interactions by jlowinhttpsgithub.comjlowin in 143httpsgithub.comjlowinfastmcppull143  Update docs and add_resource_fn by jlowinhttpsgithub.comjlowin in 144httpsgithub.comjlowinfastmcppull144  Update description by jlowinhttpsgithub.comjlowin in 145httpsgithub.comjlowinfastmcppull145  Support openapi 3.0 and 3.1 by jlowinhttpsgithub.comjlowin in 147httpsgithub.comjlowinfastmcppull147 Full Changelog v2.1.0...v2.1.1httpsgithub.comjlowinfastmcpcomparev2.1.0...v2.1.1  v2.1.0 Tag, Youre Ithttpsgithub.comjlowinfastmcpreleasestagv2.1.0 The primary motivation for this release is the fix in 128 for Claude desktop compatibility, but the primary new feature of this release is per-object tags. Currently these are for bookkeeping only but will become useful in future releases.  New Features   Add tags for all core MCP objects by jlowinhttpsgithub.comjlowin in 121httpsgithub.comjlowinfastmcppull121  Ensure that openapi tags are transferred to MCP objects by jlowinhttpsgithub.comjlowin in 124httpsgithub.comjlowinfastmcppull124  Fixes   Change default mounted tool separator from  to _ by jlowinhttpsgithub.comjlowin in 128httpsgithub.comjlowinfastmcppull128  Enter mounted app lifespans by jlowinhttpsgithub.comjlowin in 129httpsgithub.comjlowinfastmcppull129  Fix CLI that called mcp instead of fastmcp by jlowinhttpsgithub.comjlowin in 128httpsgithub.comjlowinfastmcppull128  Breaking Changes   Changed configuration for duplicate resourcestoolsprompts by jlowinhttpsgithub.comjlowin in 121httpsgithub.comjlowinfastmcppull121  Improve client return types by jlowinhttpsgithub.comjlowin in 123httpsgithub.comjlowinfastmcppull123  Other Changes   Add tests for tags in server decorators by jlowinhttpsgithub.comjlowin in 122httpsgithub.comjlowinfastmcppull122  Clean up server tests by jlowinhttpsgithub.comjlowin in 125httpsgithub.comjlowinfastmcppull125 Full Changelog v2.0.0...v2.1.0httpsgithub.comjlowinfastmcpcomparev2.0.0...v2.1.0  v2.0.0 Second to Nonehttpsgithub.comjlowinfastmcpreleasestagv2.0.0  New Features   Support mounting FastMCP instances as sub-MCPs by jlowinhttpsgithub.comjlowin in 99httpsgithub.comjlowinfastmcppull99  Add in-memory client for calling FastMCP servers and tests by jlowinhttpsgithub.comjlowin in 100httpsgithub.comjlowinfastmcppull100  Add MCP proxy server by jlowinhttpsgithub.comjlowin in 105httpsgithub.comjlowinfastmcppull105  Update FastMCP for upstream changes by jlowinhttpsgithub.comjlowin in 107httpsgithub.comjlowinfastmcppull107  Generate FastMCP servers from OpenAPI specs and FastAPI by jlowinhttpsgithub.comjlowin in 110httpsgithub.comjlowinfastmcppull110  Reorganize all client  transports by jlowinhttpsgithub.comjlowin in 111httpsgithub.comjlowinfastmcppull111  Add sampling and roots by jlowinhttpsgithub.comjlowin in 117httpsgithub.comjlowinfastmcppull117  Fixes   Fix bug with tools that return lists by jlowinhttpsgithub.comjlowin in 116httpsgithub.comjlowinfastmcppull116  Other Changes   Add back FastMCP CLI by jlowinhttpsgithub.comjlowin in 108httpsgithub.comjlowinfastmcppull108  Update Readme for v2 by jlowinhttpsgithub.comjlowin in 112httpsgithub.comjlowinfastmcppull112  fix deprecation warnings by zzstoatzzhttpsgithub.comzzstoatzz in 113httpsgithub.comjlowinfastmcppull113  Readme by jlowinhttpsgithub.comjlowin in 118httpsgithub.comjlowinfastmcppull118  FastMCP 2.0 by jlowinhttpsgithub.comjlowin in 119httpsgithub.comjlowinfastmcppull119 Full Changelog v1.0...v2.0.0httpsgithub.comjlowinfastmcpcomparev1.0...v2.0.0  v1.0 Its Officialhttpsgithub.comjlowinfastmcpreleasestagv1.0 This release commemorates FastMCP 1.0, which is included in the official Model Context Protocol SDK python from mcp.server.fastmcp import FastMCP  To the best of my knowledge, v1 is identical to the upstream version included with mcp.  Docs   Update readme to redirect to the official SDK by jlowinhttpsgithub.comjlowin in 79httpsgithub.comjlowinfastmcppull79  Other Changes   fix use Mount instead of Route for SSE message handling by samihaminehttpsgithub.comsamihamine in 77httpsgithub.comjlowinfastmcppull77  New Contributors  samihaminehttpsgithub.comsamihamine made their first contribution in 77httpsgithub.comjlowinfastmcppull77 Full Changelog v0.4.1...v1.0httpsgithub.comjlowinfastmcpcomparev0.4.1...v1.0  v0.4.1 String Theoryhttpsgithub.comjlowinfastmcpreleasestagv0.4.1  Fixes   fix handle strings containing numbers correctly by sd2khttpsgithub.comsd2k in 63httpsgithub.comjlowinfastmcppull63  Docs   patch Update pyproject.toml license by leonkozlowskihttpsgithub.comleonkozlowski in 67httpsgithub.comjlowinfastmcppull67  Other Changes   Avoid new try_eval_type unavailable with older pydantic by jurasofishhttpsgithub.comjurasofish in 57httpsgithub.comjlowinfastmcppull57  Decorator typing by jurasofishhttpsgithub.comjurasofish in 56httpsgithub.comjlowinfastmcppull56  New Contributors  leonkozlowskihttpsgithub.comleonkozlowski made their first contribution in 67httpsgithub.comjlowinfastmcppull67 Full Changelog v0.4.0...v0.4.1httpsgithub.comjlowinfastmcpcomparev0.4.0...v0.4.1  v0.4.0 Nice to MIT Youhttpsgithub.comjlowinfastmcpreleasestagv0.4.0 This is a relatively small release in terms of features, but the version is bumped to 0.4 to reflect that the code is being relicensed from Apache 2.0 to MIT. This is to facilitate FastMCPs inclusion in the official MCP SDK.  New Features   Add pyright  tests by jlowinhttpsgithub.comjlowin in 52httpsgithub.comjlowinfastmcppull52  add pgvector memory example by zzstoatzzhttpsgithub.comzzstoatzz in 49httpsgithub.comjlowinfastmcppull49  Fixes   fix use stderr for logging by sd2khttpsgithub.comsd2k in 51httpsgithub.comjlowinfastmcppull51  Docs   Update ai-labeler.yml by jlowinhttpsgithub.comjlowin in 48httpsgithub.comjlowinfastmcppull48  Relicense from Apache 2.0 to MIT by jlowinhttpsgithub.comjlowin in 54httpsgithub.comjlowinfastmcppull54  Other Changes   fix warning and flake by zzstoatzzhttpsgithub.comzzstoatzz in 47httpsgithub.comjlowinfastmcppull47  New Contributors  sd2khttpsgithub.comsd2k made their first contribution in 51httpsgithub.comjlowinfastmcppull51 Full Changelog v0.3.5...v0.4.0httpsgithub.comjlowinfastmcpcomparev0.3.5...v0.4.0  v0.3.5 Windows of Opportunityhttpsgithub.comjlowinfastmcpreleasestagv0.3.5 This release is highlighted by the ability to handle complex JSON objects as MCP inputs and improved Windows compatibility.  New Features   Set up multiple os tests by jlowinhttpsgithub.comjlowin in 44httpsgithub.comjlowinfastmcppull44  Changes to accomodate windows users. by justjoeherehttpsgithub.comjustjoehere in 42httpsgithub.comjlowinfastmcppull42  Handle complex inputs by jurasofishhttpsgithub.comjurasofish in 31httpsgithub.comjlowinfastmcppull31  Docs   Make AI labeler more conservative by jlowinhttpsgithub.comjlowin in 46httpsgithub.comjlowinfastmcppull46  Other Changes   Additional Windows Fixes for Dev running and for importing modules in a server by justjoeherehttpsgithub.comjustjoehere in 43httpsgithub.comjlowinfastmcppull43  New Contributors  justjoeherehttpsgithub.comjustjoehere made their first contribution in 42httpsgithub.comjlowinfastmcppull42  jurasofishhttpsgithub.comjurasofish made their first contribution in 31httpsgithub.comjlowinfastmcppull31 Full Changelog v0.3.4...v0.3.5httpsgithub.comjlowinfastmcpcomparev0.3.4...v0.3.5  v0.3.4 URLs Well That Ends Wellhttpsgithub.comjlowinfastmcpreleasestagv0.3.4  Fixes   Handle missing config file when installing by jlowinhttpsgithub.comjlowin in 37httpsgithub.comjlowinfastmcppull37  Remove BaseURL reference and use AnyURL by jlowinhttpsgithub.comjlowin in 40httpsgithub.comjlowinfastmcppull40 Full Changelog v0.3.3...v0.3.4httpsgithub.comjlowinfastmcpcomparev0.3.3...v0.3.4  v0.3.3 Dependence Dayhttpsgithub.comjlowinfastmcpreleasestagv0.3.3  New Features   Surge example by zzstoatzzhttpsgithub.comzzstoatzz in 29httpsgithub.comjlowinfastmcppull29  Support Python dependencies in Server by jlowinhttpsgithub.comjlowin in 34httpsgithub.comjlowinfastmcppull34  Docs   add Contributing section to README by zzstoatzzhttpsgithub.comzzstoatzz in 32httpsgithub.comjlowinfastmcppull32 Full Changelog v0.3.2...v0.3.3httpsgithub.comjlowinfastmcpcomparev0.3.2...v0.3.3  v0.3.2 Green with ENVyhttpsgithub.comjlowinfastmcpreleasestagv0.3.2  New Features   Support env vars when installing by jlowinhttpsgithub.comjlowin in 27httpsgithub.comjlowinfastmcppull27  Docs   Remove top level env var by jlowinhttpsgithub.comjlowin in 28httpsgithub.comjlowinfastmcppull28 Full Changelog v0.3.1...v0.3.2httpsgithub.comjlowinfastmcpcomparev0.3.1...v0.3.2  v0.3.1httpsgithub.comjlowinfastmcpreleasestagv0.3.1  New Features   Update README.md by jlowinhttpsgithub.comjlowin in 23httpsgithub.comjlowinfastmcppull23  add rich handler and dotenv loading for settings by zzstoatzzhttpsgithub.comzzstoatzz in 22httpsgithub.comjlowinfastmcppull22  print exception when server cant start by jlowinhttpsgithub.comjlowin in 25httpsgithub.comjlowinfastmcppull25  Docs   Update README.md by jlowinhttpsgithub.comjlowin in 24httpsgithub.comjlowinfastmcppull24  Other Changes   Remove log by jlowinhttpsgithub.comjlowin in 26httpsgithub.comjlowinfastmcppull26 Full Changelog v0.3.0...v0.3.1httpsgithub.comjlowinfastmcpcomparev0.3.0...v0.3.1  v0.3.0 Prompt and Circumstancehttpsgithub.comjlowinfastmcpreleasestagv0.3.0  New Features   Update README by jlowinhttpsgithub.comjlowin in 3httpsgithub.comjlowinfastmcppull3  Make log levels strings by jlowinhttpsgithub.comjlowin in 4httpsgithub.comjlowinfastmcppull4  Make content method a function by jlowinhttpsgithub.comjlowin in 5httpsgithub.comjlowinfastmcppull5  Add template support by jlowinhttpsgithub.comjlowin in 6httpsgithub.comjlowinfastmcppull6  Refactor resources module by jlowinhttpsgithub.comjlowin in 7httpsgithub.comjlowinfastmcppull7  Clean up cli imports by jlowinhttpsgithub.comjlowin in 8httpsgithub.comjlowinfastmcppull8  Prepare to list templates by jlowinhttpsgithub.comjlowin in 11httpsgithub.comjlowinfastmcppull11  Move image to separate module by jlowinhttpsgithub.comjlowin in 9httpsgithub.comjlowinfastmcppull9  Add support for request context, progress, logging, etc. by jlowinhttpsgithub.comjlowin in 12httpsgithub.comjlowinfastmcppull12  Add context tests and better runtime loads by jlowinhttpsgithub.comjlowin in 13httpsgithub.comjlowinfastmcppull13  Refactor tools  resourcemanager by jlowinhttpsgithub.comjlowin in 14httpsgithub.comjlowinfastmcppull14  func  fn everywhere by jlowinhttpsgithub.comjlowin in 15httpsgithub.comjlowinfastmcppull15  Add support for prompts by jlowinhttpsgithub.comjlowin in 16httpsgithub.comjlowinfastmcppull16  Create LICENSE by jlowinhttpsgithub.comjlowin in 18httpsgithub.comjlowinfastmcppull18  Update cli file spec by jlowinhttpsgithub.comjlowin in 19httpsgithub.comjlowinfastmcppull19  Update readmeUpdate README by jlowinhttpsgithub.comjlowin in 20httpsgithub.comjlowinfastmcppull20  Use hatchling for version by jlowinhttpsgithub.comjlowin in 21httpsgithub.comjlowinfastmcppull21  Other Changes   Add echo server by jlowinhttpsgithub.comjlowin in 1httpsgithub.comjlowinfastmcppull1  Add github workflows by jlowinhttpsgithub.comjlowin in 2httpsgithub.comjlowinfastmcppull2  typing updates by zzstoatzzhttpsgithub.comzzstoatzz in 17httpsgithub.comjlowinfastmcppull17  New Contributors  jlowinhttpsgithub.comjlowin made their first contribution in 1httpsgithub.comjlowinfastmcppull1  zzstoatzzhttpsgithub.comzzstoatzz made their first contribution in 17httpsgithub.comjlowinfastmcppull17 Full Changelog v0.2.0...v0.3.0httpsgithub.comjlowinfastmcpcomparev0.2.0...v0.3.0  v0.2.0httpsgithub.comjlowinfastmcpreleasestagv0.2.0 Full Changelog v0.1.0...v0.2.0httpsgithub.comjlowinfastmcpcomparev0.1.0...v0.2.0  v0.1.0httpsgithub.comjlowinfastmcpreleasestagv0.1.0 The very first release of FastMCP!  Full Changelog Initial commitshttpsgithub.comjlowinfastmcpcommitsv0.1.0  Bearer Token Authentication Source httpsgofastmcp.comclientsauthbearer Authenticate your FastMCP client with a Bearer token. export const VersionBadge  version   return New in versionversion   Bearer Token authentication is only relevant for HTTP-based transports. You can configure your FastMCP client to use bearer authentication by supplying a valid access token. This is most appropriate for service accounts, long-lived API keys, CICD, applications where authentication is managed separately, or other non-interactive authentication methods. A Bearer token is a JSON Web Token JWT that is used to authenticate a request. It is most commonly used in the Authorization header of an HTTP request, using the Bearer scheme http Authorization Bearer   Client Usage The most straightforward way to use a pre-existing Bearer token is to provide it as a string to the auth parameter of the fastmcp.Client or transport instance. FastMCP will automatically format it correctly for the Authorization header and bearer scheme. If youre using a string token, do not include the Bearer prefix. FastMCP will add it for you. python 5 from fastmcp import Client async with Client httpsfastmcp.cloudmcp, auth,  as client await client.ping  You can also supply a Bearer token to a transport instance, such as StreamableHttpTransport or SSETransport python 6 from fastmcp import Client from fastmcp.client.transports import StreamableHttpTransport transport  StreamableHttpTransport httpfastmcp.cloudmcp, auth,  async with Clienttransport as client await client.ping   BearerAuth Helper If you prefer to be more explicit and not rely on FastMCP to transform your string token, you can use the BearerAuth class yourself, which implements the httpx.Auth interface. python 6 from fastmcp import Client from fastmcp.client.auth import BearerAuth async with Client httpsfastmcp.cloudmcp, authBearerAuthtoken,  as client await client.ping   Custom Headers If the MCP server expects a custom header or token scheme, you can manually set the clients headers instead of using the auth parameter by setting them on your transport python 5 from fastmcp import Client from fastmcp.client.transports import StreamableHttpTransport async with Client transportStreamableHttpTransport httpsfastmcp.cloudmcp, headersX-API-Key , ,  as client await client.ping   OAuth Authentication Source httpsgofastmcp.comclientsauthoauth Authenticate your FastMCP client via OAuth 2.1. export const VersionBadge  version   return New in versionversion   OAuth authentication is only relevant for HTTP-based transports and requires user interaction via a web browser. When your FastMCP client needs to access an MCP server protected by OAuth 2.1, and the process requires user interaction like logging in and granting consent, you should use the Authorization Code Flow. FastMCP provides the fastmcp.client.auth.OAuth helper to simplify this entire process. This flow is common for user-facing applications where the application acts on behalf of the user.  Client Usage  Default Configuration The simplest way to use OAuth is to pass the string oauth to the auth parameter of the Client or transport instance. FastMCP will automatically configure the client to use OAuth with default settings python 4 from fastmcp import Client  Uses default OAuth settings async with Clienthttpsfastmcp.cloudmcp, authoauth as client await client.ping   OAuth Helper To fully configure the OAuth flow, use the OAuth helper and pass it to the auth parameter of the Client or transport instance. OAuth manages the complexities of the OAuth 2.1 Authorization Code Grant with PKCE Proof Key for Code Exchange for enhanced security, and implements the full httpx.Auth interface. python 2, 4, 6 from fastmcp import Client from fastmcp.client.auth import OAuth oauth  OAuthmcp_urlhttpsfastmcp.cloudmcp async with Clienthttpsfastmcp.cloudmcp, authoauth as client await client.ping   OAuth Parameters  mcp_url str The full URL of the target MCP server endpoint. Used to discover OAuth server metadata  scopes str  liststr, optional OAuth scopes to request. Can be space-separated string or list of strings  client_name str, optional Client name for dynamic registration. Defaults to FastMCP Client  token_storage_cache_dir Path, optional Token cache directory. Defaults to .fastmcpoauth-mcp-client-cache  additional_client_metadata dictstr, Any, optional Extra metadata for client registration  OAuth Flow The OAuth flow is triggered when you use a FastMCP Client configured to use OAuth. The client first checks the token_storage_cache_dir for existing, valid tokens for the target server. If one is found, it will be used to authenticate the client. If no valid tokens exist, the client attempts to discover the OAuth servers endpoints using a well-known URI e.g., .well-knownoauth-authorization-server based on the mcp_url. If the OAuth server supports it and the client isnt already registered or credentials arent cached, the client performs dynamic client registration according to RFC 7591. A temporary local HTTP server is started on an available port. This servers address e.g., http127.0.0.1callback acts as the redirect_uri for the OAuth flow. The users default web browser is automatically opened, directing them to the OAuth servers authorization endpoint. The user logs in and grants or denies the requested scopes. Upon approval, the OAuth server redirects the users browser to the local callback server with an authorization_code. The client captures this code and exchanges it with the OAuth servers token endpoint for an access_token and often a refresh_token using PKCE for security. The obtained tokens are saved to the token_storage_cache_dir for future use, eliminating the need for repeated browser interactions. The access token is automatically included in the Authorization header for requests to the MCP server. If the access token expires, the client will automatically use the refresh token to get a new access token.  Token Management  Token Storage OAuth access tokens are automatically cached in .fastmcpoauth-mcp-client-cache and persist between application runs. Files are keyed by the OAuth servers base URL.  Managing Cache To clear the tokens for a specific server, instantiate a FileTokenStorage instance and call the clear method python from fastmcp.client.auth.oauth import FileTokenStorage storage  FileTokenStorageserver_urlhttpsfastmcp.cloudmcp await storage.clear  To clear all tokens for all servers, call the clear_all method on the FileTokenStorage class python from fastmcp.client.auth.oauth import FileTokenStorage FileTokenStorage.clear_all   The FastMCP Client Source httpsgofastmcp.comclientsclient Programmatic client for interacting with MCP servers through a well-typed, Pythonic interface. export const VersionBadge  version   return New in versionversion   The central piece of MCP client applications is the fastmcp.Client class. This class provides a programmatic interface for interacting with any Model Context Protocol MCP server, handling protocol details and connection management automatically. The FastMCP Client is designed for deterministic, controlled interactions rather than autonomous behavior, making it ideal for  Testing MCP servers during development  Building deterministic applications that need reliable MCP interactions  Creating the foundation for agentic or LLM-based clients with structured, type-safe operations All client operations require using the async with context manager for proper connection lifecycle management. This is not an agentic client - it requires explicit function calls and provides direct control over all MCP operations. Use it as a building block for higher-level systems.  Creating a Client Creating a client is straightforward. You provide a server source and the client automatically infers the appropriate transport mechanism. python import asyncio from fastmcp import Client, FastMCP  In-memory server ideal for testing server  FastMCPTestServer client  Clientserver  HTTP server client  Clienthttpsexample.commcp  Local Python script client  Clientmy_mcp_server.py async def main async with client  Basic server interaction await client.ping  List available operations tools  await client.list_tools resources  await client.list_resources prompts  await client.list_prompts  Execute operations result  await client.call_toolexample_tool, param value printresult asyncio.runmain   Client-Transport Architecture The FastMCP Client separates concerns between protocol and connection  Client Handles MCP protocol operations tools, resources, prompts and manages callbacks  Transport Establishes and maintains the connection WebSockets, HTTP, Stdio, in-memory  Transport Inference The client automatically infers the appropriate transport based on the input 1. FastMCP instance  In-memory transport perfect for testing 2. File path ending in .py  Python Stdio transport 3. File path ending in .js  Node.js Stdio transport 4. URL starting with http or https  HTTP transport 5. MCPConfig dictionary  Multi-server client python from fastmcp import Client, FastMCP  Examples of transport inference client_memory  ClientFastMCPTestServer client_script  Client.server.py client_http  Clienthttpsapi.example.commcp  For testing and development, always prefer the in-memory transport by passing a FastMCP server directly to the client. This eliminates network complexity and separate processes.  Configuration-Based Clients Create clients from MCP configuration dictionaries, which can include multiple servers. While there is no official standard for MCP configuration format, FastMCP follows established conventions used by tools like Claude Desktop.  Configuration Format python config   mcpServers  server_name   Remote HTTPSSE server transport http,  or sse url httpsapi.example.commcp, headers Authorization Bearer token, auth oauth  or bearer token string , local_server   Local stdio server transport stdio command python, args .server.py, --verbose, env DEBUG true, cwd pathtoserver,      Multi-Server Example python config   mcpServers  weather url httpsweather-api.example.commcp, assistant command python, args .assistant_server.py   client  Clientconfig async with client  Tools are prefixed with server names weather_data  await client.call_toolweather_get_forecast, city London response  await client.call_toolassistant_answer_question, question Whats the capital of France?  Resources use prefixed URIs icons  await client.read_resourceweatherweathericonssunny templates  await client.read_resourceresourceassistanttemplateslist   Connection Lifecycle The client operates asynchronously and uses context managers for connection management python async def example client  Clientmy_mcp_server.py  Connection established here async with client printfConnected client.is_connected  Make multiple calls within the same session tools  await client.list_tools result  await client.call_toolgreet, name World  Connection closed automatically here printfConnected client.is_connected   Operations FastMCP clients can interact with several types of server components  Tools Tools are server-side functions that the client can execute with arguments. python async with client  List available tools tools  await client.list_tools  Execute a tool result  await client.call_toolmultiply, a 5, b 3 printresult0.text  15  See Toolsclientstools for detailed documentation.  Resources Resources are data sources that the client can read, either static or templated. python async with client  List available resources resources  await client.list_resources  Read a resource content  await client.read_resourcefileconfigsettings.json printcontent0.text  See Resourcesclientsresources for detailed documentation.  Prompts Prompts are reusable message templates that can accept arguments. python async with client  List available prompts prompts  await client.list_prompts  Get a rendered prompt messages  await client.get_promptanalyze_data, data 1, 2, 3 printmessages.messages  See Promptsclientsprompts for detailed documentation.  Server Connectivity Use ping to verify the server is reachable python async with client await client.ping printServer is reachable   Client Configuration Clients can be configured with additional handlers and settings for specialized use cases.  Callback Handlers The client supports several callback handlers for advanced server interactions python from fastmcp import Client from fastmcp.client.logging import LogMessage async def log_handlermessage LogMessage printfServer log message.data async def progress_handlerprogress float, total float  None, message str  None printfProgress progresstotal - message async def sampling_handlermessages, params, context  Integrate with your LLM service here return Generated response client  Client my_mcp_server.py, log_handlerlog_handler, progress_handlerprogress_handler, sampling_handlersampling_handler, timeout30.0   The Client constructor accepts several configuration options  transport Transport instance or source for automatic inference  log_handler Handle server log messages  progress_handler Monitor long-running operations  sampling_handler Respond to server LLM requests  roots Provide local context to servers  timeout Default timeout for requests in seconds  Transport Configuration For detailed transport configuration headers, authentication, environment variables, see the Transportsclientstransports documentation.  Next Steps Explore the detailed documentation for each operation type  Core Operations  Toolsclientstools - Execute server-side functions and handle results  Resourcesclientsresources - Access static and templated resources  Promptsclientsprompts - Work with message templates and argument serialization  Advanced Features  Loggingclientslogging - Handle server log messages  Progressclientsprogress - Monitor long-running operations  Samplingclientssampling - Respond to server LLM requests  Rootsclientsroots - Provide local context to servers  Connection Details  Transportsclientstransports - Configure connection methods and parameters  Authenticationclientsauthoauth - Set up OAuth and bearer token authentication The FastMCP Client is designed as a foundational tool. Use it directly for deterministic operations, or build higher-level agentic systems on top of its reliable, type-safe interface.  Server Logging Source httpsgofastmcp.comclientslogging Receive and handle log messages from MCP servers. export const VersionBadge  version   return New in versionversion   MCP servers can emit log messages to clients. The client can handle these logs through a log handler callback.  Log Handler Provide a log_handler function when creating the client python from fastmcp import Client from fastmcp.client.logging import LogMessage async def log_handlermessage LogMessage level  message.level.upper logger  message.logger or server data  message.data printflevel logger data client  Client my_mcp_server.py, log_handlerlog_handler,    Handler Parameters The log_handler is called every time a log message is received. It receives a LogMessage object The log level The logger name optional, may be None The actual log message content python async def detailed_log_handlermessage LogMessage if message.level  error printfERROR message.data elif message.level  warning printfWARNING message.data else printfmessage.level.upper message.data   Default Log Handling If you dont provide a custom log_handler, FastMCP uses a default handler that emits a DEBUG-level FastMCP log for every log message received from the server, which is useful for visibility without polluting your own logs. python client  Clientmy_mcp_server.py async with client  Server logs will be emitted at DEBUG level automatically await client.call_toolsome_tool   Progress Monitoring Source httpsgofastmcp.comclientsprogress Handle progress notifications from long-running server operations. export const VersionBadge  version   return New in versionversion   MCP servers can report progress during long-running operations. The client can receive these updates through a progress handler.  Progress Handler Set a progress handler when creating the client python from fastmcp import Client async def my_progress_handler progress float, total float  None, message str  None  - None if total is not None percentage  progress  total  100 printfProgress percentage.1f - message or  else printfProgress progress - message or  client  Client my_mcp_server.py, progress_handlermy_progress_handler    Handler Parameters The progress handler receives three parameters Current progress value Expected total value may be None Optional status message may be None  Per-Call Progress Handler Override the progress handler for specific tool calls python async with client  Override with specific progress handler for this call result  await client.call_tool long_running_task, param value, progress_handlermy_progress_handler    Prompts Source httpsgofastmcp.comclientsprompts Use server-side prompt templates with automatic argument serialization. export const VersionBadge  version   return New in versionversion   Prompts are reusable message templates exposed by MCP servers. They can accept arguments to generate personalized message sequences for LLM interactions.  Listing Prompts Use list_prompts to retrieve all available prompt templates python async with client prompts  await client.list_prompts  prompts - listmcp.types.Prompt for prompt in prompts printfPrompt prompt.name printfDescription prompt.description if prompt.arguments printfArguments arg.name for arg in prompt.arguments   Using Prompts  Basic Usage Request a rendered prompt using get_prompt with the prompt name and arguments python async with client  Simple prompt without arguments result  await client.get_promptwelcome_message  result - mcp.types.GetPromptResult  Access the generated messages for message in result.messages printfRole message.role printfContent message.content   Prompts with Arguments Pass arguments as a dictionary to customize the prompt python async with client  Prompt with simple arguments result  await client.get_promptuser_greeting,  name Alice, role administrator   Access the personalized messages for message in result.messages printfGenerated message message.content   Automatic Argument Serialization FastMCP automatically serializes complex arguments to JSON strings as required by the MCP specification. This allows you to pass typed objects directly python from dataclasses import dataclass dataclass class UserData name str age int async with client  Complex arguments are automatically serialized result  await client.get_promptanalyze_user,  user UserDatanameAlice, age30,  Automatically serialized to JSON preferences theme dark,  Dict serialized to JSON string scores 85, 92, 78,  List serialized to JSON string simple_name Bob  Strings passed through unchanged   The client handles serialization using pydantic_core.to_json for consistent formatting. FastMCP servers can automatically deserialize these JSON strings back to the expected types.  Serialization Examples python async with client result  await client.get_promptdata_analysis,   These will be automatically serialized to JSON strings config  format csv, include_headers True, delimiter , , filters  field age, operator , value 18, field status, operator , value active ,  This remains a string report_title Monthly Analytics Report    Working with Prompt Results The get_prompt method returns a GetPromptResult object containing a list of messages python async with client result  await client.get_promptconversation_starter, topic climate  Access individual messages for i, message in enumerateresult.messages printfMessage i  1 printf Role message.role printf Content message.content.text if hasattrmessage.content, text else message.content   Raw MCP Protocol Access For access to the complete MCP protocol objects, use the _mcp methods python async with client  Raw MCP method returns full protocol object prompts_result  await client.list_prompts_mcp  prompts_result - mcp.types.ListPromptsResult prompt_result  await client.get_prompt_mcpexample_prompt, arg value  prompt_result - mcp.types.GetPromptResult   Multi-Server Clients When using multi-server clients, prompts are accessible without prefixing unlike tools python async with client  Multi-server client  Prompts from any server are directly accessible result1  await client.get_promptweather_prompt, city London result2  await client.get_promptassistant_prompt, query help   Common Prompt Patterns  System Messages Many prompts generate system messages for LLM configuration python async with client result  await client.get_promptsystem_configuration,  role helpful assistant, expertise python programming   Typically returns messages with rolesystem system_message  result.messages0 printfSystem prompt system_message.content   Conversation Templates Prompts can generate multi-turn conversation templates python async with client result  await client.get_promptinterview_template,  candidate_name Alice, position Senior Developer   Multiple messages for a conversation flow for message in result.messages printfmessage.role message.content  Prompt arguments and their expected types depend on the specific prompt implementation. Check the servers documentation or use list_prompts to see available arguments for each prompt.  Resource Operations Source httpsgofastmcp.comclientsresources Access static and templated resources from MCP servers. export const VersionBadge  version   return New in versionversion   Resources are data sources exposed by MCP servers. They can be static files or dynamic templates that generate content based on parameters.  Types of Resources MCP servers expose two types of resources  Static Resources Fixed content accessible via URI e.g., configuration files, documentation  Resource Templates Dynamic resources that accept parameters to generate content e.g., API endpoints, database queries  Listing Resources  Static Resources Use list_resources to retrieve all static resources available on the server python async with client resources  await client.list_resources  resources - listmcp.types.Resource for resource in resources printfResource URI resource.uri printfName resource.name printfDescription resource.description printfMIME Type resource.mimeType   Resource Templates Use list_resource_templates to retrieve available resource templates python async with client templates  await client.list_resource_templates  templates - listmcp.types.ResourceTemplate for template in templates printfTemplate URI template.uriTemplate printfName template.name printfDescription template.description   Reading Resources  Static Resources Read a static resource using its URI python async with client  Read a static resource content  await client.read_resourcefilepathtoREADME.md  content - listmcp.types.TextResourceContents  mcp.types.BlobResourceContents  Access text content if hasattrcontent0, text printcontent0.text  Access binary content if hasattrcontent0, blob printfBinary data lencontent0.blob bytes   Resource Templates Read from a resource template by providing the URI with parameters python async with client  Read a resource generated from a template  For example, a template like weathercitycurrent weather_content  await client.read_resourceweatherlondoncurrent  Access the generated content printweather_content0.text  Assuming text JSON response   Content Types Resources can return different content types  Text Resources python async with client content  await client.read_resourceresourceconfigsettings.json for item in content if hasattritem, text printfText content item.text printfMIME type item.mimeType   Binary Resources python async with client content  await client.read_resourceresourceimageslogo.png for item in content if hasattritem, blob printfBinary content lenitem.blob bytes printfMIME type item.mimeType  Save to file with opendownloaded_logo.png, wb as f f.writeitem.blob   Working with Multi-Server Clients When using multi-server clients, resource URIs are automatically prefixed with the server name python async with client  Multi-server client  Access resources from different servers weather_icons  await client.read_resourceweatherweathericonssunny templates  await client.read_resourceresourceassistanttemplateslist printfWeather icon weather_icons0.blob printfTemplates templates0.text   Raw MCP Protocol Access For access to the complete MCP protocol objects, use the _mcp methods python async with client  Raw MCP methods return full protocol objects resources_result  await client.list_resources_mcp  resources_result - mcp.types.ListResourcesResult templates_result  await client.list_resource_templates_mcp  templates_result - mcp.types.ListResourceTemplatesResult content_result  await client.read_resource_mcpresourceexample  content_result - mcp.types.ReadResourceResult   Common Resource URI Patterns Different MCP servers may use various URI schemes python  File system resources filepathtofile.txt  Custom protocol resources weatherlondoncurrent databaseusers123  Generic resource protocol resourceconfigsettings resourcetemplatesemail  Resource URIs and their formats depend on the specific MCP server implementation. Check the servers documentation for available resources and their URI patterns.  Client Roots Source httpsgofastmcp.comclientsroots Provide local context and resource boundaries to MCP servers. export const VersionBadge  version   return New in versionversion   Roots are a way for clients to inform servers about the resources they have access to. Servers can use this information to adjust behavior or provide more relevant responses.  Setting Static Roots Provide a list of roots when creating the client python Static Roots from fastmcp import Client client  Client my_mcp_server.py, rootspathtoroot1, pathtoroot2   python Dynamic Roots Callback from fastmcp import Client from fastmcp.client.roots import RequestContext async def roots_callbackcontext RequestContext - liststr printfServer requested roots Request ID context.request_id return pathtoroot1, pathtoroot2 client  Client my_mcp_server.py, rootsroots_callback    LLM Sampling Source httpsgofastmcp.comclientssampling Handle server-initiated LLM sampling requests. export const VersionBadge  version   return New in versionversion   MCP servers can request LLM completions from clients. The client handles these requests through a sampling handler callback.  Sampling Handler Provide a sampling_handler function when creating the client python from fastmcp import Client from fastmcp.client.sampling import  SamplingMessage, SamplingParams, RequestContext,  async def sampling_handler messages listSamplingMessage, params SamplingParams, context RequestContext  - str  Your LLM integration logic here  Extract text from messages and generate a response return Generated response based on the messages client  Client my_mcp_server.py, sampling_handlersampling_handler,    Handler Parameters The sampling handler receives three parameters The role of the message. The content of the message. TextContent is most common, and has a .text attribute. The messages to sample from The servers preferences for which model to select. The client MAY ignore these preferences. The hints to use for model selection. The cost priority for model selection. The speed priority for model selection. The intelligence priority for model selection. An optional system prompt the server wants to use for sampling. A request to include context from one or more MCP servers including the caller, to be attached to the prompt. The sampling temperature. The maximum number of tokens to sample. The stop sequences to use for sampling. Optional metadata to pass through to the LLM provider. Unique identifier for the MCP request  Basic Example python from fastmcp import Client from fastmcp.client.sampling import SamplingMessage, SamplingParams, RequestContext async def basic_sampling_handler messages listSamplingMessage, params SamplingParams, context RequestContext  - str  Extract message content conversation   for message in messages content  message.content.text if hasattrmessage.content, text else strmessage.content conversation.appendfmessage.role content  Use the system prompt if provided system_prompt  params.systemPrompt or You are a helpful assistant.  Here you would integrate with your preferred LLM service  This is just a placeholder response return fResponse based on conversation   .joinconversation client  Client my_mcp_server.py, sampling_handlerbasic_sampling_handler    Tool Operations Source httpsgofastmcp.comclientstools Discover and execute server-side tools with the FastMCP client. export const VersionBadge  version   return New in versionversion   Tools are executable functions exposed by MCP servers. The FastMCP client provides methods to discover available tools and execute them with arguments.  Discovering Tools Use list_tools to retrieve all tools available on the server python async with client tools  await client.list_tools  tools - listmcp.types.Tool for tool in tools printfTool tool.name printfDescription tool.description if tool.inputSchema printfParameters tool.inputSchema   Executing Tools  Basic Execution Execute a tool using call_tool with the tool name and arguments python async with client  Simple tool call result  await client.call_tooladd, a 5, b 3  result - listmcp.types.TextContent  mcp.types.ImageContent  ...  Access the result content printresult0.text  Assuming TextContent, e.g., 8   Advanced Execution Options The call_tool method supports additional parameters for timeout control and progress monitoring python async with client  With timeout aborts if execution takes longer than 2 seconds result  await client.call_tool long_running_task, param value, timeout2.0   With progress handler to track execution progress result  await client.call_tool long_running_task, param value, progress_handlermy_progress_handler   Parameters  name The tool name string  arguments Dictionary of arguments to pass to the tool optional  timeout Maximum execution time in seconds optional, overrides client-level timeout  progress_handler Progress callback function optional, overrides client-level handler  Handling Results Tool execution returns a list of content objects. The most common types are  TextContent Text-based results with a .text attribute  ImageContent Image data with image-specific attributes  BlobContent Binary data content python async with client result  await client.call_toolget_weather, city London for content in result if hasattrcontent, text printfText result content.text elif hasattrcontent, data printfBinary data lencontent.data bytes   Error Handling  Exception-Based Error Handling By default, call_tool raises a ToolError if the tool execution fails python from fastmcp.exceptions import ToolError async with client try result  await client.call_toolpotentially_failing_tool, param value printTool succeeded, result except ToolError as e printfTool failed e   Manual Error Checking For more granular control, use call_tool_mcp which returns the raw MCP protocol object with an isError flag python async with client result  await client.call_tool_mcppotentially_failing_tool, param value  result - mcp.types.CallToolResult if result.isError printfTool failed result.content else printfTool succeeded result.content   Argument Handling Arguments are passed as a dictionary to the tool python async with client  Simple arguments result  await client.call_toolgreet, name World  Complex arguments result  await client.call_toolprocess_data,  config format json, validate True, items 1, 2, 3, 4, 5, metadata source api, version 1.0   For multi-server clients, tool names are automatically prefixed with the server name e.g., weather_get_forecast for a tool named get_forecast on the weather server.  Client Transports Source httpsgofastmcp.comclientstransports Understand the different ways FastMCP Clients can connect to servers. export const VersionBadge  version   return New in versionversion   The FastMCP Client relies on a ClientTransport object to handle the specifics of connecting to and communicating with an MCP server. FastMCP provides several built-in transport implementations for common connection methods. While the Client often infers the correct transport automatically see Client Overviewclientsclienttransport-inference, you can also instantiate transports explicitly for more control. Clients are lightweight objects, so dont hesitate to create new ones as needed. However, be mindful of the context management - each time you open a client context async with client, a new connection or process starts. For best performance, keep client contexts open while performing multiple operations rather than repeatedly opening and closing them.  Choosing a Transport Choose the transport that best fits your use case  Connecting to RemotePersistent Servers Use StreamableHttpTransport recommended, default for HTTP URLs or SSETransport legacy option for web-based deployments.  Local DevelopmentTesting Use FastMCPTransport for in-memory, same-process testing of your FastMCP servers.  Running Local Servers Use UvxStdioTransport Pythonuv or NpxStdioTransport Nodenpm if you need to run MCP servers as packaged tools.  Network Transports These transports connect to servers running over a network, typically long-running services accessible via URLs.  Streamable HTTP Streamable HTTP is the recommended transport for web-based deployments, providing efficient bidirectional communication over HTTP.  Overview  Class fastmcp.client.transports.StreamableHttpTransport  Inferred From URLs starting with http or https default for HTTP URLs since v2.3.0 that do not contain sse in the path  Server Compatibility Works with FastMCP servers running in http mode  Basic Usage The simplest way to use Streamable HTTP is to let the transport be inferred from a URL python from fastmcp import Client import asyncio  The Client automatically uses StreamableHttpTransport for HTTP URLs client  Clienthttpsexample.commcp async def main async with client tools  await client.list_tools printfAvailable tools tools asyncio.runmain  You can also explicitly instantiate the transport python from fastmcp.client.transports import StreamableHttpTransport transport  StreamableHttpTransporturlhttpsexample.commcp client  Clienttransport   Authentication with Headers For servers requiring authentication python from fastmcp import Client from fastmcp.client.transports import StreamableHttpTransport  Create transport with authentication headers transport  StreamableHttpTransport urlhttpsexample.commcp, headersAuthorization Bearer your-token-here  client  Clienttransport   SSE Server-Sent Events Server-Sent Events SSE is a transport that allows servers to push data to clients over HTTP connections. While still supported, Streamable HTTP is now the recommended transport for new web-based deployments.  Overview  Class fastmcp.client.transports.SSETransport  Inferred From HTTP URLs containing sse in the path  Server Compatibility Works with FastMCP servers running in sse mode  Basic Usage The simplest way to use SSE is to let the transport be inferred from a URL with sse in the path python from fastmcp import Client import asyncio  The Client automatically uses SSETransport for URLs containing sse in the path client  Clienthttpsexample.comsse async def main async with client tools  await client.list_tools printfAvailable tools tools asyncio.runmain  You can also explicitly instantiate the transport for URLs that do not contain sse in the path or for more control python from fastmcp.client.transports import SSETransport transport  SSETransporturlhttpsexample.comsse client  Clienttransport   Authentication with Headers SSE transport also supports custom headers for authentication python from fastmcp import Client from fastmcp.client.transports import SSETransport  Create SSE transport with authentication headers transport  SSETransport urlhttpsexample.comsse, headersAuthorization Bearer your-token-here  client  Clienttransport   When to Use SSE vs. Streamable HTTP  Use Streamable HTTP when  Setting up new deployments recommended default  You need bidirectional streaming  Youre connecting to FastMCP servers running in http mode  Use SSE when  Connecting to legacy FastMCP servers running in sse mode  Working with infrastructure optimized for Server-Sent Events  Local Transports These transports manage an MCP server running as a subprocess, communicating with it via standard input stdin and standard output stdout. This is the standard mechanism used by clients like Claude Desktop.  Session Management All stdio transports support a keep_alive parameter default True that controls session persistence across multiple client context managers  keep_aliveTrue default The subprocess and session are maintained between client context exits and re-entries. This improves performance when making multiple separate connections to the same server.  keep_aliveFalse A new subprocess is started for each client context, ensuring complete isolation between sessions. When keep_aliveTrue, you can manually close the session using await client.close if needed. This will terminate the subprocess and require a new one to be started on the next connection. python keep_aliveTrue from fastmcp import Client  Client with keep_aliveTrue default client  Clientmy_mcp_server.py async def example  First session async with client await client.ping  Second session - uses the same subprocess async with client await client.ping  Manually close the session await client.close  Third session - will start a new subprocess async with client await client.ping asyncio.runexample  python keep_aliveFalse from fastmcp import Client  Client with keep_aliveFalse client  Clientmy_mcp_server.py, keep_aliveFalse async def example  First session async with client await client.ping  Second session - will start a new subprocess async with client await client.ping  Third session - will start a new subprocess async with client await client.ping asyncio.runexample   Python Stdio  Class fastmcp.client.transports.PythonStdioTransport  Inferred From Paths to .py files  Use Case Running a Python-based MCP server script in a subprocess This is the most common way to interact with local FastMCP servers during development or when integrating with tools that expect to launch a server script. python from fastmcp import Client from fastmcp.client.transports import PythonStdioTransport server_script  my_mcp_server.py  Path to your server script  Option 1 Inferred transport client  Clientserver_script  Option 2 Explicit transport with custom configuration transport  PythonStdioTransport script_pathserver_script, python_cmdusrbinpython3.11,  Optional specify Python interpreter  args--some-server-arg,  Optional pass arguments to the script  envMY_VAR value,  Optional set environment variables  client  Clienttransport async def main async with client tools  await client.list_tools printfConnected via Python Stdio, found tools tools asyncio.runmain  The server script must include logic to start the MCP server and listen on stdio, typically via mcp.run or fastmcp.server.run. The Client only launches the script it doesnt inject the server logic.  Node.js Stdio  Class fastmcp.client.transports.NodeStdioTransport  Inferred From Paths to .js files  Use Case Running a Node.js-based MCP server script in a subprocess Similar to the Python transport, but for JavaScript servers. python from fastmcp import Client from fastmcp.client.transports import NodeStdioTransport node_server_script  my_mcp_server.js  Path to your Node.js server script  Option 1 Inferred transport client  Clientnode_server_script  Option 2 Explicit transport transport  NodeStdioTransport script_pathnode_server_script, node_cmdnode,  Optional specify path to Node executable  client  Clienttransport async def main async with client tools  await client.list_tools printfConnected via Node.js Stdio, found tools tools asyncio.runmain   UVX Stdio Experimental  Class fastmcp.client.transports.UvxStdioTransport  Inferred From Not automatically inferred  Use Case Running an MCP server packaged as a Python tool using uvxhttpsdocs.astral.shuvreferencecliuvx This is useful for executing MCP servers distributed as command-line tools or packages without installing them into your environment. python from fastmcp import Client from fastmcp.client.transports import UvxStdioTransport  Run a hypothetical cloud-analyzer-mcp tool via uvx transport  UvxStdioTransport tool_namecloud-analyzer-mcp,  from_packagecloud-analyzer-cli,  Optional specify package if tool name differs  with_packagesboto3, requests  Optional add dependencies  client  Clienttransport async def main async with client result  await client.call_toolanalyze_bucket, name my-data printfAnalysis result result asyncio.runmain   NPX Stdio Experimental  Class fastmcp.client.transports.NpxStdioTransport  Inferred From Not automatically inferred  Use Case Running an MCP server packaged as an NPM package using npx Similar to UvxStdioTransport, but for the Node.js ecosystem. python from fastmcp import Client from fastmcp.client.transports import NpxStdioTransport  Run an MCP server from an NPM package transport  NpxStdioTransport packagemcp-server-package,  args--port, stdio  Optional pass arguments to the package  client  Clienttransport async def main async with client result  await client.call_toolget_npm_data,  printfResult result asyncio.runmain   In-Memory Transports  FastMCP Transport  Class fastmcp.client.transports.FastMCPTransport  Inferred From An instance of fastmcp.server.FastMCP or a FastMCP 1.0 server mcp.server.fastmcp.FastMCP  Use Case Connecting directly to a FastMCP server instance in the same Python process This is extremely useful for testing your FastMCP servers. python from fastmcp import FastMCP, Client import asyncio  1. Create your FastMCP server instance server  FastMCPnameInMemoryServer server.tool def ping return pong  2. Create a client pointing directly to the server instance client  Clientserver  Transport is automatically inferred async def main async with client result  await client.call_toolping printfIn-memory call result result asyncio.runmain  Communication happens through efficient in-memory queues, making it very fast and ideal for unit testing.  Configuration-Based Transports  MCPConfig Transport  Class fastmcp.client.transports.MCPConfigTransport  Inferred From An instance of MCPConfig or a dictionary matching the MCPConfig schema  Use Case Connecting to one or more MCP servers defined in a configuration object MCPConfig follows an emerging standard for MCP server configuration but is subject to change as the specification evolves. The standard supports both local servers running via stdio and remote servers accessed via HTTP. python from fastmcp import Client  Configuration for multiple MCP servers both local and remote config   mcpServers   Remote HTTP server weather  url httpsweather-api.example.commcp, transport http ,  Local stdio server assistant  command python, args .assistant_server.py, env DEBUG true ,  Another remote server calendar  url httpscalendar-api.example.commcp, transport http     Create a transport from the config happens automatically with Client client  Clientconfig async def main async with client  Tools are accessible with server name prefixes weather  await client.call_toolweather_get_forecast, city London answer  await client.call_toolassistant_answer_question, query What is MCP? events  await client.call_toolcalendar_list_events, date 2023-06-01  Resources use prefixed URI paths icons  await client.read_resourceweatherweathericonssunny docs  await client.read_resourceresourceassistantdocsmcp asyncio.runmain  If your configuration has only a single server, the client will connect directly to that server without any prefixing. This makes it convenient to switch between single and multi-server configurations without changing your client code. The MCPConfig format is an emerging standard for MCP server configuration and may change as the MCP ecosystem evolves. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change.  Community Showcase Source httpsgofastmcp.comcommunityshowcase High-quality projects and examples from the FastMCP community export const YouTubeEmbed  videoId, title   return    Featured Projects Discover exemplary MCP servers and implementations created by our community. These projects demonstrate best practices and innovative uses of FastMCP.  Learning Resources A comprehensive educational example demonstrating FastMCP best practices with professional dual-transport server implementation, interactive test client, and detailed documentation.  Video Tutorials Build Remote MCP Servers w Python  FastMCP - Claude Integrations Tutorial by Greg  Code FastMCP  the best way to build an MCP server with Python - Tutorial by ZazenCodes Speedrun a MCP server for Claude Desktop fastmcp - Tutorial by Nate from Prefect  Community Examples Have you built something interesting with FastMCP? Wed love to feature high-quality examples here! Start a discussion on GitHubhttpsgithub.comjlowinfastmcpdiscussions to share your project.  Contributing To get your project featured 1. Ensure your project demonstrates best practices 2. Include comprehensive documentation 3. Add clear usage examples 4. Open a discussion in our GitHub Discussionshttpsgithub.comjlowinfastmcpdiscussions We review submissions regularly and feature projects that provide value to the FastMCP community.  Further Reading  Contrib Modulesintegrationscontrib - Community-contributed modules that are distributed with FastMCP itself  Integrating FastMCP in ASGI Applications Source httpsgofastmcp.comdeploymentasgi Integrate FastMCP servers into existing Starlette, FastAPI, or other ASGI applications export const VersionBadge  version   return New in versionversion   While FastMCP provides standalone server capabilities, you can also integrate your FastMCP server into existing web applications. This approach is useful for  Adding MCP functionality to an existing website or API  Mounting MCP servers under specific URL paths  Combining multiple services in a single application  Leveraging existing authentication and middleware Please note that all FastMCP servers have a run method that can be used to start the server. This guide focuses on integration with broader ASGI frameworks.  ASGI Server FastMCP servers can be created as Starlettehttpswww.starlette.io ASGI apps for straightforward hosting or integration into existing applications. The first step is to obtain a Starlette application instance from your FastMCP server using the http_app method The http_app method is new in FastMCP 2.3.2. In older versions, use sse_app for SSE transport or streamable_http_app for Streamable HTTP transport. python from fastmcp import FastMCP mcp  FastMCPMyServer mcp.tool def helloname str - str return fHello, name!  Get a Starlette app instance for Streamable HTTP transport recommended http_app  mcp.http_app  For legacy SSE transport deprecated sse_app  mcp.http_apptransportsse  Both approaches return a Starlette application that can be integrated with other ASGI-compatible web frameworks. The returned app stores the FastMCP instance on app.state.fastmcp_server, so you can access it from custom middleware or routes via request.app.state.fastmcp_server. The MCP servers endpoint is mounted at the root path mcp for Streamable HTTP transport, and sse for SSE transport, though you can change these paths by passing a path argument to the http_app method python  For Streamable HTTP transport http_app  mcp.http_apppathcustom-mcp-path  For SSE transport deprecated sse_app  mcp.http_apppathcustom-sse-path, transportsse   Running the Server To run the FastMCP server, you can use the uvicorn ASGI server python from fastmcp import FastMCP import uvicorn mcp  FastMCPMyServer http_app  mcp.http_app if __name__  __main__ uvicorn.runhttp_app, host0.0.0.0, port8000  Or, from the command line bash uvicorn path.to.your.apphttp_app --host 0.0.0.0 --port 8000   Custom Middleware You can add custom Starlette middleware to your FastMCP ASGI apps by passing a list of middleware instances to the app creation methods python from fastmcp import FastMCP from starlette.middleware import Middleware from starlette.middleware.cors import CORSMiddleware  Create your FastMCP server mcp  FastMCPMyServer  Define custom middleware custom_middleware   Middleware CORSMiddleware, allow_originshttpsexample.com, httpsapp.example.com, allow_credentialsTrue, allow_methodsGET, POST, OPTIONS, allow_headersContent-Type, Authorization, ,   Create ASGI app with custom middleware http_app  mcp.http_appmiddlewarecustom_middleware   Starlette Integration You can mount your FastMCP server in another Starlette application python from fastmcp import FastMCP from starlette.applications import Starlette from starlette.routing import Mount  Create your FastMCP server as well as any tools, resources, etc. mcp  FastMCPMyServer  Create the ASGI app mcp_app  mcp.http_apppathmcp  Create a Starlette app and mount the MCP server app  Starlette routes Mountmcp-server, appmcp_app,  Add other routes as needed , lifespanmcp_app.lifespan,   The MCP endpoint will be available at mcp-servermcp of the resulting Starlette app. For Streamable HTTP transport, you must pass the lifespan context from the FastMCP app to the resulting Starlette app, as nested lifespans are not recognized. Otherwise, the FastMCP servers session manager will not be properly initialized.  Nested Mounts You can create complex routing structures by nesting mounts python from fastmcp import FastMCP from starlette.applications import Starlette from starlette.routing import Mount  Create your FastMCP server as well as any tools, resources, etc. mcp  FastMCPMyServer  Create the ASGI app mcp_app  mcp.http_apppathmcp  Create nested application structure inner_app  StarletteroutesMountinner, appmcp_app app  Starlette routesMountouter, appinner_app, lifespanmcp_app.lifespan,   In this setup, the MCP server is accessible at the outerinnermcp path of the resulting Starlette app. For Streamable HTTP transport, you must pass the lifespan context from the FastMCP app to the outer Starlette app, as nested lifespans are not recognized. Otherwise, the FastMCP servers session manager will not be properly initialized.  FastAPI Integration FastAPI is built on Starlette, so you can mount your FastMCP server in a similar way python from fastmcp import FastMCP from fastapi import FastAPI from starlette.routing import Mount  Create your FastMCP server as well as any tools, resources, etc. mcp  FastMCPMyServer  Create the ASGI app mcp_app  mcp.http_apppathmcp  Create a FastAPI app and mount the MCP server app  FastAPIlifespanmcp_app.lifespan app.mountmcp-server, mcp_app  The MCP endpoint will be available at mcp-servermcp of the resulting FastAPI app. For Streamable HTTP transport, you must pass the lifespan context from the FastMCP app to the resulting FastAPI app, as nested lifespans are not recognized. Otherwise, the FastMCP servers session manager will not be properly initialized.  Custom Routes In addition to adding your FastMCP server to an existing ASGI app, you can also add custom web routes to your FastMCP server, which will be exposed alongside the MCP endpoint. To do so, use the custom_route decorator. Note that this is less flexible than using a full ASGI framework, but can be useful for adding simple endpoints like health checks to your standalone server. python from fastmcp import FastMCP from starlette.requests import Request from starlette.responses import PlainTextResponse mcp  FastMCPMyServer mcp.custom_routehealth, methodsGET async def health_checkrequest Request - PlainTextResponse return PlainTextResponseOK  These routes will be included in the FastMCP app when mounted in your web application.  Running Your FastMCP Server Source httpsgofastmcp.comdeploymentrunning-server Learn how to run and deploy your FastMCP server using various transport protocols like STDIO, Streamable HTTP, and SSE. export const VersionBadge  version   return New in versionversion   FastMCP servers can be run in different ways depending on your applications needs, from local command-line tools to persistent web services. This guide covers the primary methods for running your server, focusing on the available transport protocols STDIO, Streamable HTTP, and SSE.  The run Method FastMCP servers can be run directly from Python by calling the run method on a FastMCP instance. For maximum compatibility, its best practice to place the run call within an if __name__  __main__ block. This ensures the server starts only when the script is executed directly, not when imported as a module. python 9-10 my_server.py from fastmcp import FastMCP mcp  FastMCPnameMyServer mcp.tool def helloname str - str return fHello, name! if __name__  __main__ mcp.run  You can now run this MCP server by executing python my_server.py. MCP servers can be run with a variety of different transport options, depending on your applications requirements. The run method can take a transport argument and other transport-specific keyword arguments to configure how the server operates.  The FastMCP CLI FastMCP also provides a command-line interface for running servers without modifying the source code. After installing FastMCP, you can run your server directly from the command line bash fastmcp run server.py  Important When using fastmcp run, it ignores the if __name__  __main__ block entirely. Instead, it looks for a FastMCP object named mcp, server, or app and calls its run method directly with the transport options you specify. This means you can use fastmcp run to override the transport specified in your code, which is particularly useful for testing or changing deployment methods without modifying the code. You can specify transport options and other configuration bash fastmcp run server.py --transport sse --port 9000  For development and testing, you can use the dev command to run your server with the MCP Inspector bash fastmcp dev server.py  See the CLI documentationpatternscli for detailed information about all available commands and options.  Passing Arguments to Servers When servers accept command line arguments using argparse, click, or other libraries, you can pass them after -- bash fastmcp run config_server.py -- --config config.json fastmcp run database_server.py -- --database-path tmpdb.sqlite --debug  This is useful for servers that need configuration files, database paths, API keys, or other runtime options.  Transport Options Below is a comparison of available transport options to help you choose the right one for your needs  Transport  Use Cases  Recommendation   -------------------  ------------------------------------------------------------------------------------  -------------------------------------------------------------   STDIO  Local tools, command-line scripts, and integrations with clients like Claude Desktop  Best for local tools and when clients manage server processes   Streamable HTTP  Web-based deployments, microservices, exposing MCP over a network  Recommended choice for web-based deployments   SSE  Existing web-based deployments that rely on SSE  Deprecated - prefer Streamable HTTP for new projects   STDIO The STDIO transport is the default and most widely compatible option for local MCP server execution. It is ideal for local tools, command-line integrations, and clients like Claude Desktop. However, it has the disadvantage of having to run the MCP code locally, which can introduce security concerns with third-party servers. STDIO is the default transport, so you dont need to specify it when calling run. However, you can specify it explicitly to make your intent clear python 6 from fastmcp import FastMCP mcp  FastMCP if __name__  __main__ mcp.runtransportstdio  When using Stdio transport, you will typically not run the server yourself as a separate process. Rather, your clients will spin up a new server process for each session. As such, no additional configuration is required.  Streamable HTTP Streamable HTTP is a modern, efficient transport for exposing your MCP server via HTTP. It is the recommended transport for web-based deployments. To run a server using Streamable HTTP, you can use the run method with the transport argument set to http. This will start a Uvicorn server on the default host 127.0.0.1, port 8000, and path mcp. python 6 server.py from fastmcp import FastMCP mcp  FastMCP if __name__  __main__ mcp.runtransporthttp  python 5 client.py import asyncio from fastmcp import Client async def example async with Clienthttp127.0.0.18000mcp as client await client.ping if __name__  __main__ asyncio.runexample  For backward compatibility, wherever http is accepted as a transport name, you can also pass streamable-http as a fully supported alias. This is particularly useful when upgrading from FastMCP 1.x in the official Python SDK and FastMCP  2.9, where streamable-http was the standard name. To customize the host, port, path, or log level, provide appropriate keyword arguments to the run method. python 8-11 server.py from fastmcp import FastMCP mcp  FastMCP if __name__  __main__ mcp.run transporthttp, host127.0.0.1, port4200, pathmy-custom-path, log_leveldebug,   python 5 client.py import asyncio from fastmcp import Client async def example async with Clienthttp127.0.0.14200my-custom-path as client await client.ping if __name__  __main__ asyncio.runexample   SSE The SSE transport is deprecated and may be removed in a future version. New applications should use Streamable HTTP transport instead. Server-Sent Events SSE is an HTTP-based protocol for server-to-client streaming. While FastMCP still supports SSE, it is deprecated and Streamable HTTP is preferred for new projects. To run a server using SSE, you can use the run method with the transport argument set to sse. This will start a Uvicorn server on the default host 127.0.0.1, port 8000, and with default SSE path sse and message path messages. python 6 server.py from fastmcp import FastMCP mcp  FastMCP if __name__  __main__ mcp.runtransportsse  python 3,7 client.py import asyncio from fastmcp import Client from fastmcp.client.transports import SSETransport async def example async with Client transportSSETransporthttp127.0.0.18000sse  as client await client.ping if __name__  __main__ asyncio.runexample  Notice that the client in the above example uses an explicit SSETransport to connect to the server. FastMCP will attempt to infer the appropriate transport from the provided configuration, but HTTP URLs are assumed to be Streamable HTTP as of FastMCP 2.3.0. To customize the host, port, or log level, provide appropriate keyword arguments to the run method. You can also adjust the SSE path which clients should connect to and the message POST endpoint which clients use to send subsequent messages. python 8-12 server.py from fastmcp import FastMCP mcp  FastMCP if __name__  __main__ mcp.run transportsse, host127.0.0.1, port4200, log_leveldebug, pathmy-custom-sse-path,   python 7 client.py import asyncio from fastmcp import Client from fastmcp.client.transports import SSETransport async def example async with Client transportSSETransporthttp127.0.0.14200my-custom-sse-path  as client await client.ping if __name__  __main__ asyncio.runexample   Async Usage FastMCP provides both synchronous and asynchronous APIs for running your server. The run method seen in previous examples is a synchronous method that internally uses anyio.run to run the asynchronous server. For applications that are already running in an async context, FastMCP provides the run_async method. python 10-12 from fastmcp import FastMCP import asyncio mcp  FastMCPnameMyServer mcp.tool def helloname str - str return fHello, name! async def main  Use run_async in async contexts await mcp.run_asynctransporthttp if __name__  __main__ asyncio.runmain  The run method cannot be called from inside an async function because it already creates its own async event loop internally. If you attempt to call run from inside an async function, youll get an error about the event loop already running. Always use run_async inside async functions and run in synchronous contexts. Both run and run_async accept the same transport arguments, so all the examples above apply to both methods.  Custom Routes You can also add custom web routes to your FastMCP server, which will be exposed alongside the MCP endpoint. To do so, use the custom_route decorator. Note that this is less flexible than using a full ASGI framework, but can be useful for adding simple endpoints like health checks to your standalone server. python from fastmcp import FastMCP from starlette.requests import Request from starlette.responses import PlainTextResponse mcp  FastMCPMyServer mcp.custom_routehealth, methodsGET async def health_checkrequest Request - PlainTextResponse return PlainTextResponseOK if __name__  __main__ mcp.run   Installation Source httpsgofastmcp.comgetting-startedinstallation  Install FastMCP We recommend using uvhttpsdocs.astral.shuvgetting-startedinstallation to install and manage FastMCP. If you plan to use FastMCP in your project, you can add it as a dependency with bash uv add fastmcp  Alternatively, you can install it directly with pip or uv pip bash uv uv pip install fastmcp  bash pip pip install fastmcp   Verify Installation To verify that FastMCP is installed correctly, you can run the following command bash fastmcp version  You should see output like the following bash  fastmcp version FastMCP version 0.4.2.dev41ga077727.d20250410 MCP version 1.6.0 Python version 3.12.2 Platform macOS-15.3.1-arm64-arm-64bit FastMCP root path Developerfastmcp   Upgrading from the Official MCP SDK Upgrading from the official MCP SDKs FastMCP 1.0 to FastMCP 2.0 is generally straightforward. The core server API is highly compatible, and in many cases, changing your import statement from from mcp.server.fastmcp import FastMCP to from fastmcp import FastMCP will be sufficient. python 5  Before  from mcp.server.fastmcp import FastMCP  After from fastmcp import FastMCP mcp  FastMCPMy MCP Server  Prior to fastmcp2.3.0 and mcp1.8.0, the 2.x API always mirrored the official 1.0 API. However, as the projects diverge, this can not be guaranteed. You may see deprecation warnings if you attempt to use 1.0 APIs in FastMCP 2.x. Please refer to this documentation for details on new capabilities.  Versioning and Breaking Changes While we make every effort not to introduce backwards-incompatible changes to our public APIs and behavior, FastMCP exists in a rapidly evolving MCP landscape. Were committed to bringing the most cutting-edge features to our users, which occasionally necessitates changes to existing functionality. As a practice, breaking changes will only occur on minor version changes e.g., 2.3.x to 2.4.0. A minor version change indicates either  A significant new feature set that warrants a new minor version  Introducing breaking changes that may affect behavior on upgrade For users concerned about stability in production environments, we recommend pinning FastMCP to a specific version in your dependencies. Whenever possible, FastMCP will issue deprecation warnings when users attempt to use APIs that are either deprecated or destined for future removal. These warnings will be maintained for at least 1 minor version release, and may be maintained longer. Note that the public API includes the public functionality of the FastMCP server, core FastMCP components like Tool, Prompt, Resource, and ResourceTemplate, and their respective public methods. It does not include private methods, utilities, or objects that are stored as private attributes, as we do not expect users to rely on those implementation details.  Installing for Development If you plan to contribute to FastMCP, you should begin by cloning the repository and using uv to install all dependencies development dependencies are installed automatically bash git clone httpsgithub.comjlowinfastmcp.git cd fastmcp uv sync  This will install all dependencies, including ones for development, and create a virtual environment, which you can activate and use as normal.  Unit Tests FastMCP has a comprehensive unit test suite, and all PRs must introduce and pass appropriate tests. To run the tests, use pytest bash pytest   Pre-Commit Hooks FastMCP uses pre-commit to manage code quality, including formatting, linting, and type-safety. All PRs must pass the pre-commit hooks, which are run as a part of the CI process. To install the pre-commit hooks, run bash uv run pre-commit install  Alternatively, to run pre-commit manually at any time, use bash pre-commit run --all-files   Quickstart Source httpsgofastmcp.comgetting-startedquickstart Welcome! This guide will help you quickly set up FastMCP and run your first MCP server. If you havent already installed FastMCP, follow the installation instructionsgetting-startedinstallation.  Creating a FastMCP Server A FastMCP server is a collection of tools, resources, and other MCP components. To create a server, start by instantiating the FastMCP class. Create a new file called my_server.py and add the following code python my_server.py from fastmcp import FastMCP mcp  FastMCPMy MCP Server  Thats it! Youve created a FastMCP server, albeit a very boring one. Lets add a tool to make it more interesting.  Adding a Tool To add a tool that returns a simple greeting, write a function and decorate it with mcp.tool to register it with the server python my_server.py 5-7 from fastmcp import FastMCP mcp  FastMCPMy MCP Server mcp.tool def greetname str - str return fHello, name!   Testing the Server To test the server, create a FastMCP client and point it at the server object. python my_server.py 1-2, 10-17 import asyncio from fastmcp import FastMCP, Client mcp  FastMCPMy MCP Server mcp.tool def greetname str - str return fHello, name! client  Clientmcp async def call_toolname str async with client result  await client.call_toolgreet, name name printresult asyncio.runcall_toolFord  There are a few things to note here  Clients are asynchronous, so we need to use asyncio.run to run the client.  We must enter a client context async with client before using the client. You can make multiple client calls within the same context.  Running the server In order to run the server with Python, we need to add a run statement to the __main__ block of the server file. python my_server.py 9-10 from fastmcp import FastMCP mcp  FastMCPMy MCP Server mcp.tool def greetname str - str return fHello, name! if __name__  __main__ mcp.run  This lets us run the server with python my_server.py, using the default stdio transport, which is the standard way to expose an MCP server to a client. Why do we need the if __name__  __main__ block? Within the FastMCP ecosystem, this line may be unnecessary. However, including it ensures that your FastMCP server runs for all users and clients in a consistent way and is therefore recommended as best practice.  Interacting with the Python server Now that the server can be executed with python my_server.py, we can interact with it like any other MCP server. In a new file, create a client and point it at the server file python my_client.py import asyncio from fastmcp import Client client  Clientmy_server.py async def call_toolname str async with client result  await client.call_toolgreet, name name printresult asyncio.runcall_toolFord   Using the FastMCP CLI To have FastMCP run the server for us, we can use the fastmcp run command. This will start the server and keep it running until it is stopped. By default, it will use the stdio transport, which is a simple text-based protocol for interacting with the server. bash fastmcp run my_server.pymcp  Note that FastMCP does not require the __main__ block in the server file, and will ignore it if it is present. Instead, it looks for the server object provided in the CLI command here, mcp. If no server object is provided, fastmcp run will automatically search for servers called mcp, app, or server in the file. We pointed our client at the server file, which is recognized as a Python MCP server and executed with python my_server.py by default. This executes the __main__ block of the server file. There are other ways to run the server, which are described in the server configurationserversfastmcprunning-the-server guide.  Welcome to FastMCP 2.0! Source httpsgofastmcp.comgetting-startedwelcome The fast, Pythonic way to build MCP servers and clients. The Model Context Protocolhttpsmodelcontextprotocol.io MCP is a new, standardized way to provide context and tools to your LLMs, and FastMCP makes building MCP servers and clients simple and intuitive. Create tools, expose resources, define prompts, and more with clean, Pythonic code python 1 from fastmcp import FastMCP mcp  FastMCPDemo  mcp.tool def adda int, b int - int Add two numbers return a  b if __name__  __main__ mcp.run   Beyond the Protocol FastMCP is the standard framework for working with the Model Context Protocol. FastMCP 1.0 was incorporated into the official MCP Python SDKhttpsgithub.commodelcontextprotocolpython-sdk in 2024. This is FastMCP 2.0, the actively maintained version that provides a complete toolkit for working with the MCP ecosystem. FastMCP 2.0 has a comprehensive set of features that go far beyond the core MCP specification, all in service of providing the simplest path to production. These include deployment, auth, clients, server proxying and composition, generating servers from REST APIs, dynamic tool rewriting, built-in testing tools, integrations, and more. Ready to upgrade or get started? Follow the installation instructionsgetting-startedinstallation, which include steps for upgrading from the official MCP SDK.  What is MCP? The Model Context Protocol lets you build servers that expose data and functionality to LLM applications in a secure, standardized way. It is often described as the USB-C port for AI, providing a uniform way to connect LLMs to resources they can use. It may be easier to think of it as an API, but specifically designed for LLM interactions. MCP servers can  Expose data through Resources think of these sort of like GET endpoints they are used to load information into the LLMs context  Provide functionality through Tools sort of like POST endpoints they are used to execute code or otherwise produce a side effect  Define interaction patterns through Prompts reusable templates for LLM interactions  And more! FastMCP provides a high-level, Pythonic interface for building, managing, and interacting with these servers.  Why FastMCP? The MCP protocol is powerful but implementing it involves a lot of boilerplate - server setup, protocol handlers, content types, error management. FastMCP handles all the complex protocol details and server management, so you can focus on building great tools. Its designed to be high-level and Pythonic in most cases, decorating a function is all you need. FastMCP 2.0 has evolved into a comprehensive platform that goes far beyond basic protocol implementation. While 1.0 provided server-building capabilities and is now part of the official MCP SDK, 2.0 offers a complete ecosystem including client libraries, authentication systems, deployment tools, integrations with major AI platforms, testing frameworks, and production-ready infrastructure patterns. FastMCP aims to be  Fast High-level interface means less code and faster development  Simple Build MCP servers with minimal boilerplate  Pythonic Feels natural to Python developers  Complete A comprehensive platform for all MCP use cases, from dev to prod FastMCP is made with  by Prefecthttpswww.prefect.io.  LLM-Friendly Docs This documentation is also available in llms.txt formathttpsllmstxt.org, which is a simple markdown standard that LLMs can consume easily. There are two ways to access the LLM-friendly documentation  llms.txthttpsgofastmcp.comllms.txt is essentially a sitemap, listing all the pages in the documentation.  llms-full.txthttpsgofastmcp.comllms-full.txt contains the entire documentation. Note this may exceed the context window of your LLM. In addition, any page can be accessed as markdown by appending .md to the URL. For example, this page would become httpsgofastmcp.comgetting-startedwelcome.md, which you can view heregetting-startedwelcome.md. Finally, you can copy the contents of any page as markdown by pressing CmdC or CtrlC on Windows on your keyboard.  Anthropic API  FastMCP Source httpsgofastmcp.comintegrationsanthropic Call FastMCP servers from the Anthropic API export const VersionBadge  version   return New in versionversion   Anthropics Messages APIhttpsdocs.anthropic.comenapimessages supports MCP servers as remote tool sources. This tutorial will show you how to create a FastMCP server and deploy it to a public URL, then how to call it from the Messages API. Currently, the MCP connector only accesses tools from MCP serversit queries the list_tools endpoint and exposes those functions to Claude. Other MCP features like resources and prompts are not currently supported. You can read more about the MCP connector in the Anthropic documentationhttpsdocs.anthropic.comendocsagents-and-toolsmcp-connector.  Create a Server First, create a FastMCP server with the tools you want to expose. For this example, well create a server with a single tool that rolls dice. python server.py import random from fastmcp import FastMCP mcp  FastMCPnameDice Roller mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ mcp.runtransporthttp, port8000   Deploy the Server Your server must be deployed to a public URL in order for Anthropic to access it. The MCP connector supports both SSE and Streamable HTTP transports. For development, you can use tools like ngrok to temporarily expose a locally-running server to the internet. Well do that for this example you may need to install ngrok and create a free account, but you can use any other method to deploy your server. Assuming you saved the above code as server.py, you can run the following two commands in two separate terminals to deploy your server and expose it to the internet bash FastMCP server python server.py  bash ngrok ngrok http 8000  This exposes your unauthenticated server to the internet. Only run this command in a safe environment if you understand the risks.  Call the Server To use the Messages API with MCP servers, youll need to install the Anthropic Python SDK not included with FastMCP bash pip install anthropic  Youll also need to authenticate with Anthropic. You can do this by setting the ANTHROPIC_API_KEY environment variable. Consult the Anthropic SDK documentation for more information. bash export ANTHROPIC_API_KEYyour-api-key  Here is an example of how to call your server from Python. Note that youll need to replace httpsyour-server-url.com with the actual URL of your server. In addition, we use mcp as the endpoint because we deployed a streamable-HTTP server with the default path you may need to use a different endpoint if you customized your servers deployment. At this time you must also include the extra_headers parameter with the anthropic-beta header. python 5, 13-22 import anthropic from rich import print  Your server URL replace with your actual URL url  httpsyour-server-url.com client  anthropic.Anthropic response  client.beta.messages.create modelclaude-sonnet-4-20250514, max_tokens1000, messagesrole user, content Roll a few dice!, mcp_servers  type url, url furlmcp, name dice-server,  , extra_headers anthropic-beta mcp-client-2025-04-04   printresponse.content  If you run this code, youll see something like the following output text Ill roll some dice for you! Let me use the dice rolling tool. I rolled 3 dice and got 4, 2, 6 The results were 4, 2, and 6. Would you like me to roll again or roll a different number of dice?   Authentication The MCP connector supports OAuth authentication through authorization tokens, which means you can secure your server while still allowing Anthropic to access it.  Server Authentication The simplest way to add authentication to the server is to use a bearer token scheme. For this example, well quickly generate our own tokens with FastMCPs RSAKeyPair utility, but this may not be appropriate for production use. For more details, see the complete server-side Bearer Authserversauthbearer documentation. Well start by creating an RSA key pair to sign and verify tokens. python from fastmcp.server.auth.providers.bearer import RSAKeyPair key_pair  RSAKeyPair.generate access_token  key_pair.create_tokenaudiencedice-server  FastMCPs RSAKeyPair utility is for development and testing only. Next, well create a BearerAuthProvider to authenticate the server. python from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider auth  BearerAuthProvider public_keykey_pair.public_key, audiencedice-server,  mcp  FastMCPnameDice Roller, authauth  Here is a complete example that you can copypaste. For simplicity and the purposes of this example only, it will print the token to the console. Do NOT do this in production! python server.py expandable from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider from fastmcp.server.auth.providers.bearer import RSAKeyPair import random key_pair  RSAKeyPair.generate access_token  key_pair.create_tokenaudiencedice-server auth  BearerAuthProvider public_keykey_pair.public_key, audiencedice-server,  mcp  FastMCPnameDice Roller, authauth mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ printfn---nn Dice Roller access tokennnaccess_tokennn---n mcp.runtransporthttp, port8000   Client Authentication If you try to call the authenticated server with the same Anthropic code we wrote earlier, youll get an error indicating that the server rejected the request because its not authenticated. python Error code 400 -  type error, error  type invalid_request_error, message MCP server dice-server requires authentication. Please provide an authorization_token., ,   To authenticate the client, you can pass the token using the authorization_token parameter in your MCP server configuration python 8, 21 import anthropic from rich import print  Your server URL replace with your actual URL url  httpsyour-server-url.com  Your access token replace with your actual token access_token  your-access-token client  anthropic.Anthropic response  client.beta.messages.create modelclaude-sonnet-4-20250514, max_tokens1000, messagesrole user, content Roll a few dice!, mcp_servers  type url, url furlmcp, name dice-server, authorization_token access_token  , extra_headers anthropic-beta mcp-client-2025-04-04   printresponse.content  You should now see the dice roll results in the output.  ChatGPT  FastMCP Source httpsgofastmcp.comintegrationschatgpt Connect FastMCP servers to ChatGPT Deep Research ChatGPT supports MCP servers through remote HTTP connections, allowing you to extend ChatGPTs capabilities with custom tools and knowledge from your FastMCP servers. MCP integration with ChatGPT is currently limited to Deep Research functionality and is not available for general chat. This feature is available for ChatGPT Pro, Team, Enterprise, and Edu users. OpenAIs official MCP documentation and examples are built with FastMCP v2! Check out their sample MCP serverhttpsgithub.comopenaimcp-server-sample which demonstrates FastMCP in action.  Deep Research ChatGPTs Deep Research feature requires MCP servers to be internet-accessible HTTP endpoints with exactly two specific tools  search For searching through your resources and returning matching IDs  fetch For retrieving the full content of specific resources by ID If your server doesnt implement both search and fetch tools with the correct signatures, ChatGPT will show the error This MCP server doesnt implement our specification. Both tools are required.  Tool Descriptions Matter Since ChatGPT needs to understand how to use your tools effectively, write detailed tool descriptions. The description teaches ChatGPT how to form queries, what parameters to use, and what to expect from your data. Poor descriptions lead to poor search results.  Create a Server A Deep Research-compatible server must implement these two required tools  searchquery str - Takes a query of any kind and returns matching record IDs  fetchid str - Takes an ID and returns the record Critical Write detailed docstrings for both tools. These descriptions teach ChatGPT how to use your tools effectively. Poor descriptions lead to poor search results. The search tool should take a query of any kind! and return IDs. The fetch tool should take an ID and return the record. Heres a reference server implementation you can adapt see also OpenAIs sample serverhttpsgithub.comopenaimcp-server-sample for comparison python server.py expandable import json from pathlib import Path from dataclasses import dataclass from fastmcp import FastMCP dataclass class Record id str title str text str metadata dict def create_server records_path Path  str, name str  None  None, instructions str  None  None,  - FastMCP Create a FastMCP server that can search and fetch records from a JSON file. records  json.loadsPathrecords_path.read_text RECORDS  Recordr for r in records LOOKUP  r.id r for r in RECORDS mcp  FastMCPnamename or Deep Research MCP, instructionsinstructions mcp.tool async def searchquery str  Simple unranked keyword search across title, text, and metadata. Searches for any of the query terms in the record content. Returns a list of matching record IDs for ChatGPT to fetch.  toks  query.lower.split ids   for r in RECORDS record_txt   .join r.title, r.text,  .joinr.metadata.values .lower if anyt in record_txt for t in toks ids.appendr.id return ids ids mcp.tool async def fetchid str  Fetch a record by ID. Returns the complete record data for ChatGPT to analyze and cite.  if id not in LOOKUP raise ValueErrorfUnknown record ID id return LOOKUPid return mcp if __name__  __main__ mcp  create_serverpathtorecords.json mcp.runtransporthttp, port8000   Deploy the Server Your server must be deployed to a public URL in order for ChatGPT to access it. For development, you can use tools like ngrok to temporarily expose a locally-running server to the internet. Well do that for this example you may need to install ngrok and create a free account, but you can use any other method to deploy your server. Assuming you saved the above code as server.py, you can run the following two commands in two separate terminals to deploy your server and expose it to the internet bash FastMCP server python server.py  bash ngrok ngrok http 8000  This exposes your unauthenticated server to the internet. Only run this command in a safe environment if you understand the risks.  Connect to ChatGPT Replace httpsyour-server-url.com with the actual URL of your server such as your ngrok URL. 1. Open ChatGPT and go to Settings  Connectors 2. Click Add custom connector 3. Enter your server details  Name Library Catalog  URL Your server URL e.g., httpsabc123.ngrok.io  Description A library catalog for searching and retrieving books  Test the Connection 1. Start a new chat in ChatGPT 2. Click Tools  Run deep research 3. Select your Library Catalog connector as a source 4. Ask questions like  Search for Python programming books  Find books about AI and machine learning  Show me books by the Python Software Foundation ChatGPT will use your servers search and fetch tools to find relevant information and cite the sources in its response.  Troubleshooting  This MCP server doesnt implement our specification If you get this error, it most likely means that your server doesnt implement the required tools search and fetch. To correct it, ensure that your server meets the service requirements.  Claude Code  FastMCP Source httpsgofastmcp.comintegrationsclaude-code Connect FastMCP servers to Claude Code Claude Code supports MCP servers through multiple transport methods, allowing you to extend Claudes capabilities with custom tools, resources, and prompts from your FastMCP servers. Claude Code supports both local and remote MCP servers with flexible configuration options. See the Claude Code MCP documentationhttpsdocs.anthropic.comendocsclaude-codemcp for other transport methods. Claude Code provides built-in MCP management commands to easily add, configure, and authenticate your FastMCP servers.  Create a Server You can create FastMCP servers using STDIO transport, remote HTTP servers, or local HTTP servers. This example shows one common approach running an HTTP server locally for development. python server.py import random from fastmcp import FastMCP mcp  FastMCPnameDice Roller mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ mcp.runtransporthttp, port8000   Connect to Claude Code Start your server and add it to Claude Code bash  Start your server first python server.py  Then add it to Claude Code bash claude mcp add dice --transport http httplocalhost8000mcp   Using Your Server Once connected, Claude Code will automatically discover and use your servers tools when relevant  Roll some dice for me  Claude will call your roll_dice tool and provide the results. If your server provides resources, you can reference them with  mentions like dicefilepathtoresource.  Claude Desktop  FastMCP Source httpsgofastmcp.comintegrationsclaude-desktop Call FastMCP servers from Claude Desktop Claude Desktop supports MCP servers through local STDIO connections and remote servers beta, allowing you to extend Claudes capabilities with custom tools, resources, and prompts from your FastMCP servers. Remote MCP server support is currently in beta and available for users on Claude Pro, Max, Team, and Enterprise plans as of June 2025. Most users will still need to use local STDIO connections. This guide focuses specifically on using FastMCP servers with Claude Desktop. For general Claude Desktop MCP setup and official examples, see the official Claude Desktop quickstart guidehttpsmodelcontextprotocol.ioquickstartuser.  Requirements Claude Desktop traditionally requires MCP servers to run locally using STDIO transport, where your server communicates with Claude through standard inputoutput rather than HTTP. However, users on certain plans now have access to remote server support as well. If you dont have access to remote server support or need to connect to remote servers, you can create a proxy server that runs locally via STDIO and forwards requests to remote HTTP servers. See the Proxy Serversproxy-servers section below.  Create a Server The examples in this guide will use the following simple dice-rolling server, saved as server.py. python server.py import random from fastmcp import FastMCP mcp  FastMCPnameDice Roller mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ mcp.run   Install the Server  FastMCP CLI The easiest way to install a FastMCP server in Claude Desktop is using the fastmcp install command. This automatically handles the configuration and dependency management. bash fastmcp install server.py  The install command supports the same file.pyobject notation as the run command. If no object is specified, it will automatically look for a FastMCP server object named mcp, server, or app in your file bash  These are equivalent if your server object is named mcp fastmcp install server.py fastmcp install server.pymcp  Use explicit object name if your server has a different name fastmcp install server.pymy_custom_server  After installation, restart Claude Desktop completely. You should see a hammer icon  in the bottom left of the input box, indicating that MCP tools are available.  Dependencies If your server has dependencies, include them with the --with flag bash fastmcp install server.py --with pandas --with requests  Alternatively, you can specify dependencies directly in your server code python server.py from fastmcp import FastMCP mcp  FastMCP nameDice Roller, dependenciespandas, requests    Environment Variables Claude Desktop runs servers in a completely isolated environment with no access to your shell environment or locally installed applications. You must explicitly pass any environment variables your server needs. If your server needs environment variables like API keys, you must include them bash fastmcp install server.py --name Weather Server  --env-var API_KEYyour-api-key  --env-var DEBUGtrue  Or load them from a .env file bash fastmcp install server.py --name Weather Server --env-file .env   uv must be installed and available in your system PATH. Claude Desktop runs in its own isolated environment and needs uv to manage dependencies.  On macOS, it is recommended to install uv globally with Homebrew so that Claude Desktop will detect it brew install uv. Installing uv with other methods may not make it accessible to Claude Desktop.  Manual Configuration For more control over the configuration, you can manually edit Claude Desktops configuration file. You can open the configuration file from Claudes developer settings, or find it in the following locations  macOS LibraryApplication SupportClaudeclaude_desktop_config.json  Windows APPDATAClaudeclaude_desktop_config.json The configuration file is a JSON object with a mcpServers key, which contains the configuration for each MCP server. json  mcpServers  dice-roller  command python, args pathtoyourserver.py     After updating the configuration file, restart Claude Desktop completely. Look for the hammer icon  to confirm your server is loaded.  Dependencies If your server has dependencies, you can use uv or another package manager to set up the environment. json  mcpServers  dice-roller  command uv, args  run, --with, pandas, --with, requests, python, pathtoyourserver.py       uv must be installed and available in your system PATH. Claude Desktop runs in its own isolated environment and needs uv to manage dependencies.  On macOS, it is recommended to install uv globally with Homebrew so that Claude Desktop will detect it brew install uv. Installing uv with other methods may not make it accessible to Claude Desktop.  Environment Variables You can also specify environment variables in the configuration json  mcpServers  weather-server  command python, args pathtoweather_server.py, env  API_KEY your-api-key, DEBUG true      Claude Desktop runs servers in a completely isolated environment with no access to your shell environment or locally installed applications. You must explicitly pass any environment variables your server needs.  Remote Servers Users on Claude Pro, Max, Team, and Enterprise plans have first-class remote server support via integrations. For other users, or as an alternative approach, FastMCP can create a proxy server that forwards requests to a remote HTTP server. You can install the proxy server in Claude Desktop. Create a proxy server that connects to a remote HTTP server python proxy_server.py from fastmcp import FastMCP  Create a proxy to a remote server proxy  FastMCP.as_proxy httpsexample.commcpsse, nameRemote Server Proxy  if __name__  __main__ proxy.run  Runs via STDIO for Claude Desktop   Authentication For authenticated remote servers, create an authenticated client following the guidance in the client auth documentationclientsauthbearer and pass it to the proxy python auth_proxy_server.py 7 from fastmcp import FastMCP, Client from fastmcp.client.auth import BearerAuth  Create authenticated client client  Client httpsapi.example.commcpsse, authBearerAuthtokenyour-access-token   Create proxy using the authenticated client proxy  FastMCP.as_proxyclient, nameAuthenticated Proxy if __name__  __main__ proxy.run   Contrib Modules Source httpsgofastmcp.comintegrationscontrib Community-contributed modules extending FastMCP export const VersionBadge  version   return New in versionversion   FastMCP includes a contrib package that holds community-contributed modules. These modules extend FastMCPs functionality but arent officially maintained by the core team. Contrib modules provide additional features, integrations, or patterns that complement the core FastMCP library. They offer a way for the community to share useful extensions while keeping the core library focused and maintainable. The available modules can be viewed in the contrib directoryhttpsgithub.comjlowinfastmcptreemainsrcfastmcpcontrib.  Usage To use a contrib module, import it from the fastmcp.contrib package python from fastmcp.contrib import my_module   Important Considerations  Stability Modules in contrib may have different testing requirements or stability guarantees compared to the core library.  Compatibility Changes to core FastMCP might break modules in contrib without explicit warnings in the main changelog.  Dependencies Contrib modules may have additional dependencies not required by the core library. These dependencies are typically documented in the modules README or separate requirements files.  Contributing We welcome contributions to the contrib package! If you have a module that extends FastMCP in a useful way, consider contributing it 1. Create a new directory in srcfastmcpcontrib for your module 2. Add proper tests for your module in testscontrib 3. Include comprehensive documentation in a README.md file, including usage and examples, as well as any additional dependencies or installation instructions 4. Submit a pull request The ideal contrib module  Solves a specific use case or integration need  Follows FastMCP coding standards  Includes thorough documentation and examples  Has comprehensive tests  Specifies any additional dependencies  Gemini SDK  FastMCP Source httpsgofastmcp.comintegrationsgemini Call FastMCP servers from the Google Gemini SDK export const VersionBadge  version   return New in versionversion   Googles Gemini API includes built-in support for MCP servers in their Python and JavaScript SDKs, allowing you to connect directly to MCP servers and use their tools seamlessly with Gemini models.  Gemini Python SDK Googles Gemini Python SDKhttpsai.google.devgemini-apidocs can use FastMCP clients directly. Googles MCP integration is currently experimental and available in the Python and JavaScript SDKs. The API automatically calls MCP tools when needed and can connect to both local and remote MCP servers. Currently, Geminis MCP support only accesses tools from MCP serversit queries the list_tools endpoint and exposes those functions to the AI. Other MCP features like resources and prompts are not currently supported.  Create a Server First, create a FastMCP server with the tools you want to expose. For this example, well create a server with a single tool that rolls dice. python server.py import random from fastmcp import FastMCP mcp  FastMCPnameDice Roller mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ mcp.run   Call the Server To use the Gemini API with MCP, youll need to install the Google Generative AI SDK bash pip install google-genai  Youll also need to authenticate with Google. You can do this by setting the GEMINI_API_KEY environment variable. Consult the Gemini SDK documentation for more information. bash export GEMINI_API_KEYyour-api-key  Geminis SDK interacts directly with the MCP client session. To call the server, youll need to instantiate a FastMCP client, enter its connection context, and pass the client session to the Gemini SDK. python 5, 9, 15 from fastmcp import Client from google import genai import asyncio mcp_client  Clientserver.py gemini_client  genai.Client async def main async with mcp_client response  await gemini_client.aio.models.generate_content modelgemini-2.0-flash, contentsRoll 3 dice!, configgenai.types.GenerateContentConfig temperature0, toolsmcp_client.session,  Pass the FastMCP client session ,  printresponse.text if __name__  __main__ asyncio.runmain  If you run this code, youll see output like text Okay, I rolled 3 dice and got a 5, 4, and 1.   Remote  Authenticated Servers In the above example, we connected to our local server using stdio transport. Because were using a FastMCP client, you can also connect to any local or remote MCP server, using any transportclientstransports or authclientsauth method supported by FastMCP, simply by changing the client configuration. For example, to connect to a remote, authenticated server, you can use the following client python from fastmcp import Client from fastmcp.client.auth import BearerAuth mcp_client  Client httpsmy-server.commcp, authBearerAuth,   The rest of the code remains the same.  OpenAI API  FastMCP Source httpsgofastmcp.comintegrationsopenai Call FastMCP servers from the OpenAI API export const VersionBadge  version   return New in versionversion    Responses API OpenAIs Responses APIhttpsplatform.openai.comdocsapi-referenceresponses supports MCP servershttpsplatform.openai.comdocsguidestools-remote-mcp as remote tool sources, allowing you to extend AI capabilities with custom functions. The Responses API is a distinct API from OpenAIs Completions API or Assistants API. At this time, only the Responses API supports MCP. Currently, the Responses API only accesses tools from MCP serversit queries the list_tools endpoint and exposes those functions to the AI agent. Other MCP features like resources and prompts are not currently supported.  Create a Server First, create a FastMCP server with the tools you want to expose. For this example, well create a server with a single tool that rolls dice. python server.py import random from fastmcp import FastMCP mcp  FastMCPnameDice Roller mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ mcp.runtransporthttp, port8000   Deploy the Server Your server must be deployed to a public URL in order for OpenAI to access it. For development, you can use tools like ngrok to temporarily expose a locally-running server to the internet. Well do that for this example you may need to install ngrok and create a free account, but you can use any other method to deploy your server. Assuming you saved the above code as server.py, you can run the following two commands in two separate terminals to deploy your server and expose it to the internet bash FastMCP server python server.py  bash ngrok ngrok http 8000  This exposes your unauthenticated server to the internet. Only run this command in a safe environment if you understand the risks.  Call the Server To use the Responses API, youll need to install the OpenAI Python SDK not included with FastMCP bash pip install openai  Youll also need to authenticate with OpenAI. You can do this by setting the OPENAI_API_KEY environment variable. Consult the OpenAI SDK documentation for more information. bash export OPENAI_API_KEYyour-api-key  Here is an example of how to call your server from Python. Note that youll need to replace httpsyour-server-url.com with the actual URL of your server. In addition, we use mcp as the endpoint because we deployed a streamable-HTTP server with the default path you may need to use a different endpoint if you customized your servers deployment. python 4, 11-16 from openai import OpenAI  Your server URL replace with your actual URL url  httpsyour-server-url.com client  OpenAI resp  client.responses.create modelgpt-4.1, tools  type mcp, server_label dice_server, server_url furlmcp, require_approval never, , , inputRoll a few dice!,  printresp.output_text  If you run this code, youll see something like the following output text You rolled 3 dice and got the following results 6, 4, and 2!   Authentication The Responses API can include headers to authenticate the request, which means you dont have to worry about your server being publicly accessible.  Server Authentication The simplest way to add authentication to the server is to use a bearer token scheme. For this example, well quickly generate our own tokens with FastMCPs RSAKeyPair utility, but this may not be appropriate for production use. For more details, see the complete server-side Bearer Authserversauthbearer documentation. Well start by creating an RSA key pair to sign and verify tokens. python from fastmcp.server.auth.providers.bearer import RSAKeyPair key_pair  RSAKeyPair.generate access_token  key_pair.create_tokenaudiencedice-server  FastMCPs RSAKeyPair utility is for development and testing only. Next, well create a BearerAuthProvider to authenticate the server. python from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider auth  BearerAuthProvider public_keykey_pair.public_key, audiencedice-server,  mcp  FastMCPnameDice Roller, authauth  Here is a complete example that you can copypaste. For simplicity and the purposes of this example only, it will print the token to the console. Do NOT do this in production! python server.py expandable from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider from fastmcp.server.auth.providers.bearer import RSAKeyPair import random key_pair  RSAKeyPair.generate access_token  key_pair.create_tokenaudiencedice-server auth  BearerAuthProvider public_keykey_pair.public_key, audiencedice-server,  mcp  FastMCPnameDice Roller, authauth mcp.tool def roll_dicen_dice int - listint Roll n_dice 6-sided dice and return the results. return random.randint1, 6 for _ in rangen_dice if __name__  __main__ printfn---nn Dice Roller access tokennnaccess_tokennn---n mcp.runtransporthttp, port8000   Client Authentication If you try to call the authenticated server with the same OpenAI code we wrote earlier, youll get an error like this python pythonAPIStatusError Error code 424 -  error  message Error retrieving tool list from MCP server dice_server. Http status code 401 Unauthorized, type external_connector_error, param tools, code http_error    As expected, the server is rejecting the request because its not authenticated. To authenticate the client, you can pass the token in the Authorization header with the Bearer scheme python 4, 7, 19-21 expandable from openai import OpenAI  Your server URL replace with your actual URL url  httpsyour-server-url.com  Your access token replace with your actual token access_token  your-access-token client  OpenAI resp  client.responses.create modelgpt-4.1, tools  type mcp, server_label dice_server, server_url furlmcp, require_approval never, headers  Authorization fBearer access_token  , , inputRoll a few dice!,  printresp.output_text  You should now see the dice roll results in the output.  FastMCP CLI Source httpsgofastmcp.compatternscli Learn how to use the FastMCP command-line interface export const VersionBadge  version   return New in versionversion   FastMCP provides a command-line interface CLI that makes it easy to run, develop, and install your MCP servers. The CLI is automatically installed when you install FastMCP. bash fastmcp --help   Commands Overview  Command  Purpose  Dependency Management   ---------  -----------------------------------------------  -----------------------------------------------------------------------------------------------------------------   run  Run a FastMCP server directly  Uses your current environment you are responsible for ensuring all dependencies are available   dev  Run a server with the MCP Inspector for testing  Creates an isolated environment dependencies must be explicitly specified with --with andor --with-editable   install  Install a server in the Claude desktop app  Creates an isolated environment dependencies must be explicitly specified with --with andor --with-editable   inspect  Generate a JSON report about a FastMCP server  Uses your current environment you are responsible for ensuring all dependencies are available   version  Display version information  NA   Command Details  run Run a FastMCP server directly or proxy a remote server. bash fastmcp run server.py  This command runs the server directly in your current Python environment. You are responsible for ensuring all dependencies are available.  Options  Option  Flag  Description   ---------  -------------------  --------------------------------------------------------------   Transport  --transport, -t  Transport protocol to use stdio, http, or sse   Host  --host  Host to bind to when using http transport default 127.0.0.1   Port  --port, -p  Port to bind to when using http transport default 8000   Log Level  --log-level, -l  Log level DEBUG, INFO, WARNING, ERROR, CRITICAL   Server Specification The server can be specified in three ways 1. server.py - imports the module and looks for a FastMCP object named mcp, server, or app. Errors if no such object is found. 2. server.pycustom_name - imports and uses the specified server object 3. httpserver-urlpath or httpsserver-urlpath - connects to a remote server and creates a proxy When using fastmcp run with a local file, it ignores the if __name__  __main__ block entirely. Instead, it finds your server object and calls its run method directly with the transport options you specify. This means you can use fastmcp run to override the transport specified in your code. For example, if your code contains python  server.py from fastmcp import FastMCP mcp  FastMCPMyServer mcp.tool def helloname str - str return fHello, name! if __name__  __main__  This is ignored when using fastmcp run! mcp.runtransportstdio  You can run it with Streamable HTTP transport regardless of whats in the __main__ block bash fastmcp run server.py --transport http --port 8000  Examples bash  Run a local server with Streamable HTTP transport on a custom port fastmcp run server.py --transport http --port 8000  Connect to a remote server and proxy as a stdio server fastmcp run httpsexample.commcp-server  Connect to a remote server with specified log level fastmcp run httpsexample.commcp-server --log-level DEBUG   dev Run a MCP server with the MCP Inspectorhttpsgithub.commodelcontextprotocolinspector for testing. bash fastmcp dev server.py  This command runs your server in an isolated environment. All dependencies must be explicitly specified using the --with andor --with-editable options. The dev command is a shortcut for testing a server over STDIO only. When the Inspector launches, you may need to 1. Select STDIO from the transport dropdown 2. Connect manually This command does not support HTTP testing. To test a server over Streamable HTTP or SSE 1. Start your server manually with the appropriate transport using either the command line bash fastmcp run server.py --transport http  or by setting the transport in your code bash python server.py  Assuming your __main__ block sets Streamable HTTP transport  2. Open the MCP Inspector separately and connect to your running server  Options  Option  Flag  Description   -------------------  -----------------------  ---------------------------------------------------------------   Editable Package  --with-editable, -e  Directory containing pyproject.toml to install in editable mode   Additional Packages  --with  Additional packages to install can be used multiple times   Inspector Version  --inspector-version  Version of the MCP Inspector to use   UI Port  --ui-port  Port for the MCP Inspector UI   Server Port  --server-port  Port for the MCP Inspector Proxy server  Example bash  Run dev server with editable mode and additional packages fastmcp dev server.py -e . --with pandas --with matplotlib   install Install a MCP server in the Claude desktop app. bash fastmcp install server.py  Note that for security reasons, Claude runs every MCP server in a completely isolated environment. Therefore, all dependencies must be explicitly specified using the --with andor --with-editable options following uv conventions or by attaching them to your server in code via the dependencies parameter.  uv must be installed and available in your system PATH. Claude Desktop runs in its own isolated environment and needs uv to manage dependencies.  On macOS, it is recommended to install uv globally with Homebrew so that Claude Desktop will detect it brew install uv. Installing uv with other methods may not make it accessible to Claude Desktop. The install command currently only sets up servers for STDIO transport. When installed in the Claude desktop app, your server will be run using STDIO regardless of any transport configuration in your code.  Server Specification The install command supports the same file.pyobject notation as the run command 1. server.py - imports the module and looks for a FastMCP object named mcp, server, or app. Errors if no such object is found. 2. server.pycustom_name - imports and uses the specified server object Examples bash  Auto-detects server object looks for mcp, server, or app fastmcp install server.py  Uses specific server object fastmcp install server.pymy_server  With custom name and dependencies fastmcp install server.pymy_server -n My Analysis Server --with pandas   inspect Generate a detailed JSON report about a FastMCP server, including information about its tools, prompts, resources, and capabilities. bash fastmcp inspect server.py  The command supports the same server specification format as run and install bash  Auto-detect server object fastmcp inspect server.py  Specify server object fastmcp inspect server.pymy_server  Custom output location fastmcp inspect server.py --output analysis.json   version Display version information about FastMCP and related components. bash fastmcp version   Decorating Methods Source httpsgofastmcp.compatternsdecorating-methods Properly use instance methods, class methods, and static methods with FastMCP decorators. FastMCPs decorator system is designed to work with functions, but you may see unexpected behavior if you try to decorate an instance or class method. This guide explains the correct approach for using methods with all FastMCP decorators tool, resource, and .prompt.  Why Are Methods Hard? When you apply a FastMCP decorator like tool, resource, or prompt to a method, the decorator captures the function at decoration time. For instance methods and class methods, this poses a challenge because 1. For instance methods The decorator gets the unbound method before any instance exists 2. For class methods The decorator gets the function before its bound to the class This means directly decorating these methods doesnt work as expected. In practice, the LLM would see parameters like self or cls that it cannot provide values for. Additionally, FastMCP decorators return objects Tool, Resource, or Prompt instances rather than the original function. This means that when you decorate a method directly, the method becomes the returned object and is no longer callable by your code Dont do this! The method will no longer be callable from Python, and the tool wont be callable by LLMs. python from fastmcp import FastMCP mcp  FastMCP class MyClass mcp.tool def my_methodself, x int - int return x  2 obj  MyClass obj.my_method5  Fails - my_method is a Tool, not a function  This is another important reason to register methods functionally after defining the class.  Recommended Patterns  Instance Methods Dont do this! python from fastmcp import FastMCP mcp  FastMCP class MyClass mcp.tool  This wont work correctly def addself, x, y return x  y  When the decorator is applied this way, it captures the unbound method. When the LLM later tries to use this component, it will see self as a required parameter, but it wont know what to provide for it, causing errors or unexpected behavior. Do this instead python from fastmcp import FastMCP mcp  FastMCP class MyClass def addself, x, y return x  y  Create an instance first, then register the bound methods obj  MyClass mcp.toolobj.add  Now you can call it without self showing up as a parameter await mcp._mcp_call_tooladd, x 1, y 2  Returns 3  This approach works because 1. You first create an instance of the class obj 2. When you access the method through the instance obj.add, Python creates a bound method where self is already set to that instance 3. When you register this bound method, the system sees a callable that only expects the appropriate parameters, not self  Class Methods The behavior of decorating class methods depends on the order of decorators Dont do this decorator order matters python from fastmcp import FastMCP mcp  FastMCP class MyClass classmethod mcp.tool  This wont work but wont raise an error def from_string_v1cls, s return clss mcp.tool classmethod  This will raise a helpful ValueError def from_string_v2cls, s return clss   If classmethod comes first, then mcp.tool No error is raised, but it wont work correctly  If mcp.tool comes first, then classmethod FastMCP will detect this and raise a helpful ValueError with guidance Do this instead python from fastmcp import FastMCP mcp  FastMCP class MyClass classmethod def from_stringcls, s return clss  Register the class method after the class is defined mcp.toolMyClass.from_string  This works because 1. The classmethod decorator is applied properly during class definition 2. When you access MyClass.from_string, Python provides a special method object that automatically binds the class to the cls parameter 3. When registered, only the appropriate parameters are exposed to the LLM, hiding the implementation detail of the cls parameter  Static Methods Static methods work with FastMCP decorators, but this is not recommended because the FastMCP decorator will not return a callable method. Therefore, you should register static methods the same way as other methods. This is not recommended, though it will work. python from fastmcp import FastMCP mcp  FastMCP class MyClass mcp.tool staticmethod def utilityx, y return x  y  This works because staticmethod converts the method to a regular function, which the FastMCP decorator can then properly process. However, this is not recommended because the FastMCP decorator will not return a callable staticmethod. Therefore, you should register static methods the same way as other methods. Prefer this pattern python from fastmcp import FastMCP mcp  FastMCP class MyClass staticmethod def utilityx, y return x  y  This also works mcp.toolMyClass.utility   Additional Patterns  Creating Components at Class Initialization You can automatically register instance methods when creating an object python from fastmcp import FastMCP mcp  FastMCP class ComponentProvider def __init__self, mcp_instance  Register methods mcp_instance.toolself.tool_method mcp_instance.resourceresourcedataself.resource_method def tool_methodself, x return x  2 def resource_methodself return Resource data  The methods are automatically registered when creating the instance provider  ComponentProvidermcp  This pattern is useful when  You want to encapsulate registration logic within the class itself  You have multiple related components that should be registered together  You want to ensure that methods are always properly registered when creating an instance The class automatically registers its methods during initialization, ensuring theyre properly bound to the instance before registration.  Summary The current behavior of FastMCP decorators with methods is  Static methods Can be decorated directly and work perfectly with all FastMCP decorators  Class methods Cannot be decorated directly and will raise a helpful ValueError with guidance  Instance methods Should be registered after creating an instance using the decorator calls For class and instance methods, you should register them after creating the instance or class to ensure proper method binding. This ensures that the methods are properly bound before being registered. Understanding these patterns allows you to effectively organize your components into classes while maintaining proper method binding, giving you the benefits of object-oriented design without sacrificing the simplicity of FastMCPs decorator system.  HTTP Requests Source httpsgofastmcp.compatternshttp-requests Accessing and using HTTP requests in FastMCP servers export const VersionBadge  version   return New in versionversion    Overview When running FastMCP as a web server, your MCP tools, resources, and prompts might need to access the underlying HTTP request information, such as headers, client IP, or query parameters. FastMCP provides a clean way to access HTTP request information through a dependency function.  Accessing HTTP Requests The recommended way to access the current HTTP request is through the get_http_request dependency function python 2, 3, 11 from fastmcp import FastMCP from fastmcp.server.dependencies import get_http_request from starlette.requests import Request mcp  FastMCPnameHTTP Request Demo mcp.tool async def user_agent_info - dict Return information about the user agent.  Get the HTTP request request Request  get_http_request  Access request data user_agent  request.headers.getuser-agent, Unknown client_ip  request.client.host if request.client else Unknown return  user_agent user_agent, client_ip client_ip, path request.url.path,   This approach works anywhere within a requests execution flow, not just within your MCP function. Its useful when 1. You need access to HTTP information in helper functions 2. Youre calling nested functions that need HTTP request data 3. Youre working with middleware or other request processing code  Accessing HTTP Headers Only If you only need request headers and want to avoid potential errors, you can use the get_http_headers helper python 2 from fastmcp import FastMCP from fastmcp.server.dependencies import get_http_headers mcp  FastMCPnameHeaders Demo mcp.tool async def safe_header_info - dict Safely get header information without raising errors.  Get headers returns empty dict if no request context headers  get_http_headers  Get authorization header auth_header  headers.getauthorization,  is_bearer  auth_header.startswithBearer  return  user_agent headers.getuser-agent, Unknown, content_type headers.getcontent-type, Unknown, has_auth boolauth_header, auth_type Bearer if is_bearer else Other if auth_header else None, headers_count lenheaders   By default, get_http_headers excludes problematic headers like host and content-length. To include all headers, use get_http_headersinclude_allTrue.  Important Notes  HTTP requests are only available when FastMCP is running as part of a web application  Accessing the HTTP request with get_http_request outside of a web request context will raise a RuntimeError  The get_http_headers function never raises errors - it returns an empty dict when no request context is available  The get_http_request function returns a standard Starlette Requesthttpswww.starlette.iorequests object  Testing MCP Servers Source httpsgofastmcp.compatternstesting Learn how to test your FastMCP servers effectively Testing your MCP servers thoroughly is essential for ensuring they work correctly when deployed. FastMCP makes this easy through a variety of testing patterns.  In-Memory Testing The most efficient way to test an MCP server is to pass your FastMCP server instance directly to a Client. This enables in-memory testing without having to start a separate server process, which is particularly useful because managing an MCP server programmatically can be challenging. Here is an example of using a Client to test a server with pytest python import pytest from fastmcp import FastMCP, Client pytest.fixture def mcp_server server  FastMCPTestServer server.tool def greetname str - str return fHello, name! return server async def test_tool_functionalitymcp_server  Pass the server directly to the Client constructor async with Clientmcp_server as client result  await client.call_toolgreet, name World assert result0.text  Hello, World!  This pattern creates a direct connection between the client and server, allowing you to test your servers functionality efficiently.  Tool Transformation Source httpsgofastmcp.compatternstool-transformation Create enhanced tool variants with modified schemas, argument mappings, and custom behavior. export const VersionBadge  version   return New in versionversion   Tool transformation allows you to create new, enhanced tools from existing ones. This powerful feature enables you to adapt tools for different contexts, simplify complex interfaces, or add custom logic without duplicating code.  Why Transform Tools? Often, an existing tool is almost perfect for your use case, but it might have  A confusing description or no description at all.  Argument names or descriptions that are not intuitive for an LLM e.g., q instead of query.  Unnecessary parameters that you want to hide from the LLM.  A need for input validation before the original tool is called.  A need to modify or format the tools output. Instead of rewriting the tool from scratch, you can transform it to fit your needs.  Basic Transformation The primary way to create a transformed tool is with the Tool.from_tool class method. At its simplest, you can use it to change a tools top-level metadata like its name, description, or tags. In the following simple example, we take a generic search tool and adjust its name and description to help an LLM client better understand its purpose. python 13-21 from fastmcp import FastMCP from fastmcp.tools import Tool mcp  FastMCP  The original, generic tool mcp.tool def searchquery str, category str  all - listdict Searches for items in the database. return database.searchquery, category  Create a more domain-specific version by changing its metadata product_search_tool  Tool.from_tool search, namefind_products, description Search for products in the e-commerce catalog. Use this when customers ask about finding specific items, checking availability, or browsing product categories. ,  mcp.add_toolproduct_search_tool  When you transform a tool, the original tool remains registered on the server. To avoid confusing an LLM with two similar tools, you can disable the original one python from fastmcp import FastMCP from fastmcp.tools import Tool mcp  FastMCP  The original, generic tool mcp.tool def searchquery str, category str  all - listdict ...  Create a more domain-specific version product_search_tool  Tool.from_toolsearch, ... mcp.add_toolproduct_search_tool  Disable the original tool search.disable  Now, clients see a tool named find_products with a clear, domain-specific purpose and relevant tags, even though it still uses the original generic search functions logic.  Parameters The Tool.from_tool class method is the primary way to create a transformed tool. It takes the following parameters  tool The tool to transform. This is the only required argument.  name An optional name for the new tool.  description An optional description for the new tool.  transform_args A dictionary of ArgTransform objects, one for each argument you want to modify.  transform_fn An optional function that will be called instead of the parent tools logic.  tags An optional set of tags for the new tool.  annotations An optional set of ToolAnnotations for the new tool.  serializer An optional function that will be called to serialize the result of the new tool. The result is a new TransformedTool object that wraps the parent tool and applies the transformations you specify. You can add this tool to your MCP server using its add_tool method.  Modifying Arguments To modify a tools parameters, provide a dictionary of ArgTransform objects to the transform_args parameter of Tool.from_tool. Each key is the name of the original argument you want to modify. You only need to provide a transform_args entry for arguments you want to modify. All other arguments will be passed through unchanged.  The ArgTransform Class To modify an argument, you need to create an ArgTransform object. This object has the following parameters  name The new name for the argument.  description The new description for the argument.  default The new default value for the argument.  default_factory A function that will be called to generate a default value for the argument. This is useful for arguments that need to be generated for each tool call, such as timestamps or unique IDs.  hide Whether to hide the argument from the LLM.  required Whether the argument is required, usually used to make an optional argument be required instead.  type The new type for the argument. Certain combinations of parameters are not allowed. For example, you can only use default_factory with hideTrue, because dynamic defaults cannot be represented in a JSON schema for the client. You can only set requiredTrue for arguments that do not declare a default value.  Descriptions By far the most common reason to transform a tool, after its own description, is to improve its argument descriptions. A good description is crucial for helping an LLM understand how to use a parameter correctly. This is especially important when wrapping tools from external APIs, whose argument descriptions may be missing or written for developers, not LLMs. In this example, we add a helpful description to the user_id argument python 16-19 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import ArgTransform mcp  FastMCP mcp.tool def find_useruser_id str Finds a user by their ID. ... new_tool  Tool.from_tool find_user, transform_args user_id ArgTransform description The unique identifier for the user,  usually in the format usr-xxxxxxxx.       Names At times, you may want to rename an argument to make it more intuitive for an LLM. For example, in the following example, we take a generic q argument and expand it to search_query python 15 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import ArgTransform mcp  FastMCP mcp.tool def searchq str Searches for items in the database. return database.searchq new_tool  Tool.from_tool search, transform_args q ArgTransformnamesearch_query     Default Values You can update the default value for any argument using the default parameter. Here, we change the default value of the y argument to 10 python15 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import ArgTransform mcp  FastMCP mcp.tool def addx int, y int - int Adds two numbers. return x  y new_tool  Tool.from_tool add, transform_args y ArgTransformdefault10    Default values are especially useful in combination with hidden arguments.  Hiding Arguments Sometimes a tool requires arguments that shouldnt be exposed to the LLM, such as API keys, configuration flags, or internal IDs. You can hide these parameters using hideTrue. Note that you can only hide arguments that have a default value or for which you provide a new default, because the LLM cant provide a value at call time. To pass a constant value to the parent tool, combine hideTrue with default. python 19-20 import os from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import ArgTransform mcp  FastMCP mcp.tool def send_emailto str, subject str, body str, api_key str Sends an email. ...  Create a simplified version that hides the API key new_tool  Tool.from_tool send_email, namesend_notification, transform_args api_key ArgTransform hideTrue, defaultos.environ.getEMAIL_API_KEY,     The LLM now only sees the to, subject, and body parameters. The api_key is supplied automatically from an environment variable. For values that must be generated for each tool call like timestamps or unique IDs, use default_factory, which is called with no arguments every time the tool is called. For example, python 3-4 transform_args   timestamp ArgTransform hideTrue, default_factorylambda datetime.now,    default_factory can only be used with hideTrue. This is because visible parameters need static defaults that can be represented in a JSON schema for the client.  Required Values In rare cases where you want to make an optional argument required, you can set requiredTrue. This has no effect if the argument was already required. python 3 transform_args   user_id ArgTransform requiredTrue,     Modifying Tool Behavior With great power comes great responsibility. Modifying tool behavior is a very advanced feature. In addition to changing a tools schema, advanced users can also modify its behavior. This is useful for adding validation logic, or for post-processing the tools output. The from_tool method takes a transform_fn parameter, which is an async function that replaces the parent tools logic and gives you complete control over the tools execution.  The Transform Function The transform_fn is an async function that completely replaces the parent tools logic. Critically, the transform functions arguments are used to determine the new tools final schema. Any arguments that are not already present in the parent tool schema OR the transform_args will be added to the new tools schema. Note that when transform_args and your function have the same argument name, the transform_args metadata will take precedence, if provided. python async def my_custom_logicuser_input str, max_length int  100 - str  Your custom logic here - this completely replaces the parent tool return fCustom result for user_inputmax_length Tool.from_tooltransform_fnmy_custom_logic  The name  docstring of the transform_fn are ignored. Only its arguments are used to determine the final schema.  Calling the Parent Tool Most of the time, you dont want to completely replace the parent tools behavior. Instead, you want to add validation, modify inputs, or post-process outputs while still leveraging the parent tools core functionality. For this, FastMCP provides the special forward and forward_raw functions. Both forward and forward_raw are async functions that let you call the parent tool from within your transform_fn  forward recommended Automatically handles argument mapping based on your ArgTransform configurations. Call it with the transformed argument names.  forward_raw Bypasses all transformation and calls the parent tool directly with its original argument names. This is rarely needed unless youre doing complex argument manipulation, perhaps without arg_transforms. The most common transformation pattern is to validate potentially renamed arguments before calling the parent tool. Heres an example that validates that x and y are positive before calling the parent tool In the simplest case, your parent tool and your transform function have the same arguments. You can call forward with the same argument names as the parent tool python 15 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import forward mcp  FastMCP mcp.tool def addx int, y int - int Adds two numbers. return x  y async def ensure_positivex int, y int - int if x  0 or y  0 raise ValueErrorx and y must be positive return await forwardxx, yy new_tool  Tool.from_tool add, transform_fnensure_positive,  mcp.add_toolnew_tool  When your transformed tool has different argument names than the parent tool, you can call forward with the renamed arguments and it will automatically map the arguments to the parent tools arguments python 15, 20-23 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import forward mcp  FastMCP mcp.tool def addx int, y int - int Adds two numbers. return x  y async def ensure_positivea int, b int - int if a  0 or b  0 raise ValueErrora and b must be positive return await forwardaa, bb new_tool  Tool.from_tool add, transform_fnensure_positive, transform_args x ArgTransformnamea, y ArgTransformnameb,   mcp.add_toolnew_tool  Finally, you can use forward_raw to bypass all argument mapping and call the parent tool directly with its original argument names. python 15, 20-23 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import forward mcp  FastMCP mcp.tool def addx int, y int - int Adds two numbers. return x  y async def ensure_positivea int, b int - int if a  0 or b  0 raise ValueErrora and b must be positive return await forward_rawxa, yb new_tool  Tool.from_tool add, transform_fnensure_positive, transform_args x ArgTransformnamea, y ArgTransformnameb,   mcp.add_toolnew_tool   Passing Arguments with kwargs If your transform_fn includes kwargs in its signature, it will receive all arguments from the parent tool after ArgTransform configurations have been applied. This is powerful for creating flexible validation functions that dont require you to add every argument to the function signature. In the following example, we wrap a parent tool that accepts two arguments x and y. These are renamed to a and b in the transformed tool, and the transform only validates a, passing the other argument through as kwargs. python 12, 15 from fastmcp import FastMCP from fastmcp.tools import Tool from fastmcp.tools.tool_transform import forward mcp  FastMCP mcp.tool def addx int, y int - int Adds two numbers. return x  y async def ensure_a_positivea int, kwargs - int if a  0 raise ValueErrora must be positive return await forwardaa, kwargs new_tool  Tool.from_tool add, transform_fnensure_a_positive, transform_args x ArgTransformnamea, y ArgTransformnameb,   mcp.add_toolnew_tool  In the above example, kwargs receives the renamed argument b, not the original argument y. It is therefore recommended to use with forward, not forward_raw.  Common Patterns Tool transformation is a flexible feature that supports many powerful patterns. Here are a few common use cases to give you ideas.  Adapting Remote or Generated Tools This is one of the most common reasons to use tool transformation. Tools from remote servers via a proxyserversproxy or generated from an OpenAPI specserversopenapi are often too generic for direct use by an LLM. You can use transformation to create a simpler, more intuitive version for your specific needs.  Chaining Transformations You can chain transformations by using an already transformed tool as the parent for a new transformation. This lets you build up complex behaviors in layers, for example, first renaming arguments, and then adding validation logic to the renamed tool.  Context-Aware Tool Factories You can write functions that act as factories, generating specialized versions of a tool for different contexts. For example, you could create a get_my_data tool that is specific to the currently logged-in user by hiding the user_id parameter and providing it automatically.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-cli-__init__  fastmcp.cli FastMCP CLI package.  claude Source httpsgofastmcp.compython-sdkfastmcp-cli-claude  fastmcp.cli.claude Claude app integration utilities.  Functions  get_claude_config_path python get_claude_config_path - Path  None  Get the Claude config directory based on platform.  update_claude_config python update_claude_configfile_spec str, server_name str - bool  Add or update a FastMCP server in Claudes configuration. Args  file_spec Path to the server file, optionally with object suffix  server_name Name for the server in Claudes config  with_editable Optional directory to install in editable mode  with_packages Optional list of additional packages to install  env_vars Optional dictionary of environment variables. These are merged with any existing variables, with new values taking precedence. Raises  RuntimeError If Claude Desktops config directory is not found, indicating Claude Desktop may not be installed or properly set up.  cli Source httpsgofastmcp.compython-sdkfastmcp-cli-cli  fastmcp.cli.cli FastMCP CLI tools.  Functions  version python versionctx Context   dev python devserver_spec str  typer.Argument..., helpPython file to run, optionally with object suffix, with_editable AnnotatedPath  None, typer.Option--with-editable, -e, helpDirectory containing pyproject.toml to install in editable mode, existsTrue, file_okayFalse, resolve_pathTrue  None, with_packages Annotatedliststr, typer.Option--with, helpAdditional packages to install  , inspector_version Annotatedstr  None, typer.Option--inspector-version, helpVersion of the MCP Inspector to use  None, ui_port Annotatedint  None, typer.Option--ui-port, helpPort for the MCP Inspector UI  None, server_port Annotatedint  None, typer.Option--server-port, helpPort for the MCP Inspector Proxy server  None - None  Run a MCP server with the MCP Inspector.  run python runctx typer.Context, server_spec str  typer.Argument..., helpPython file, object specification fileobj, or URL, transport Annotatedstr  None, typer.Option--transport, -t, helpTransport protocol to use stdio, http, or sse  None, host Annotatedstr  None, typer.Option--host, helpHost to bind to when using http transport default 127.0.0.1  None, port Annotatedint  None, typer.Option--port, -p, helpPort to bind to when using http transport default 8000  None, log_level Annotatedstr  None, typer.Option--log-level, -l, helpLog level DEBUG, INFO, WARNING, ERROR, CRITICAL  None - None  Run a MCP server or connect to a remote one. The server can be specified in three ways 1. Module approach server.py - runs the module directly, looking for an object named mcpserverapp. 2. Import approach server.pyapp - imports and runs the specified server object. 3. URL approach httpserver-urlhttpserver-url - connects to a remote server and creates a proxy. Note This command runs the server directly. You are responsible for ensuring all dependencies are available. Server arguments can be passed after --  fastmcp run server.py -- --config config.json --debug  install python installserver_spec str  typer.Argument..., helpPython file to run, optionally with object suffix, server_name Annotatedstr  None, typer.Option--name, -n, helpCustom name for the server defaults to servers name attribute or file name  None, with_editable AnnotatedPath  None, typer.Option--with-editable, -e, helpDirectory containing pyproject.toml to install in editable mode, existsTrue, file_okayFalse, resolve_pathTrue  None, with_packages Annotatedliststr, typer.Option--with, helpAdditional packages to install  , env_vars Annotatedliststr, typer.Option--env-var, -v, helpEnvironment variables in KEYVALUE format  , env_file AnnotatedPath  None, typer.Option--env-file, -f, helpLoad environment variables from a .env file, existsTrue, file_okayTrue, dir_okayFalse, resolve_pathTrue  None - None  Install a MCP server in the Claude desktop app. Environment variables are preserved once added and only updated if new values are explicitly provided.  inspect python inspectserver_spec str  typer.Argument..., helpPython file to inspect, optionally with object suffix, output AnnotatedPath, typer.Option--output, -o, helpOutput file path for the JSON report default server-info.json  Pathserver-info.json - None  Inspect a FastMCP server and generate a JSON report. This command analyzes a FastMCP server v1.x or v2.x and generates a comprehensive JSON report containing information about the servers name, instructions, version, tools, prompts, resources, templates, and capabilities. Examples fastmcp inspect server.py fastmcp inspect server.py -o report.json fastmcp inspect server.pymcp -o analysis.json fastmcp inspect pathtoserver.pyapp -o tmpserver-info.json  run Source httpsgofastmcp.compython-sdkfastmcp-cli-run  fastmcp.cli.run FastMCP run command implementation.  Functions  is_url python is_urlpath str - bool  Check if a string is a URL.  parse_file_path python parse_file_pathserver_spec str - tuplePath, str  None  Parse a file path that may include a server object specification. Args  server_spec Path to file, optionally with object suffix Returns  Tuple of file_path, server_object  import_server python import_serverfile Path, server_object str  None  None - Any  Import a MCP server from a file. Args  file Path to the file  server_object Optional object name in format moduleobject or just object Returns  The server object  create_client_server python create_client_serverurl str - Any  Create a FastMCP server from a client URL. Args  url The URL to connect to Returns  A FastMCP server instance  import_server_with_args python import_server_with_argsfile Path, server_object str  None  None, server_args liststr  None  None - Any  Import a server with optional command line arguments. Args  file Path to the server file  server_object Optional server object name  server_args Optional command line arguments to inject Returns  The imported server object  run_command python run_commandserver_spec str, transport str  None  None, host str  None  None, port int  None  None, log_level str  None  None, server_args liststr  None  None - None  Run a MCP server or connect to a remote one. Args  server_spec Python file, object specification fileobj, or URL  transport Transport protocol to use  host Host to bind to when using http transport  port Port to bind to when using http transport  log_level Log level  server_args Additional arguments to pass to the server  __init__ Source httpsgofastmcp.compython-sdkfastmcp-client-__init__  fastmcp.client This module is empty or contains only privateinternal implementations.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-client-auth-__init__  fastmcp.client.auth This module is empty or contains only privateinternal implementations.  bearer Source httpsgofastmcp.compython-sdkfastmcp-client-auth-bearer  fastmcp.client.auth.bearer  Classes  BearerAuth Methods  auth_flow python auth_flowself, request   oauth Source httpsgofastmcp.compython-sdkfastmcp-client-auth-oauth  fastmcp.client.auth.oauth  Functions  default_cache_dir python default_cache_dir - Path   OAuth python OAuthmcp_url str, scopes str  liststr  None  None, client_name str  FastMCP Client, token_storage_cache_dir Path  None  None, additional_client_metadata dictstr, Any  None  None - _MCPOAuthClientProvider  Create an OAuthClientProvider for an MCP server. This is intended to be provided to the auth parameter of an httpx.AsyncClient or appropriate FastMCP clienttransport instance Args  mcp_url Full URL to the MCP endpoint e.g. httphostmcpsse  scopes OAuth scopes to request. Can be a  client_name Name for this client during registration  token_storage_cache_dir Directory for FileTokenStorage  additional_client_metadata Extra fields for OAuthClientMetadata Returns  OAuthClientProvider  Classes  ServerOAuthMetadata More flexible OAuth metadata model that accepts broader ranges of values than the restrictive MCP standard model. This handles real-world OAuth servers like PayPal that may support additional methods not in the MCP specification.  OAuthClientProvider OAuth client provider with more flexible OAuth metadata discovery.  FileTokenStorage File-based token storage implementation for OAuth credentials and tokens. Implements the mcp.client.auth.TokenStorage protocol. Each instance is tied to a specific server URL for proper token isolation. Methods  get_base_url python get_base_urlurl str - str  Extract the base URL scheme  host from a URL.  get_cache_key python get_cache_keyself - str  Generate a safe filesystem key from the servers base URL.  clear python clearself - None  Clear all cached data for this server.  clear_all python clear_allcls, cache_dir Path  None  None - None  Clear all cached data for all servers.  client Source httpsgofastmcp.compython-sdkfastmcp-client-client  fastmcp.client.client  Classes  Client MCP client that delegates connection management to a Transport instance. The Client class is responsible for MCP protocol logic, while the Transport handles connection establishment and management. Client provides methods for working with resources, prompts, tools and other MCP capabilities. Args  transport Connection source specification, which can be  ClientTransport Direct transport instance  FastMCP In-process FastMCP server  AnyUrl  str URL to connect to  Path File path for local socket  MCPConfig MCP server configuration  dict Transport configuration  roots Optional RootsList or RootsHandler for filesystem access  sampling_handler Optional handler for sampling requests  log_handler Optional handler for log messages  message_handler Optional handler for protocol messages  progress_handler Optional handler for progress notifications  timeout Optional timeout for requests seconds or timedelta  init_timeout Optional timeout for initial connection seconds or timedelta. Set to 0 to disable. If None, uses the value in the FastMCP global settings. Examples python  Connect to FastMCP server client  Clienthttplocalhost8080 async with client  List available resources resources  await client.list_resources  Call a tool result  await client.call_toolmy_tool, param value  Methods  session python sessionself - ClientSession  Get the current active session. Raises RuntimeError if not connected.  initialize_result python initialize_resultself - mcp.types.InitializeResult  Get the result of the initialization request.  set_roots python set_rootsself, roots RootsList  RootsHandler - None  Set the roots for the client. This does not automatically call send_roots_list_changed.  set_sampling_callback python set_sampling_callbackself, sampling_callback SamplingHandler - None  Set the sampling callback for the client.  is_connected python is_connectedself - bool  Check if the client is currently connected.  logging Source httpsgofastmcp.compython-sdkfastmcp-client-logging  fastmcp.client.logging  Functions  create_log_callback python create_log_callbackhandler LogHandler  None  None - LoggingFnT   oauth_callback Source httpsgofastmcp.compython-sdkfastmcp-client-oauth_callback  fastmcp.client.oauth_callback OAuth callback server for handling authorization code flows. This module provides a reusable callback server that can handle OAuth redirects and display styled responses to users.  Functions  create_callback_html python create_callback_htmlmessage str, is_success bool  True, title str  FastMCP OAuth, server_url str  None  None - str  Create a styled HTML response for OAuth callbacks.  create_oauth_callback_server python create_oauth_callback_serverport int, callback_path str  callback, server_url str  None  None, response_future asyncio.Future  None  None - Server  Create an OAuth callback server. Args  port The port to run the server on  callback_path The path to listen for OAuth redirects on  server_url Optional server URL to display in success messages  response_future Optional future to resolve when OAuth callback is received Returns  Configured uvicorn Server instance not yet running  Classes  CallbackResponse Methods  from_dict python from_dictcls, data dictstr, str - CallbackResponse   to_dict python to_dictself - dictstr, str   progress Source httpsgofastmcp.compython-sdkfastmcp-client-progress  fastmcp.client.progress This module is empty or contains only privateinternal implementations.  roots Source httpsgofastmcp.compython-sdkfastmcp-client-roots  fastmcp.client.roots  Functions  convert_roots_list python convert_roots_listroots RootsList - listmcp.types.Root   create_roots_callback python create_roots_callbackhandler RootsList  RootsHandler - ListRootsFnT   sampling Source httpsgofastmcp.compython-sdkfastmcp-client-sampling  fastmcp.client.sampling  Functions  create_sampling_callback python create_sampling_callbacksampling_handler SamplingHandler - SamplingFnT   transports Source httpsgofastmcp.compython-sdkfastmcp-client-transports  fastmcp.client.transports  Functions  infer_transport python infer_transporttransport ClientTransport  FastMCP  FastMCP1Server  AnyUrl  Path  MCPConfig  dictstr, Any  str - ClientTransport  Infer the appropriate transport type from the given transport argument. This function attempts to infer the correct transport type from the provided argument, handling various input types and converting them to the appropriate ClientTransport subclass. The function supports these input types  ClientTransport Used directly without modification  FastMCP or FastMCP1Server Creates an in-memory FastMCPTransport  Path or str file path Creates PythonStdioTransport .py or NodeStdioTransport .js  AnyUrl or str URL Creates StreamableHttpTransport default or SSETransport for sse endpoints  MCPConfig or dict Creates MCPConfigTransport, potentially connecting to multiple servers For HTTP URLs, they are assumed to be Streamable HTTP URLs unless they end in sse. For MCPConfig with multiple servers, a composite client is created where each server is mounted with its name as prefix. This allows accessing tools and resources from multiple servers through a single unified client interface, using naming patterns like servername_toolname for tools and protocolservernamepath for resources. If the MCPConfig contains only one server, a direct connection is established without prefixing. Examples python  Connect to a local Python script transport  infer_transportmy_script.py  Connect to a remote server via HTTP transport  infer_transporthttpexample.commcp  Connect to multiple servers using MCPConfig config   mcpServers  weather url httpweather.example.commcp, calendar url httpcalendar.example.commcp   transport  infer_transportconfig   Classes  SessionKwargs Keyword arguments for the MCP ClientSession constructor.  ClientTransport Abstract base class for different MCP client transport mechanisms. A Transport is responsible for establishing and managing connections to an MCP server, and providing a ClientSession within an async context.  WSTransport Transport implementation that connects to an MCP server via WebSockets.  SSETransport Transport implementation that connects to an MCP server via Server-Sent Events.  StreamableHttpTransport Transport implementation that connects to an MCP server via Streamable HTTP Requests.  StdioTransport Base transport for connecting to an MCP server via subprocess with stdio. This is a base class that can be subclassed for specific command-based transports like Python, Node, Uvx, etc.  PythonStdioTransport Transport for running Python scripts.  FastMCPStdioTransport Transport for running FastMCP servers using the FastMCP CLI.  NodeStdioTransport Transport for running Node.js scripts.  UvxStdioTransport Transport for running commands via the uvx tool.  NpxStdioTransport Transport for running commands via the npx tool.  FastMCPTransport In-memory transport for FastMCP servers. This transport connects directly to a FastMCP server instance in the same Python process. It works with both FastMCP 2.x servers and FastMCP 1.0 servers from the low-level MCP SDK. This is particularly useful for unit tests or scenarios where client and server run in the same runtime.  MCPConfigTransport Transport for connecting to one or more MCP servers defined in an MCPConfig. This transport provides a unified interface to multiple MCP servers defined in an MCPConfig object or dictionary matching the MCPConfig schema. It supports two key scenarios 1. If the MCPConfig contains exactly one server, it creates a direct transport to that server. 2. If the MCPConfig contains multiple servers, it creates a composite client by mounting all servers on a single FastMCP instance, with each servers name used as its mounting prefix. In the multi-server case, tools are accessible with the prefix pattern server_name_tool_name and resources with the pattern protocolserver_namepathtoresource. This is particularly useful for creating clients that need to interact with multiple specialized MCP servers through a single interface, simplifying client code. Examples python from fastmcp import Client from fastmcp.utilities.mcp_config import MCPConfig  Create a config with multiple servers config   mcpServers  weather  url httpsweather-api.example.commcp, transport http , calendar  url httpscalendar-api.example.commcp, transport http     Create a client with the config client  Clientconfig async with client  Access tools with prefixes weather  await client.call_toolweather_get_forecast, city London events  await client.call_toolcalendar_list_events, date 2023-06-01  Access resources with prefixed URIs icons  await client.read_resourceweatherweathericonssunny   exceptions Source httpsgofastmcp.compython-sdkfastmcp-exceptions  fastmcp.exceptions Custom exceptions for FastMCP.  Classes  FastMCPError Base error for FastMCP.  ValidationError Error in validating parameters or return values.  ResourceError Error in resource operations.  ToolError Error in tool operations.  PromptError Error in prompt operations.  InvalidSignature Invalid signature for use with FastMCP.  ClientError Error in client operations.  NotFoundError Object not found.  DisabledError Object is disabled.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-prompts-__init__  fastmcp.prompts This module is empty or contains only privateinternal implementations.  prompt Source httpsgofastmcp.compython-sdkfastmcp-prompts-prompt  fastmcp.prompts.prompt Base classes for FastMCP prompts.  Functions  Message python Messagecontent str  MCPContent, role Role  None  None, kwargs Any - PromptMessage  A user-friendly constructor for PromptMessage.  Classes  PromptArgument An argument that can be passed to a prompt.  Prompt A prompt template that can be rendered with parameters. Methods  to_mcp_prompt python to_mcp_promptself, overrides Any - MCPPrompt  Convert the prompt to an MCP prompt.  from_function python from_functionfn Callable..., PromptResult  AwaitablePromptResult, name str  None  None, description str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionPrompt  Create a Prompt from a function. The function can return  A string converted to a message  A Message object  A dict converted to a message  A sequence of any of the above  FunctionPrompt A prompt that is a function. Methods  from_function python from_functioncls, fn Callable..., PromptResult  AwaitablePromptResult, name str  None  None, description str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionPrompt  Create a Prompt from a function. The function can return  A string converted to a message  A Message object  A dict converted to a message  A sequence of any of the above  prompt_manager Source httpsgofastmcp.compython-sdkfastmcp-prompts-prompt_manager  fastmcp.prompts.prompt_manager  Classes  PromptManager Manages FastMCP prompts. Methods  mount python mountself, server MountedServer - None  Adds a mounted server as a source for prompts.  add_prompt_from_fn python add_prompt_from_fnself, fn Callable..., PromptResult  AwaitablePromptResult, name str  None  None, description str  None  None, tags setstr  None  None - FunctionPrompt  Create a prompt from a function.  add_prompt python add_promptself, prompt Prompt - Prompt  Add a prompt to the manager.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-resources-__init__  fastmcp.resources This module is empty or contains only privateinternal implementations.  resource Source httpsgofastmcp.compython-sdkfastmcp-resources-resource  fastmcp.resources.resource Base classes and interfaces for FastMCP resources.  Classes  Resource Base class for all resources. Methods  from_function python from_functionfn Callable, Any, uri str  AnyUrl, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionResource   set_default_mime_type python set_default_mime_typecls, mime_type str  None - str  Set default MIME type if not provided.  set_default_name python set_default_nameself - Self  Set default name from URI if not provided.  to_mcp_resource python to_mcp_resourceself, overrides Any - MCPResource  Convert the resource to an MCPResource.  key python keyself - str  The key of the component. This is used for internal bookkeeping and may reflect e.g. prefixes or other identifiers. You should not depend on keys having a certain value, as the same tool loaded from different hierarchies of servers may have different keys.  FunctionResource A resource that defers data loading by wrapping a function. The function is only called when the resource is read, allowing for lazy loading of potentially expensive data. This is particularly useful when listing resources, as the function wont be called until the resource is actually accessed. The function can return  str for text content default  bytes for binary content  other types will be converted to JSON Methods  from_function python from_functioncls, fn Callable, Any, uri str  AnyUrl, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionResource  Create a FunctionResource from a function.  resource_manager Source httpsgofastmcp.compython-sdkfastmcp-resources-resource_manager  fastmcp.resources.resource_manager Resource manager functionality.  Classes  ResourceManager Manages FastMCP resources. Methods  mount python mountself, server MountedServer - None  Adds a mounted server as a source for resources and templates.  add_resource_or_template_from_fn python add_resource_or_template_from_fnself, fn Callable..., Any, uri str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None - Resource  ResourceTemplate  Add a resource or template to the manager from a function. Args  fn The function to register as a resource or template  uri The URI for the resource or template  name Optional name for the resource or template  description Optional description of the resource or template  mime_type Optional MIME type for the resource or template  tags Optional set of tags for categorizing the resource or template Returns  The added resource or template. If a resource or template with the same URI already exists,  returns the existing resource or template.  add_resource_from_fn python add_resource_from_fnself, fn Callable..., Any, uri str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None - Resource  Add a resource to the manager from a function. Args  fn The function to register as a resource  uri The URI for the resource  name Optional name for the resource  description Optional description of the resource  mime_type Optional MIME type for the resource  tags Optional set of tags for categorizing the resource Returns  The added resource. If a resource with the same URI already exists,  returns the existing resource.  add_resource python add_resourceself, resource Resource - Resource  Add a resource to the manager. Args  resource A Resource instance to add. The resources .key attribute will be used as the storage key. To overwrite it, call Resource.with_key before calling this method.  add_template_from_fn python add_template_from_fnself, fn Callable..., Any, uri_template str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None - ResourceTemplate  Create a template from a function.  add_template python add_templateself, template ResourceTemplate - ResourceTemplate  Add a template to the manager. Args  template A ResourceTemplate instance to add. The templates .key attribute will be used as the storage key. To overwrite it, call ResourceTemplate.with_key before calling this method. Returns  The added template. If a template with the same URI already exists,  returns the existing template.  template Source httpsgofastmcp.compython-sdkfastmcp-resources-template  fastmcp.resources.template Resource template functionality.  Functions  build_regex python build_regextemplate str - re.Pattern   match_uri_template python match_uri_templateuri str, uri_template str - dictstr, str  None   Classes  ResourceTemplate A template for dynamically creating resources. Methods  from_function python from_functionfn Callable..., Any, uri_template str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionResourceTemplate   set_default_mime_type python set_default_mime_typecls, mime_type str  None - str  Set default MIME type if not provided.  matches python matchesself, uri str - dictstr, Any  None  Check if URI matches template and extract parameters.  to_mcp_template python to_mcp_templateself, overrides Any - MCPResourceTemplate  Convert the resource template to an MCPResourceTemplate.  from_mcp_template python from_mcp_templatecls, mcp_template MCPResourceTemplate - ResourceTemplate  Creates a FastMCP ResourceTemplate from a raw MCP ResourceTemplate object.  key python keyself - str  The key of the component. This is used for internal bookkeeping and may reflect e.g. prefixes or other identifiers. You should not depend on keys having a certain value, as the same tool loaded from different hierarchies of servers may have different keys.  FunctionResourceTemplate A template for dynamically creating resources. Methods  from_function python from_functioncls, fn Callable..., Any, uri_template str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None, enabled bool  None  None - FunctionResourceTemplate  Create a template from a function.  types Source httpsgofastmcp.compython-sdkfastmcp-resources-types  fastmcp.resources.types Concrete resource implementations.  Classes  TextResource A resource that reads from a string.  BinaryResource A resource that reads from bytes.  FileResource A resource that reads from a file. Set is_binaryTrue to read file as binary data instead of text. Methods  validate_absolute_path python validate_absolute_pathcls, path Path - Path  Ensure path is absolute.  set_binary_from_mime_type python set_binary_from_mime_typecls, is_binary bool, info ValidationInfo - bool  Set is_binary based on mime_type if not explicitly set.  HttpResource A resource that reads from an HTTP endpoint.  DirectoryResource A resource that lists files in a directory. Methods  validate_absolute_path python validate_absolute_pathcls, path Path - Path  Ensure path is absolute.  list_files python list_filesself - listPath  List files in the directory.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-server-__init__  fastmcp.server This module is empty or contains only privateinternal implementations.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-server-auth-__init__  fastmcp.server.auth This module is empty or contains only privateinternal implementations.  auth Source httpsgofastmcp.compython-sdkfastmcp-server-auth-auth  fastmcp.server.auth.auth  Classes  OAuthProvider  __init__ Source httpsgofastmcp.compython-sdkfastmcp-server-auth-providers-__init__  fastmcp.server.auth.providers This module is empty or contains only privateinternal implementations.  bearer Source httpsgofastmcp.compython-sdkfastmcp-server-auth-providers-bearer  fastmcp.server.auth.providers.bearer  Classes  JWKData JSON Web Key data structure.  JWKSData JSON Web Key Set data structure.  RSAKeyPair Methods  generate python generatecls - RSAKeyPair  Generate an RSA key pair for testing. Returns  private_key_pem, public_key_pem  create_token python create_tokenself, subject str  fastmcp-user, issuer str  httpsfastmcp.example.com, audience str  liststr  None  None, scopes liststr  None  None, expires_in_seconds int  3600, additional_claims dictstr, Any  None  None, kid str  None  None - str  Generate a test JWT token for testing purposes. Args  private_key_pem RSA private key in PEM format  subject Subject claim usually user ID  issuer Issuer claim  audience Audience claim - can be a string or list of strings optional  scopes List of scopes to include  expires_in_seconds Token expiration time in seconds  additional_claims Any additional claims to include  kid Key ID for JWKS lookup optional Returns  Signed JWT token string  BearerAuthProvider Simple JWT Bearer Token validator for hosted MCP servers. Uses RS256 asymmetric encryption. Supports either static public key or JWKS URI for key rotation. Note that this provider DOES NOT permit client registration or revocation, or any OAuth flows. It is intended to be used with a control plane that manages clients and tokens.  bearer_env Source httpsgofastmcp.compython-sdkfastmcp-server-auth-providers-bearer_env  fastmcp.server.auth.providers.bearer_env  Classes  EnvBearerAuthProviderSettings Settings for the BearerAuthProvider.  EnvBearerAuthProvider A BearerAuthProvider that loads settings from environment variables. Any providing setting will always take precedence over the environment variables.  in_memory Source httpsgofastmcp.compython-sdkfastmcp-server-auth-providers-in_memory  fastmcp.server.auth.providers.in_memory  Classes  InMemoryOAuthProvider An in-memory OAuth provider for testing purposes. It simulates the OAuth 2.1 flow locally without external calls.  context Source httpsgofastmcp.compython-sdkfastmcp-server-context  fastmcp.server.context  Functions  set_context python set_contextcontext Context - GeneratorContext, None, None   Classes  Context Context object providing access to MCP capabilities. This provides a cleaner interface to MCPs RequestContext functionality. It gets injected into tool and resource functions that request it via type hints. To use context in a tool function, add a parameter with the Context type annotation python server.tool def my_toolx int, ctx Context - str  Log messages to the client ctx.infofProcessing x ctx.debugDebug info ctx.warningWarning message ctx.errorError message  Report progress ctx.report_progress50, 100, Processing  Access resources data  ctx.read_resourceresourcedata  Get request info request_id  ctx.request_id client_id  ctx.client_id return strx  The context parameter name can be anything as long as its annotated with Context. The context is optional - tools that dont need it can omit the parameter. Methods  request_context python request_contextself - RequestContext  Access to the underlying request context. If called outside of a request context, this will raise a ValueError.  client_id python client_idself - str  None  Get the client ID if available.  request_id python request_idself - str  Get the unique ID for this request.  session_id python session_idself - str  None  Get the MCP session ID for HTTP transports. Returns the session ID that can be used as a key for session-based data storage e.g., Redis to share data between tool calls within the same client session. Returns  The session ID for HTTP transports SSE, StreamableHTTP, or None  for stdio and in-memory transports which dont use session IDs.  session python sessionself  Access to the underlying session for advanced usage.  get_http_request python get_http_requestself - Request  Get the active starlette request.  dependencies Source httpsgofastmcp.compython-sdkfastmcp-server-dependencies  fastmcp.server.dependencies  Functions  get_context python get_context - Context   get_http_request python get_http_request - Request   get_http_headers python get_http_headersinclude_all bool  False - dictstr, str  Extract headers from the current HTTP request if available. Never raises an exception, even if there is no active HTTP request in which case an empty dict is returned. By default, strips problematic headers like content-length that cause issues if forwarded to downstream clients. If include_all is True, all headers are returned.  http Source httpsgofastmcp.compython-sdkfastmcp-server-http  fastmcp.server.http  Functions  set_http_request python set_http_requestrequest Request - GeneratorRequest, None, None   setup_auth_middleware_and_routes python setup_auth_middleware_and_routesauth OAuthProvider - tuplelistMiddleware, listBaseRoute, liststr  Set up authentication middleware and routes if auth is enabled. Args  auth The OAuthProvider authorization server provider Returns  Tuple of middleware, auth_routes, required_scopes  create_base_app python create_base_approutes listBaseRoute, middleware listMiddleware, debug bool  False, lifespan Callable  None  None - StarletteWithLifespan  Create a base Starlette app with common middleware and routes. Args  routes List of routes to include in the app  middleware List of middleware to include in the app  debug Whether to enable debug mode  lifespan Optional lifespan manager for the app Returns  A Starlette application  create_sse_app python create_sse_appserver FastMCPLifespanResultT, message_path str, sse_path str, auth OAuthProvider  None  None, debug bool  False, routes listBaseRoute  None  None, middleware listMiddleware  None  None - StarletteWithLifespan  Return an instance of the SSE server app. Args  server The FastMCP server instance  message_path Path for SSE messages  sse_path Path for SSE connections  auth Optional auth provider  debug Whether to enable debug mode  routes Optional list of custom routes  middleware Optional list of middleware Returns A Starlette application with RequestContextMiddleware  create_streamable_http_app python create_streamable_http_appserver FastMCPLifespanResultT, streamable_http_path str, event_store EventStore  None  None, auth OAuthProvider  None  None, json_response bool  False, stateless_http bool  False, debug bool  False, routes listBaseRoute  None  None, middleware listMiddleware  None  None - StarletteWithLifespan  Return an instance of the StreamableHTTP server app. Args  server The FastMCP server instance  streamable_http_path Path for StreamableHTTP connections  event_store Optional event store for session management  auth Optional auth provider  json_response Whether to use JSON response format  stateless_http Whether to use stateless mode new transport per request  debug Whether to enable debug mode  routes Optional list of custom routes  middleware Optional list of middleware Returns  A Starlette application with StreamableHTTP support  Classes  StarletteWithLifespan Methods  lifespan python lifespanself - Lifespan   RequestContextMiddleware Middleware that stores each request in a ContextVar  __init__ Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-__init__  fastmcp.server.middleware This module is empty or contains only privateinternal implementations.  error_handling Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-error_handling  fastmcp.server.middleware.error_handling Error handling middleware for consistent error responses and tracking.  Classes  ErrorHandlingMiddleware Middleware that provides consistent error handling and logging. Catches exceptions, logs them appropriately, and converts them to proper MCP error responses. Also tracks error patterns for monitoring. Methods  get_error_stats python get_error_statsself - dictstr, int  Get error statistics for monitoring.  RetryMiddleware Middleware that implements automatic retry logic for failed requests. Retries requests that fail with transient errors, using exponential backoff to avoid overwhelming the server or external dependencies.  logging Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-logging  fastmcp.server.middleware.logging Comprehensive logging middleware for FastMCP servers.  Classes  LoggingMiddleware Middleware that provides comprehensive request and response logging. Logs all MCP messages with configurable detail levels. Useful for debugging, monitoring, and understanding server usage patterns.  StructuredLoggingMiddleware Middleware that provides structured JSON logging for better log analysis. Outputs structured logs that are easier to parse and analyze with log aggregation tools like ELK stack, Splunk, or cloud logging services.  middleware Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-middleware  fastmcp.server.middleware.middleware  Functions  make_middleware_wrapper python make_middleware_wrappermiddleware Middleware, call_next CallNextT, R - CallNextT, R  Create a wrapper that applies a single middleware to a context. The closure bakes in the middleware and call_next function, so it can be passed to other functions that expect a call_next function.  Classes  CallNext  CallToolResult  ListToolsResult  ListResourcesResult  ListResourceTemplatesResult  ListPromptsResult  ServerResultProtocol  MiddlewareContext Unified context for all middleware operations. Methods  copy python copyself, kwargs Any - MiddlewareContextT   Middleware Base class for FastMCP middleware with dispatching hooks.  rate_limiting Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-rate_limiting  fastmcp.server.middleware.rate_limiting Rate limiting middleware for protecting FastMCP servers from abuse.  Classes  RateLimitError Error raised when rate limit is exceeded.  TokenBucketRateLimiter Token bucket implementation for rate limiting.  SlidingWindowRateLimiter Sliding window rate limiter implementation.  RateLimitingMiddleware Middleware that implements rate limiting to prevent server abuse. Uses a token bucket algorithm by default, allowing for burst traffic while maintaining a sustainable long-term rate.  SlidingWindowRateLimitingMiddleware Middleware that implements sliding window rate limiting. Uses a sliding window approach which provides more precise rate limiting but uses more memory to track individual request timestamps.  timing Source httpsgofastmcp.compython-sdkfastmcp-server-middleware-timing  fastmcp.server.middleware.timing Timing middleware for measuring and logging request performance.  Classes  TimingMiddleware Middleware that logs the execution time of requests. Only measures and logs timing for request messages not notifications. Provides insights into performance characteristics of your MCP server.  DetailedTimingMiddleware Enhanced timing middleware with per-operation breakdowns. Provides detailed timing information for different types of MCP operations, allowing you to identify performance bottlenecks in specific operations.  openapi Source httpsgofastmcp.compython-sdkfastmcp-server-openapi  fastmcp.server.openapi FastMCP server implementation for OpenAPI integration.  Classes  MCPType Type of FastMCP component to create from a route.  RouteType Deprecated Use MCPType instead. This enum is kept for backward compatibility and will be removed in a future version.  RouteMap Mapping configuration for HTTP routes to FastMCP component types.  OpenAPITool Tool implementation for OpenAPI endpoints.  OpenAPIResource Resource implementation for OpenAPI endpoints.  OpenAPIResourceTemplate Resource template implementation for OpenAPI endpoints.  FastMCPOpenAPI FastMCP server implementation that creates components from an OpenAPI schema. This class parses an OpenAPI specification and creates appropriate FastMCP components Tools, Resources, ResourceTemplates based on route mappings.  proxy Source httpsgofastmcp.compython-sdkfastmcp-server-proxy  fastmcp.server.proxy  Classes  ProxyToolManager A ToolManager that sources its tools from a remote client in addition to local and mounted tools.  ProxyResourceManager A ResourceManager that sources its resources from a remote client in addition to local and mounted resources.  ProxyPromptManager A PromptManager that sources its prompts from a remote client in addition to local and mounted prompts.  ProxyTool A Tool that represents and executes a tool on a remote server. Methods  from_mcp_tool python from_mcp_toolcls, client Client, mcp_tool mcp.types.Tool - ProxyTool  Factory method to create a ProxyTool from a raw MCP tool schema.  ProxyResource A Resource that represents and reads a resource from a remote server. Methods  from_mcp_resource python from_mcp_resourcecls, client Client, mcp_resource mcp.types.Resource - ProxyResource  Factory method to create a ProxyResource from a raw MCP resource schema.  ProxyTemplate A ResourceTemplate that represents and creates resources from a remote server template. Methods  from_mcp_template python from_mcp_templatecls, client Client, mcp_template mcp.types.ResourceTemplate - ProxyTemplate  Factory method to create a ProxyTemplate from a raw MCP template schema.  ProxyPrompt A Prompt that represents and renders a prompt from a remote server. Methods  from_mcp_prompt python from_mcp_promptcls, client Client, mcp_prompt mcp.types.Prompt - ProxyPrompt  Factory method to create a ProxyPrompt from a raw MCP prompt schema.  FastMCPProxy A FastMCP server that acts as a proxy to a remote MCP-compliant server. It uses specialized managers that fulfill requests via an HTTP client.  server Source httpsgofastmcp.compython-sdkfastmcp-server-server  fastmcp.server.server FastMCP - A more ergonomic interface for MCP servers.  Functions  add_resource_prefix python add_resource_prefixuri str, prefix str, prefix_format Literalprotocol, path  None  None - str  Add a prefix to a resource URI. Args  uri The original resource URI  prefix The prefix to add Returns  The resource URI with the prefix added Examples With new style python add_resource_prefixresourcepathtoresource, prefix resourceprefixpathtoresource  With legacy style python add_resource_prefixresourcepathtoresource, prefix prefixresourcepathtoresource  With absolute path python add_resource_prefixresourceabsolutepath, prefix resourceprefixabsolutepath  Raises  ValueError If the URI doesnt match the expected protocolpath format  remove_resource_prefix python remove_resource_prefixuri str, prefix str, prefix_format Literalprotocol, path  None  None - str  Remove a prefix from a resource URI. Args  uri The resource URI with a prefix  prefix The prefix to remove  prefix_format The format of the prefix to remove Returns The resource URI with the prefix removed Examples With new style python remove_resource_prefixresourceprefixpathtoresource, prefix resourcepathtoresource  With legacy style python remove_resource_prefixprefixresourcepathtoresource, prefix resourcepathtoresource  With absolute path python remove_resource_prefixresourceprefixabsolutepath, prefix resourceabsolutepath  Raises  ValueError If the URI doesnt match the expected protocolpath format  has_resource_prefix python has_resource_prefixuri str, prefix str, prefix_format Literalprotocol, path  None  None - bool  Check if a resource URI has a specific prefix. Args  uri The resource URI to check  prefix The prefix to look for Returns  True if the URI has the specified prefix, False otherwise Examples With new style python has_resource_prefixresourceprefixpathtoresource, prefix True  With legacy style python has_resource_prefixprefixresourcepathtoresource, prefix True  With other path python has_resource_prefixresourceotherpathtoresource, prefix False  Raises  ValueError If the URI doesnt match the expected protocolpath format  Classes  FastMCP Methods  settings python settingsself - Settings   name python nameself - str   instructions python instructionsself - str  None   run python runself, transport Transport  None  None, transport_kwargs Any - None  Run the FastMCP server. Note this is a synchronous function. Args  transport Transport protocol to use stdio, sse, or streamable-http  add_middleware python add_middlewareself, middleware Middleware - None   custom_route python custom_routeself, path str, methods liststr, name str  None  None, include_in_schema bool  True  Decorator to register a custom HTTP route on the FastMCP server. Allows adding arbitrary HTTP endpoints outside the standard MCP protocol, which can be useful for OAuth callbacks, health checks, or admin APIs. The handler function must be an async function that accepts a Starlette Request and returns a Response. Args  path URL path for the route e.g., oauthcallback  methods List of HTTP methods to support e.g., GET, POST  name Optional name for the route to reference this route with Starlettes reverse URL lookup feature  include_in_schema Whether to include in OpenAPI schema, defaults to True  add_tool python add_toolself, tool Tool - None  Add a tool to the server. The tool function can optionally request a Context object by adding a parameter with the Context type annotation. See the tool decorator for examples. Args  tool The Tool instance to register  remove_tool python remove_toolself, name str - None  Remove a tool from the server. Args  name The name of the tool to remove Raises  NotFoundError If the tool is not found  tool python toolself, name_or_fn AnyFunction - FunctionTool   tool python toolself, name_or_fn str  None  None - CallableAnyFunction, FunctionTool   tool python toolself, name_or_fn str  AnyFunction  None  None - CallableAnyFunction, FunctionTool  FunctionTool  Decorator to register a tool. Tools can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and resource access. This decorator supports multiple calling patterns  server.tool without parentheses  server.tool with empty parentheses  server.toolcustom_name with name as first argument  server.toolnamecustom_name with name as keyword argument  server.toolfunction, namecustom_name direct function call Args  name_or_fn Either a function when used as tool, a string name, or None  name Optional name for the tool keyword-only, alternative to name_or_fn  description Optional description of what the tool does  tags Optional set of tags for categorizing the tool  annotations Optional annotations about the tools behavior  exclude_args Optional list of argument names to exclude from the tool schema  enabled Optional boolean to enable or disable the tool Examples Register a tool with a custom name python server.tool def my_toolx int - str return strx  Register a tool with a custom name server.tool def my_toolx int - str return strx server.toolcustom_name def my_toolx int - str return strx server.toolnamecustom_name def my_toolx int - str return strx  Direct function call server.toolmy_function, namecustom_name   add_resource python add_resourceself, resource Resource - None  Add a resource to the server. Args  resource A Resource instance to add  add_template python add_templateself, template ResourceTemplate - None  Add a resource template to the server. Args  template A ResourceTemplate instance to add  add_resource_fn python add_resource_fnself, fn AnyFunction, uri str, name str  None  None, description str  None  None, mime_type str  None  None, tags setstr  None  None - None  Add a resource or template to the server from a function. If the URI contains parameters e.g. resourceparam or the function has parameters, it will be registered as a template resource. Args  fn The function to register as a resource  uri The URI for the resource  name Optional name for the resource  description Optional description of the resource  mime_type Optional MIME type for the resource  tags Optional set of tags for categorizing the resource  resource python resourceself, uri str - CallableAnyFunction, Resource  ResourceTemplate  Decorator to register a function as a resource. The function will be called when the resource is read to generate its content. The function can return  str for text content  bytes for binary content  other types will be converted to JSON Resources can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and session information. If the URI contains parameters e.g. resourceparam or the function has parameters, it will be registered as a template resource. Args  uri URI for the resource e.g. resourcemy-resource or resourceparam  name Optional name for the resource  description Optional description of the resource  mime_type Optional MIME type for the resource  tags Optional set of tags for categorizing the resource  enabled Optional boolean to enable or disable the resource Examples Register a resource with a custom name python server.resourceresourcemy-resource def get_data - str return Hello, world! server.resourceresourcemy-resource async get_data - str data  await fetch_data return fHello, world! data server.resourceresourcecityweather def get_weathercity str - str return fWeather for city server.resourceresourcecityweather def get_weather_with_contextcity str, ctx Context - str ctx.infofFetching weather for city return fWeather for city server.resourceresourcecityweather async def get_weathercity str - str data  await fetch_weathercity return fWeather for city data   add_prompt python add_promptself, prompt Prompt - None  Add a prompt to the server. Args  prompt A Prompt instance to add  prompt python promptself, name_or_fn AnyFunction - FunctionPrompt   prompt python promptself, name_or_fn str  None  None - CallableAnyFunction, FunctionPrompt   prompt python promptself, name_or_fn str  AnyFunction  None  None - CallableAnyFunction, FunctionPrompt  FunctionPrompt  Decorator to register a prompt. Prompts can optionally request a Context object by adding a parameter with the Context type annotation. The context provides access to MCP capabilities like logging, progress reporting, and session information. This decorator supports multiple calling patterns  server.prompt without parentheses  server.prompt with empty parentheses  server.promptcustom_name with name as first argument  server.promptnamecustom_name with name as keyword argument  server.promptfunction, namecustom_name direct function call Args name_or_fn Either a function when used as prompt, a string name, or None name Optional name for the prompt keyword-only, alternative to name_or_fn description Optional description of what the prompt does tags Optional set of tags for categorizing the prompt enabled Optional boolean to enable or disable the prompt Examples python server.prompt def analyze_tabletable_name str - listMessage schema  read_table_schematable_name return   role user, content fAnalyze this schema schema   server.prompt def analyze_with_contexttable_name str, ctx Context - listMessage ctx.infofAnalyzing table table_name schema  read_table_schematable_name return   role user, content fAnalyze this schema schema   server.promptcustom_name def analyze_filepath str - listMessage content  await read_filepath return   role user, content  type resource, resource  uri ffilepath, text content     server.promptnamecustom_name def another_promptdata str - listMessage return role user, content data  Direct function call server.promptmy_function, namecustom_name   sse_app python sse_appself, path str  None  None, message_path str  None  None, middleware listASGIMiddleware  None  None - StarletteWithLifespan  Create a Starlette app for the SSE server. Args  path The path to the SSE endpoint  message_path The path to the message endpoint  middleware A list of middleware to apply to the app  streamable_http_app python streamable_http_appself, path str  None  None, middleware listASGIMiddleware  None  None - StarletteWithLifespan  Create a Starlette app for the StreamableHTTP server. Args  path The path to the StreamableHTTP endpoint  middleware A list of middleware to apply to the app  http_app python http_appself, path str  None  None, middleware listASGIMiddleware  None  None, json_response bool  None  None, stateless_http bool  None  None, transport Literalhttp, streamable-http, sse  http - StarletteWithLifespan  Create a Starlette app using the specified HTTP transport. Args  path The path for the HTTP endpoint  middleware A list of middleware to apply to the app  transport Transport protocol to use - either streamable-http default or sse Returns  A Starlette application configured with the specified transport  mount python mountself, server FastMCPLifespanResultT, prefix str  None  None, as_proxy bool  None  None - None  Mount another FastMCP server on this server with an optional prefix. Unlike importing with import_server, mounting establishes a dynamic connection between servers. When a client interacts with a mounted servers objects through the parent server, requests are forwarded to the mounted server in real-time. This means changes to the mounted server are immediately reflected when accessed through the parent. When a server is mounted with a prefix  Tools from the mounted server are accessible with prefixed names. Example If server has a tool named get_weather, it will be available as prefix_get_weather.  Resources are accessible with prefixed URIs. Example If server has a resource with URI weatherforecast, it will be available as weatherprefixforecast.  Templates are accessible with prefixed URI templates. Example If server has a template with URI weatherlocationid, it will be available as weatherprefixlocationid.  Prompts are accessible with prefixed names. Example If server has a prompt named weather_prompt, it will be available as prefix_weather_prompt. When a server is mounted without a prefix prefixNone, its tools, resources, templates, and prompts are accessible with their original names. Multiple servers can be mounted without prefixes, and they will be tried in order until a match is found. There are two modes for mounting servers 1. Direct mounting default when server has no custom lifespan The parent server directly accesses the mounted servers objects in-memory for better performance. In this mode, no client lifecycle events occur on the mounted server, including lifespan execution. 2. Proxy mounting default when server has a custom lifespan The parent server treats the mounted server as a separate entity and communicates with it via a Client transport. This preserves all client-facing behaviors, including lifespan execution, but with slightly higher overhead. Args  server The FastMCP server to mount.  prefix Optional prefix to use for the mounted servers objects. If None, the servers objects are accessible with their original names.  as_proxy Whether to treat the mounted server as a proxy. If None default, automatically determined based on whether the server has a custom lifespan True if it has a custom lifespan, False otherwise.  tool_separator Deprecated. Separator character for tool names.  resource_separator Deprecated. Separator character for resource URIs.  prompt_separator Deprecated. Separator character for prompt names.  from_openapi python from_openapicls, openapi_spec dictstr, Any, client httpx.AsyncClient, route_maps listRouteMap  None  None, route_map_fn OpenAPIRouteMapFn  None  None, mcp_component_fn OpenAPIComponentFn  None  None, mcp_names dictstr, str  None  None, tags setstr  None  None, settings Any - FastMCPOpenAPI  Create a FastMCP server from an OpenAPI specification.  from_fastapi python from_fastapicls, app Any, name str  None  None, route_maps listRouteMap  None  None, route_map_fn OpenAPIRouteMapFn  None  None, mcp_component_fn OpenAPIComponentFn  None  None, mcp_names dictstr, str  None  None, httpx_client_kwargs dictstr, Any  None  None, tags setstr  None  None, settings Any - FastMCPOpenAPI  Create a FastMCP server from a FastAPI application.  as_proxy python as_proxycls, backend ClientClientTransportT  ClientTransport  FastMCPAny  AnyUrl  Path  MCPConfig  dictstr, Any  str, settings Any - FastMCPProxy  Create a FastMCP proxy server for the given backend. The backend argument can be either an existing fastmcp.client.Client instance or any value accepted as the transport argument of fastmcp.client.Client. This mirrors the convenience of the fastmcp.client.Client constructor.  from_client python from_clientcls, client ClientClientTransportT, settings Any - FastMCPProxy  Create a FastMCP proxy server from a FastMCP client.  MountedServer  settings Source httpsgofastmcp.compython-sdkfastmcp-settings  fastmcp.settings  Classes  ExtendedEnvSettingsSource A special EnvSettingsSource that allows for multiple env var prefixes to be used. Raises a deprecation warning if the old FASTMCP_SERVER_ prefix is used. Methods  get_field_value python get_field_valueself, field FieldInfo, field_name str - tupleAny, str, bool   ExtendedSettingsConfigDict  Settings FastMCP settings. Methods  settings_customise_sources python settings_customise_sourcescls, settings_cls typeBaseSettings, init_settings PydanticBaseSettingsSource, env_settings PydanticBaseSettingsSource, dotenv_settings PydanticBaseSettingsSource, file_secret_settings PydanticBaseSettingsSource - tuplePydanticBaseSettingsSource, ...   settings python settingsself - Self  This property is for backwards compatibility with FastMCP  2.8.0, which accessed fastmcp.settings.settings  setup_logging python setup_loggingself - Self  Finalize the settings.  __init__ Source httpsgofastmcp.compython-sdkfastmcp-tools-__init__  fastmcp.tools This module is empty or contains only privateinternal implementations.  tool Source httpsgofastmcp.compython-sdkfastmcp-tools-tool  fastmcp.tools.tool  Functions  default_serializer python default_serializerdata Any - str   Classes  Tool Internal tool registration info. Methods  to_mcp_tool python to_mcp_toolself, overrides Any - MCPTool   from_function python from_functionfn Callable..., Any, name str  None  None, description str  None  None, tags setstr  None  None, annotations ToolAnnotations  None  None, exclude_args liststr  None  None, serializer CallableAny, str  None  None, enabled bool  None  None - FunctionTool  Create a Tool from a function.  from_tool python from_toolcls, tool Tool, transform_fn Callable..., Any  None  None, name str  None  None, transform_args dictstr, ArgTransform  None  None, description str  None  None, tags setstr  None  None, annotations ToolAnnotations  None  None, serializer CallableAny, str  None  None, enabled bool  None  None - TransformedTool   FunctionTool Methods  from_function python from_functioncls, fn Callable..., Any, name str  None  None, description str  None  None, tags setstr  None  None, annotations ToolAnnotations  None  None, exclude_args liststr  None  None, serializer CallableAny, str  None  None, enabled bool  None  None - FunctionTool  Create a Tool from a function.  ParsedFunction Methods  from_function python from_functioncls, fn Callable..., Any, exclude_args liststr  None  None, validate bool  True - ParsedFunction   tool_manager Source httpsgofastmcp.compython-sdkfastmcp-tools-tool_manager  fastmcp.tools.tool_manager  Classes  ToolManager Manages FastMCP tools. Methods  mount python mountself, server MountedServer - None  Adds a mounted server as a source for tools.  add_tool_from_fn python add_tool_from_fnself, fn Callable..., Any, name str  None  None, description str  None  None, tags setstr  None  None, annotations ToolAnnotations  None  None, serializer CallableAny, str  None  None, exclude_args liststr  None  None - Tool  Add a tool to the server.  add_tool python add_toolself, tool Tool - Tool  Register a tool with the server.  remove_tool python remove_toolself, key str - None  Remove a tool from the server. Args  key The key of the tool to remove Raises  NotFoundError If the tool is not found  tool_transform Source httpsgofastmcp.compython-sdkfastmcp-tools-tool_transform  fastmcp.tools.tool_transform  Classes  ArgTransform Configuration for transforming a parent tools argument. This class allows fine-grained control over how individual arguments are transformed when creating a new tool from an existing one. You can rename arguments, change their descriptions, add default values, or hide them from clients while passing constants. Examples Rename argument old_name to new_name python ArgTransformnamenew_name  Change description only python ArgTransformdescriptionUpdated description  Add a default value makes argument optional python ArgTransformdefault42  Add a default factory makes argument optional python ArgTransformdefault_factorylambda time.time  Change the type python ArgTransformtypestr  Hide the argument entirely from clients python ArgTransformhideTrue  Hide argument but pass a constant value to parent python ArgTransformhideTrue, defaultconstant_value  Hide argument but pass a factory-generated value to parent python ArgTransformhideTrue, default_factorylambda uuid.uuid4.hex  Make an optional parameter required removes any default python ArgTransformrequiredTrue  Combine multiple transformations python ArgTransformnamenew_name, descriptionNew desc, defaultNone, typeint   TransformedTool A tool that is transformed from another tool. This class represents a tool that has been created by transforming another tool. It supports argument renaming, schema modification, custom function injection, and provides context for the forward and forward_raw functions. The transformation can be purely schema-based argument renaming, dropping, etc. or can include a custom function that uses forward to call the parent tool with transformed arguments. Methods  from_tool python from_toolcls, tool Tool, name str  None  None, description str  None  None, tags setstr  None  None, transform_fn Callable..., Any  None  None, transform_args dictstr, ArgTransform  None  None, annotations ToolAnnotations  None  None, serializer CallableAny, str  None  None, enabled bool  None  None - TransformedTool  Create a transformed tool from a parent tool. Args  tool The parent tool to transform.  transform_fn Optional custom function. Can use forward and forward_raw to call the parent tool. Functions with kwargs receive transformed argument names.  name New name for the tool. Defaults to parent tools name.  transform_args Optional transformations for parent tool arguments. Only specified arguments are transformed, others pass through unchanged  Simple rename str  Complex transformation renamedescriptiondefaultdrop ArgTransform  Drop the argument None  description New description. Defaults to parents description.  tags New tags. Defaults to parents tags.  annotations New annotations. Defaults to parents annotations.  serializer New serializer. Defaults to parents serializer. Returns  TransformedTool with the specified transformations. Examples  Transform specific arguments only python Tool.from_toolparent, transform_argsold new  Others unchanged   Custom function with partial transforms python async def customx int, y int - str result  await forwardxx, yy return fCustom result Tool.from_toolparent, transform_fncustom, transform_argsa x, b y   Using kwargs gets all args, transformed and untransformed python async def flexiblekwargs - str result  await forwardkwargs return fGot kwargs Tool.from_toolparent, transform_fnflexible, transform_argsa x   __init__ Source httpsgofastmcp.compython-sdkfastmcp-utilities-__init__  fastmcp.utilities FastMCP utility modules.  cache Source httpsgofastmcp.compython-sdkfastmcp-utilities-cache  fastmcp.utilities.cache  Classes  TimedCache Methods  set python setself, key Any, value Any - None   get python getself, key Any - Any   clear python clearself - None   components Source httpsgofastmcp.compython-sdkfastmcp-utilities-components  fastmcp.utilities.components  Classes  FastMCPComponent Base class for FastMCP tools, prompts, resources, and resource templates. Methods  key python keyself - str  The key of the component. This is used for internal bookkeeping and may reflect e.g. prefixes or other identifiers. You should not depend on keys having a certain value, as the same tool loaded from different hierarchies of servers may have different keys.  with_key python with_keyself, key str - Self   enable python enableself - None  Enable the component.  disable python disableself - None  Disable the component.  exceptions Source httpsgofastmcp.compython-sdkfastmcp-utilities-exceptions  fastmcp.utilities.exceptions  Functions  iter_exc python iter_excgroup BaseExceptionGroup   get_catch_handlers python get_catch_handlers - MappingtypeBaseException  IterabletypeBaseException, CallableBaseExceptionGroupAny, Any   http Source httpsgofastmcp.compython-sdkfastmcp-utilities-http  fastmcp.utilities.http  Functions  find_available_port python find_available_port - int  Find an available port by letting the OS assign one.  inspect Source httpsgofastmcp.compython-sdkfastmcp-utilities-inspect  fastmcp.utilities.inspect Utilities for inspecting FastMCP instances.  Classes  ToolInfo Information about a tool.  PromptInfo Information about a prompt.  ResourceInfo Information about a resource.  TemplateInfo Information about a resource template.  FastMCPInfo Information extracted from a FastMCP instance.  json_schema Source httpsgofastmcp.compython-sdkfastmcp-utilities-json_schema  fastmcp.utilities.json_schema  Functions  compress_schema python compress_schemaschema dict, prune_params liststr  None  None, prune_defs bool  True, prune_additional_properties bool  True, prune_titles bool  False - dict  Remove the given parameters from the schema. Args  schema The schema to compress  prune_params List of parameter names to remove from properties  prune_defs Whether to remove unused definitions  prune_additional_properties Whether to remove additionalProperties false  prune_titles Whether to remove title fields from the schema  logging Source httpsgofastmcp.compython-sdkfastmcp-utilities-logging  fastmcp.utilities.logging Logging utilities for FastMCP.  Functions  get_logger python get_loggername str - logging.Logger  Get a logger nested under FastMCP namespace. Args  name the name of the logger, which will be prefixed with FastMCP. Returns  a configured logger instance  configure_logging python configure_logginglevel LiteralDEBUG, INFO, WARNING, ERROR, CRITICAL  int  INFO, logger logging.Logger  None  None, enable_rich_tracebacks bool  True - None  Configure logging for FastMCP. Args  logger the logger to configure  level the log level to use  mcp_config Source httpsgofastmcp.compython-sdkfastmcp-utilities-mcp_config  fastmcp.utilities.mcp_config  Functions  infer_transport_type_from_url python infer_transport_type_from_urlurl str  AnyUrl - Literalhttp, sse  Infer the appropriate transport type from the given URL.  Classes  StdioMCPServer Methods  to_transport python to_transportself - StdioTransport   RemoteMCPServer Methods  to_transport python to_transportself - StreamableHttpTransport  SSETransport   MCPConfig Methods  from_dict python from_dictcls, config dictstr, Any - MCPConfig   openapi Source httpsgofastmcp.compython-sdkfastmcp-utilities-openapi  fastmcp.utilities.openapi  Functions  parse_openapi_to_http_routes python parse_openapi_to_http_routesopenapi_dict dictstr, Any - listHTTPRoute  Parses an OpenAPI schema dictionary into a list of HTTPRoute objects using the openapi-pydantic library. Supports both OpenAPI 3.0.x and 3.1.x versions.  clean_schema_for_display python clean_schema_for_displayschema JsonSchema  None - JsonSchema  None  Clean up a schema dictionary for display by removing internalcomplex fields.  generate_example_from_schema python generate_example_from_schemaschema JsonSchema  None - Any  Generate a simple example value from a JSON schema dictionary. Very basic implementation focusing on types.  format_json_for_description python format_json_for_descriptiondata Any, indent int  2 - str  Formats Python data as a JSON string block for markdown.  format_description_with_responses python format_description_with_responsesbase_description str, responses dictstr, Any, parameters listParameterInfo  None  None, request_body RequestBodyInfo  None  None - str  Formats the base description string with response, parameter, and request body information. Args  base_description The initial description to be formatted.  responses A dictionary of response information, keyed by status code.  parameters A list of parameter information, including path and query parameters. Each parameter includes details such as name, location, whether it is required, and a description.  request_body Information about the request body, including its description, whether it is required, and its content schema. Returns  The formatted description string with additional details about responses, parameters,  and the request body.  Classes  ParameterInfo Represents a single parameter for an HTTP operation in our IR.  RequestBodyInfo Represents the request body for an HTTP operation in our IR.  ResponseInfo Represents response information in our IR.  HTTPRoute Intermediate Representation for a single OpenAPI operation.  OpenAPIParser Unified parser for OpenAPI schemas with generic type parameters to handle both 3.0 and 3.1. Methods  parse python parseself - listHTTPRoute  Parse the OpenAPI schema into HTTP routes.  tests Source httpsgofastmcp.compython-sdkfastmcp-utilities-tests  fastmcp.utilities.tests  Functions  temporary_settings python temporary_settingskwargs Any  Temporarily override FastMCP setting values. Args  kwargs The settings to override, including nested settings.  run_server_in_process python run_server_in_processserver_fn Callable..., None, args, kwargs - Generatorstr, None, None  Context manager that runs a FastMCP server in a separate process and returns the server URL. When the context manager is exited, the server process is killed. Args  server_fn The function that runs a FastMCP server. FastMCP servers are not pickleable, so we need a function that creates and runs one.  args Arguments to pass to the server function.  provide_host_and_port Whether to provide the host and port to the server function as kwargs.  kwargs Keyword arguments to pass to the server function. Returns  The server URL.  types Source httpsgofastmcp.compython-sdkfastmcp-utilities-types  fastmcp.utilities.types Common types used across FastMCP.  Functions  get_cached_typeadapter python get_cached_typeadaptercls T - TypeAdapterT  TypeAdapters are heavy objects, and in an application context wed typically create them once in a global scope and reuse them as often as possible. However, this isnt feasible for user-generated functions. Instead, we use a cache to minimize the cost of creating them as much as possible.  issubclass_safe python issubclass_safecls type, base type - bool  Check if cls is a subclass of base, even if cls is a type variable.  is_class_member_of_type python is_class_member_of_typecls type, base type - bool  Check if cls is a member of base, even if cls is a type variable. Base can be a type, a UnionType, or an Annotated type. Generic types are not considered members e.g. T is not a member of listT.  find_kwarg_by_type python find_kwarg_by_typefn Callable, kwarg_type type - str  None  Find the name of the kwarg that is of type kwarg_type. Includes union types that contain the kwarg_type, as well as Annotated types.  Classes  FastMCPBaseModel Base model for FastMCP models.  Image Helper class for returning images from tools. Methods  to_image_content python to_image_contentself, mime_type str  None  None, annotations Annotations  None  None - ImageContent  Convert to MCP ImageContent.  Audio Helper class for returning audio from tools. Methods  to_audio_content python to_audio_contentself, mime_type str  None  None, annotations Annotations  None  None - AudioContent   File Helper class for returning audio from tools. Methods  to_resource_content python to_resource_contentself, mime_type str  None  None, annotations Annotations  None  None - EmbeddedResource   Bearer Token Authentication Source httpsgofastmcp.comserversauthbearer Secure your FastMCP servers HTTP endpoints by validating JWT Bearer tokens. export const VersionBadge  version   return New in versionversion   Authentication and authorization are only relevant for HTTP-based transports. The MCP specificationhttpsmodelcontextprotocol.iospecification2025-03-26basicauthorization requires servers to implement full OAuth 2.1 authorization flows with dynamic client registration, server metadata discovery, and complete token endpoints. FastMCPs Bearer Token authentication provides a simpler, more practical alternative by directly validating pre-issued JWT tokensideal for service-to-service communication and programmatic environments where full OAuth flows may be impractical, and in accordance with how the MCP ecosystem is pragmatically evolving. However, please note that since it doesnt implement the full OAuth 2.1 flow, this implementation does not strictly comply with the MCP specification. Bearer Token authentication is a common way to secure HTTP-based APIs. In this model, the client sends a token usually a JSON Web Token or JWT in the Authorization header with the Bearer scheme. The server then validates this token to grant or deny access. FastMCP supports Bearer Token authentication for its HTTP-based transports http and sse, allowing you to protect your server from unauthorized access.  Authentication Strategy FastMCP uses asymmetric encryption for token validation, which provides a clean security separation between token issuers and FastMCP servers. This approach means  No shared secrets Your FastMCP server never needs access to private keys or client secrets  Public key verification The server only needs a public key or JWKS endpoint to verify token signatures  Secure token issuance Tokens are signed by an external service using a private key that never leaves the issuer  Scalable architecture Multiple FastMCP servers can validate tokens without coordinating secrets This design allows you to integrate FastMCP servers into existing authentication infrastructures without compromising security boundaries.  Configuration To enable Bearer Token validation on your FastMCP server, use the BearerAuthProvider class. This provider validates incoming JWTs by verifying signatures, checking expiration, and optionally validating claims. The BearerAuthProvider validates tokens it does not issue them or implement any part of an OAuth flow. Youll need to generate tokens separately, either using FastMCP utilities or an external Identity Provider IdP or OAuth 2.1 Authorization Server.  Basic Setup To configure bearer token authentication, instantiate a BearerAuthProvider instance and pass it to the auth parameter of the FastMCP instance. The BearerAuthProvider requires either a static public key or a JWKS URI but not both! in order to verify the tokens signature. All other parameters are optional -- if they are provided, they will be used as additional validation criteria. python 2, 10 from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider auth  BearerAuthProvider jwks_urihttpsmy-identity-provider.com.well-knownjwks.json, issuerhttpsmy-identity-provider.com, audiencemy-mcp-server  mcp  FastMCPnameMy MCP Server, authauth   Configuration Parameters RSA public key in PEM format for static key validation. Required if jwks_uri is not provided URL for JSON Web Key Set endpoint. Required if public_key is not provided Expected JWT iss claim value Expected JWT aud claim value Global scopes required for all requests  Public Key If you have a public key in PEM format, you can provide it to the BearerAuthProvider as a string. python 12 from fastmcp.server.auth import BearerAuthProvider import inspect public_key_pem  inspect.cleandoc  -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy... -----END PUBLIC KEY-----   auth  BearerAuthProviderpublic_keypublic_key_pem   JWKS URI python provider  BearerAuthProvider jwks_urihttpsidp.example.com.well-knownjwks.json   JWKS is recommended for production as it supports automatic key rotation and multiple signing keys.  Generating Tokens For development and testing, FastMCP provides the RSAKeyPair utility class to generate tokens without needing an external OAuth provider. The RSAKeyPair utility is intended for development and testing only. For production, use a proper OAuth 2.1 Authorization Server or Identity Provider.  Basic Token Generation python from fastmcp import FastMCP from fastmcp.server.auth import BearerAuthProvider from fastmcp.server.auth.providers.bearer import RSAKeyPair  Generate a new key pair key_pair  RSAKeyPair.generate  Configure the auth provider with the public key auth  BearerAuthProvider public_keykey_pair.public_key, issuerhttpsdev.example.com, audiencemy-dev-server  mcp  FastMCPnameDevelopment Server, authauth  Generate a token for testing token  key_pair.create_token subjectdev-user, issuerhttpsdev.example.com, audiencemy-dev-server, scopesread, write  printfTest token token   Token Creation Parameters The create_token method accepts these parameters JWT subject claim usually user ID JWT issuer claim JWT audience claim OAuth scopes to include Token expiration time in seconds Extra claims to include in the token Key ID for JWKS lookup  Accessing Token Claims Once authenticated, your tools, resources, or prompts can access token information using the get_access_token dependency function python from fastmcp import FastMCP, Context, ToolError from fastmcp.server.dependencies import get_access_token, AccessToken mcp.tool async def get_my_datactx Context - dict access_token AccessToken  get_access_token user_id  access_token.client_id  From JWT sub or client_id claim user_scopes  access_token.scopes if dataread_sensitive not in user_scopes raise ToolErrorInsufficient permissions dataread_sensitive scope required. return  user user_id, sensitive_data fPrivate data for user_id, granted_scopes user_scopes    AccessToken Properties The raw JWT string Authenticated principal identifier Granted scopes Token expiration timestamp  Server Composition Source httpsgofastmcp.comserverscomposition Combine multiple FastMCP servers into a single, larger application using mounting and importing. export const VersionBadge  version   return New in versionversion   As your MCP applications grow, you might want to organize your tools, resources, and prompts into logical modules or reuse existing server components. FastMCP supports composition through two methods  import_server For a one-time copy of components with prefixing static composition.  mount For creating a live link where the main server delegates requests to the subserver dynamic composition.  Why Compose Servers?  Modularity Break down large applications into smaller, focused servers e.g., a WeatherServer, a DatabaseServer, a CalendarServer.  Reusability Create common utility servers e.g., a TextProcessingServer and mount them wherever needed.  Teamwork Different teams can work on separate FastMCP servers that are later combined.  Organization Keep related functionality grouped together logically.  Importing vs Mounting The choice of importing or mounting depends on your use case and requirements.  Feature  Importing  Mounting   --------------------  --------------------------------------------  ------------------------------------------   Method  FastMCP.import_serverserver, prefixNone  FastMCP.mountserver, prefixNone   Composition Type  One-time copy static  Live link dynamic   Updates  Changes to subserver NOT reflected  Changes to subserver immediately reflected   Prefix  Optional - omit for original names  Optional - omit for original names   Best For  Bundling finalized components  Modular runtime composition   Proxy Servers FastMCP supports MCP proxyingserversproxy, which allows you to mirror a local or remote server in a local FastMCP instance. Proxies are fully compatible with both importing and mounting. You can also create proxies from configuration dictionaries that follow the MCPConfig schema, which is useful for quickly connecting to one or more remote servers. See the Proxy Servers documentationserversproxyconfiguration-based-proxies for details on configuration-based proxying. Note that MCPConfig follows an emerging standard and its format may evolve over time.  Importing Static Composition The import_server method copies all components tools, resources, templates, prompts from one FastMCP instance the subserver into another the main server. An optional prefix can be provided to avoid naming conflicts. If no prefix is provided, components are imported without modification. When multiple servers are imported with the same prefix or no prefix, the most recently imported servers components take precedence. python from fastmcp import FastMCP import asyncio  Define subservers weather_mcp  FastMCPnameWeatherService weather_mcp.tool def get_forecastcity str - dict Get weather forecast. return city city, forecast Sunny weather_mcp.resourcedatacitiessupported def list_supported_cities - liststr List cities with weather support. return London, Paris, Tokyo  Define main server main_mcp  FastMCPnameMainApp  Import subserver async def setup await main_mcp.import_serverweather_mcp, prefixweather  Result main_mcp now contains prefixed components  - Tool weather_get_forecast  - Resource dataweathercitiessupported if __name__  __main__ asyncio.runsetup main_mcp.run   How Importing Works When you call await main_mcp.import_serversubserver, prefixwhatever 1. Tools All tools from subserver are added to main_mcp with names prefixed using prefix_.  subserver.toolnamemy_tool becomes main_mcp.toolnameprefix_my_tool. 2. Resources All resources are added with URIs prefixed in the format protocolprefixpath.  subserver.resourceuridatainfo becomes main_mcp.resourceuridataprefixinfo. 3. Resource Templates Templates are prefixed similarly to resources.  subserver.resourceuridataid becomes main_mcp.resourceuridataprefixid. 4. Prompts All prompts are added with names prefixed using prefix_.  subserver.promptnamemy_prompt becomes main_mcp.promptnameprefix_my_prompt. Note that import_server performs a one-time copy of components. Changes made to the subserver after importing will not be reflected in main_mcp. The subservers lifespan context is also not executed by the main server. The prefix parameter is optional. If omitted, components are imported without modification.  Importing Without Prefixes You can also import servers without specifying a prefix, which copies components using their original names python from fastmcp import FastMCP import asyncio  Define subservers weather_mcp  FastMCPnameWeatherService weather_mcp.tool def get_forecastcity str - dict Get weather forecast. return city city, forecast Sunny weather_mcp.resourcedatacitiessupported def list_supported_cities - liststr List cities with weather support. return London, Paris, Tokyo  Define main server main_mcp  FastMCPnameMainApp  Import subserver async def setup  Import without prefix - components keep original names await main_mcp.import_serverweather_mcp  Result main_mcp now contains  - Tool get_forecast original name preserved  - Resource datacitiessupported original URI preserved if __name__  __main__ asyncio.runsetup main_mcp.run   Conflict Resolution When importing multiple servers with the same prefix, or no prefix, components from the most recently imported server take precedence.  Mounting Live Linking The mount method creates a live link between the main_mcp server and the subserver. Instead of copying components, requests for components matching the optional prefix are delegated to the subserver at runtime. If no prefix is provided, the subservers components are accessible without prefixing. When multiple servers are mounted with the same prefix or no prefix, the most recently mounted server takes precedence for conflicting component names. python import asyncio from fastmcp import FastMCP, Client  Define subserver dynamic_mcp  FastMCPnameDynamicService dynamic_mcp.tool def initial_tool Initial tool demonstration. return Initial Tool Exists  Mount subserver synchronous operation main_mcp  FastMCPnameMainAppLive main_mcp.mountdynamic_mcp, prefixdynamic  Add a tool AFTER mounting - it will be accessible through main_mcp dynamic_mcp.tool def added_later Tool added after mounting. return Tool Added Dynamically!  Testing access to mounted tools async def test_dynamic_mount tools  await main_mcp.get_tools printAvailable tools, listtools.keys  Shows dynamic_initial_tool, dynamic_added_later async with Clientmain_mcp as client result  await client.call_tooldynamic_added_later printResult, result0.text  Shows Tool Added Dynamically! if __name__  __main__ asyncio.runtest_dynamic_mount   How Mounting Works When mounting is configured 1. Live Link The parent server establishes a connection to the mounted server. 2. Dynamic Updates Changes to the mounted server are immediately reflected when accessed through the parent. 3. Prefixed Access The parent server uses prefixes to route requests to the mounted server. 4. Delegation Requests for components matching the prefix are delegated to the mounted server at runtime. The same prefixing rules apply as with import_server for naming tools, resources, templates, and prompts. The prefix parameter is optional. If omitted, components are mounted without modification.  Mounting Without Prefixes You can also mount servers without specifying a prefix, which makes components accessible without prefixing. This works identically to importing without prefixesimporting-without-prefixes, including conflict resolutionconflict-resolution.  Direct vs. Proxy Mounting FastMCP supports two mounting modes 1. Direct Mounting default The parent server directly accesses the mounted servers objects in memory.  No client lifecycle events occur on the mounted server  The mounted servers lifespan context is not executed  Communication is handled through direct method calls 2. Proxy Mounting The parent server treats the mounted server as a separate entity and communicates with it through a client interface.  Full client lifecycle events occur on the mounted server  The mounted servers lifespan is executed when a client connects  Communication happens via an in-memory Client transport python  Direct mounting default when no custom lifespan main_mcp.mountapi_server, prefixapi  Proxy mounting preserves full client lifecycle main_mcp.mountapi_server, prefixapi, as_proxyTrue  Mounting without a prefix components accessible without prefixing main_mcp.mountapi_server  FastMCP automatically uses proxy mounting when the mounted server has a custom lifespan, but you can override this behavior with the as_proxy parameter.  Interaction with Proxy Servers When using FastMCP.as_proxy to create a proxy server, mounting that server will always use proxy mounting python  Create a proxy for a remote server remote_proxy  FastMCP.as_proxyClienthttpexample.commcp  Mount the proxy always uses proxy mounting main_server.mountremote_proxy, prefixremote   Resource Prefix Formats When mounting or importing servers, resource URIs are usually prefixed to avoid naming conflicts. FastMCP supports two different formats for resource prefixes  Path Format Default In path format, prefixes are added to the path component of the URI  resourceprefixpathtoresource  This is the default format since FastMCP 2.4. This format is recommended because it avoids issues with URI protocol restrictions like underscores not being allowed in protocol names.  Protocol Format Legacy In protocol format, prefixes are added as part of the protocol  prefixresourcepathtoresource  This was the default format in FastMCP before 2.4. While still supported, its not recommended for new code as it can cause problems with prefix names that arent valid in URI protocols.  Configuring the Prefix Format You can configure the prefix format globally in code python import fastmcp fastmcp.settings.resource_prefix_format  protocol  Or via environment variable bash FASTMCP_RESOURCE_PREFIX_FORMATprotocol  Or per-server python from fastmcp import FastMCP  Create a server that uses legacy protocol format server  FastMCPLegacyServer, resource_prefix_formatprotocol  Create a server that uses new path format server  FastMCPNewServer, resource_prefix_formatpath  When mounting or importing servers, the prefix format of the parent server is used.  MCP Context Source httpsgofastmcp.comserverscontext Access MCP capabilities like logging, progress, and resources within your MCP objects. export const VersionBadge  version   return New in versionversion   When defining FastMCP toolsserverstools, resourcesserversresources, resource templates, or promptsserversprompts, your functions might need to interact with the underlying MCP session or access server capabilities. FastMCP provides the Context object for this purpose.  What Is Context? The Context object provides a clean interface to access MCP features within your functions, including  Logging Send debug, info, warning, and error messages back to the client  Progress Reporting Update the client on the progress of long-running operations  Resource Access Read data from resources registered with the server  LLM Sampling Request the clients LLM to generate text based on provided messages  Request Information Access metadata about the current request  Server Access When needed, access the underlying FastMCP server instance  Accessing the Context  Via Dependency Injection To use the context object within any of your functions, simply add a parameter to your function signature and type-hint it as Context. FastMCP will automatically inject the context instance when your function is called. Key Points  The parameter name e.g., ctx, context doesnt matter, only the type hint Context is important.  The context parameter can be placed anywhere in your functions signature it will not be exposed to MCP clients as a valid parameter.  The context is optional - functions that dont need it can omit the parameter entirely.  Context methods are async, so your function usually needs to be async as well.  The type hint can be a union Context  None or use Annotated and it will still work properly.  Context is only available during a request attempting to use context methods outside a request will raise errors. If you need to debug or call your context methods outside of a request, you can type your variable as Context  NoneNone to avoid missing argument errors.  Tools python from fastmcp import FastMCP, Context mcp  FastMCPnameContextDemo mcp.tool async def process_filefile_uri str, ctx Context - str Processes a file, using context for logging and resource access.  Context is available as the ctx parameter return Processed file   Resources and Templates python mcp.resourceresourceuser-data async def get_user_datactx Context - dict Fetch personalized user data based on the request context.  Context is available as the ctx parameter return user_id example mcp.resourceresourceusersuser_idprofile async def get_user_profileuser_id str, ctx Context - dict Fetch user profile with context-aware logging.  Context is available as the ctx parameter return id user_id   Prompts python mcp.prompt async def data_analysis_requestdataset str, ctx Context - str Generate a request to analyze data with contextual information.  Context is available as the ctx parameter return fPlease analyze the following dataset dataset   Via Dependency Function While the simplest way to access context is through function parameter injection as shown above, there are cases where you need to access the context in code that may not be easy to modify to accept a context parameter, or that is nested deeper within your function calls. FastMCP provides dependency functions that allow you to retrieve the active context from anywhere within a server requests execution flow python 2,9 from fastmcp import FastMCP, Context from fastmcp.server.dependencies import get_context mcp  FastMCPnameDependencyDemo  Utility function that needs context but doesnt receive it as a parameter async def process_datadata listfloat - dict  Get the active context - only works when called within a request ctx  get_context await ctx.infofProcessing lendata data points mcp.tool async def analyze_datasetdataset_name str - dict  Call utility function that uses context internally data  load_datadataset_name await process_datadata  Important Notes  The get_context function should only be used within the context of a server request. Calling it outside of a request will raise a RuntimeError.  The get_context function is server-only and should not be used in client code.  Context Capabilities  Logging Send log messages back to the MCP client. This is useful for debugging and providing visibility into function execution during a request. python mcp.tool async def analyze_datadata listfloat, ctx Context - dict Analyze numerical data with logging. await ctx.debugStarting analysis of numerical data await ctx.infofAnalyzing lendata data points try result  sumdata  lendata await ctx.infofAnalysis complete, average result return average result, count lendata except ZeroDivisionError await ctx.warningEmpty data list provided return error Empty data list except Exception as e await ctx.errorfAnalysis failed stre raise  Available Logging Methods  ctx.debugmessage str Low-level details useful for debugging  ctx.infomessage str General information about execution  ctx.warningmessage str Potential issues that didnt prevent execution  ctx.errormessage str Errors that occurred during execution  ctx.loglevel Literaldebug, info, warning, error, message str, logger_name str  None  None Generic log method supporting custom logger names  Progress Reporting For long-running operations, notify the client about the progress. This allows clients to display progress indicators and provide a better user experience. python mcp.tool async def process_itemsitems liststr, ctx Context - dict Process a list of items with progress updates. total  lenitems results   for i, item in enumerateitems  Report progress as percentage await ctx.report_progressprogressi, totaltotal  Process the item simulated with a sleep await asyncio.sleep0.1 results.appenditem.upper  Report 100 completion await ctx.report_progressprogresstotal, totaltotal return processed lenresults, results results  Method signature  ctx.report_progressprogress float, total float  None  None  progress Current progress value e.g., 24  total Optional total value e.g., 100. If provided, clients may interpret this as a percentage. Progress reporting requires the client to have sent a progressToken in the initial request. If the client doesnt support progress reporting, these calls will have no effect.  Resource Access Read data from resources registered with your FastMCP server. This allows functions to access files, configuration, or dynamically generated content. python mcp.tool async def summarize_documentdocument_uri str, ctx Context - str Summarize a document by its resource URI.  Read the document content content_list  await ctx.read_resourcedocument_uri if not content_list return Document is empty document_text  content_list0.content  Example Generate a simple summary length-based words  document_text.split total_words  lenwords await ctx.infofDocument has total_words words  Return a simple summary if total_words  100 summary   .joinwords100  ... return fSummary total_words words total summary else return fFull document total_words words document_text  Method signature  ctx.read_resourceuri str  AnyUrl - listReadResourceContents  uri The resource URI to read  Returns a list of resource content parts usually containing just one item The returned content is typically accessed via content_list0.content and can be text or binary data depending on the resource.  LLM Sampling Request the clients LLM to generate text based on provided messages. This is useful when your function needs to leverage the LLMs capabilities to process data or generate responses. python mcp.tool async def analyze_sentimenttext str, ctx Context - dict Analyze the sentiment of a text using the clients LLM.  Create a sampling prompt asking for sentiment analysis prompt  fAnalyze the sentiment of the following text as positive, negative, or neutral. Just output a single word - positive, negative, or neutral. Text to analyze text  Send the sampling request to the clients LLM provide a hint for the model you want to use response  await ctx.sampleprompt, model_preferencesclaude-3-sonnet  Process the LLMs response sentiment  response.text.strip.lower  Map to standard sentiment values if positive in sentiment sentiment  positive elif negative in sentiment sentiment  negative else sentiment  neutral return text text, sentiment sentiment  Method signature  ctx.samplemessages str  liststr  SamplingMessage, system_prompt str  None  None, temperature float  None  None, max_tokens int  None  None, model_preferences ModelPreferences  str  liststr  None  None - TextContent  ImageContent  messages A string or list of stringsmessage objects to send to the LLM  system_prompt Optional system prompt to guide the LLMs behavior  temperature Optional sampling temperature controls randomness  max_tokens Optional maximum number of tokens to generate defaults to 512  model_preferences Optional model selection preferences e.g., a model hint string, list of hints, or a ModelPreferences object  Returns the LLMs response as TextContent or ImageContent When providing a simple string, its treated as a user message. For more complex scenarios, you can provide a list of messages with different roles. python mcp.tool async def generate_exampleconcept str, ctx Context - str Generate a Python code example for a given concept.  Using a system prompt and a user message response  await ctx.sample messagesfWrite a simple Python code example demonstrating concept., system_promptYou are an expert Python programmer. Provide concise, working code examples without explanations., temperature0.7, max_tokens300  code_example  response.text return fpythonncode_examplen  See Client Samplingclientsclientllm-sampling for more details on how clients handle these requests.  Request Information Access metadata about the current request and client. python mcp.tool async def request_infoctx Context - dict Return information about the current request. return  request_id ctx.request_id, client_id ctx.client_id or Unknown client   Available Properties  ctx.request_id - str Get the unique ID for the current MCP request  ctx.client_id - str  None Get the ID of the client making the request, if provided during initialization  ctx.session_id - str  None Get the MCP session ID for session-based data sharing HTTP transports only  Advanced Access  FastMCP Server and Sessions python mcp.tool async def advanced_toolctx Context - str Demonstrate advanced context access.  Access the FastMCP server instance server_name  ctx.fastmcp.name  Low-level session access rarely needed session  ctx.session request_context  ctx.request_context return fServer server_name   HTTP Requests The ctx.get_http_request method is deprecated and will be removed in a future version. Please use the get_http_request dependency function instead. See the HTTP Requests patternpatternshttp-requests for more details. For web applications, you can access the underlying HTTP request python mcp.tool async def handle_web_requestctx Context - dict Access HTTP request information from the Starlette request. request  ctx.get_http_request  Access HTTP headers, query parameters, etc. user_agent  request.headers.getuser-agent, Unknown client_ip  request.client.host if request.client else Unknown return  user_agent user_agent, client_ip client_ip, path request.url.path,    Advanced Properties Reference  ctx.fastmcp - FastMCP Access the server instance the context belongs to  ctx.session Access the raw mcp.server.session.ServerSession object  ctx.request_context Access the raw mcp.shared.context.RequestContext object Direct use of session or request_context requires understanding the low-level MCP Python SDK and may be less stable than using the methods provided directly on the Context object.  MCP Middleware Source httpsgofastmcp.comserversmiddleware Add cross-cutting functionality to your MCP server with middleware that can inspect, modify, and respond to all MCP requests and responses. export const VersionBadge  version   return New in versionversion   MCP middleware is a powerful concept that allows you to add cross-cutting functionality to your FastMCP server. Unlike traditional web middleware, MCP middleware is designed specifically for the Model Context Protocol, providing hooks for different types of MCP operations like tool calls, resource reads, and prompt requests. MCP middleware is a FastMCP-specific concept and is not part of the official MCP protocol specification. This middleware system is designed to work with FastMCP servers and may not be compatible with other MCP implementations. MCP middleware is a brand new concept and may be subject to breaking changes in future versions.  What is MCP Middleware? MCP middleware lets you intercept and modify MCP requests and responses as they flow through your server. Think of it as a pipeline where each piece of middleware can inspect whats happening, make changes, and then pass control to the next middleware in the chain. Common use cases for MCP middleware include  Authentication and Authorization Verify client permissions before executing operations  Logging and Monitoring Track usage patterns and performance metrics  Rate Limiting Control request frequency per client or operation type  RequestResponse Transformation Modify data before it reaches tools or after it leaves  Caching Store frequently requested data to improve performance  Error Handling Provide consistent error responses across your server  How Middleware Works FastMCP middleware operates on a pipeline model. When a request comes in, it flows through your middleware in the order they were added to the server. Each middleware can 1. Inspect the incoming request and its context 2. Modify the request before passing it to the next middleware or handler 3. Execute the next middlewarehandler in the chain by calling call_next 4. Inspect and modify the response before returning it 5. Handle errors that occur during processing The key insight is that middleware forms a chain where each piece decides whether to continue processing or stop the chain entirely. If youre familiar with ASGI middleware, the basic structure of FastMCP middleware will feel familiar. At its core, middleware is a callable class that receives a context object containing information about the current JSON-RPC message and a handler function to continue the middleware chain. Its important to understand that MCP operates on the JSON-RPC specificationhttpsspec.modelcontextprotocol.iospecificationbasictransports. While FastMCP presents requests and responses in a familiar way, these are fundamentally JSON-RPC messages, not HTTP requestresponse pairs like you might be used to in web applications. FastMCP middleware works with all transport typesclientstransports, including local stdio transport and HTTP transports, though not all middleware implementations are compatible across all transports e.g., middleware that inspects HTTP headers wont work with stdio transport. The most fundamental way to implement middleware is by overriding the __call__ method on the Middleware base class python from fastmcp.server.middleware import Middleware, MiddlewareContext class RawMiddlewareMiddleware async def __call__self, context MiddlewareContext, call_next  This method receives ALL messages regardless of type printfRaw middleware processing context.method result  await call_nextcontext printfRaw middleware completed context.method return result  This gives you complete control over every message that flows through your server, but requires you to handle all message types manually.  Middleware Hooks To make it easier for users to target specific types of messages, FastMCP middleware provides a variety of specialized hooks. Instead of implementing the raw __call__ method, you can override specific hook methods that are called only for certain types of operations, allowing you to target exactly the level of specificity you need for your middleware logic.  Hook Hierarchy and Execution Order FastMCP provides multiple hooks that are called with varying levels of specificity. Understanding this hierarchy is crucial for effective middleware design. When a request comes in, multiple hooks may be called for the same request, going from general to specific 1. on_message - Called for ALL MCP messages both requests and notifications 2. on_request or on_notification - Called based on the message type 3. Operation-specific hooks - Called for specific MCP operations like on_call_tool For example, when a client calls a tool, your middleware will receive three separate hook calls 1. First on_message because its any MCP message 2. Second on_request because tool calls expect responses 3. Third on_call_tool because its specifically a tool execution This hierarchy allows you to target your middleware logic with the right level of specificity. Use on_message for broad concerns like logging, on_request for authentication, and on_call_tool for tool-specific logic like performance monitoring.  Available Hooks  on_message Called for all MCP messages requests and notifications  on_request Called specifically for MCP requests that expect responses  on_notification Called specifically for MCP notifications fire-and-forget  on_call_tool Called when tools are being executed  on_read_resource Called when resources are being read  on_get_prompt Called when prompts are being retrieved  on_list_tools Called when listing available tools  on_list_resources Called when listing available resources  on_list_resource_templates Called when listing resource templates  on_list_prompts Called when listing available prompts  Component Access in Middleware Understanding how to access component information tools, resources, prompts in middleware is crucial for building powerful middleware functionality. The access patterns differ significantly between listing operations and execution operations.  Listing Operations vs Execution Operations FastMCP middleware handles two types of operations differently Listing Operations on_list_tools, on_list_resources, on_list_prompts, etc.  Middleware receives FastMCP component objects with full metadata  These objects include FastMCP-specific properties like tags that arent part of the MCP specification  The result contains complete component information before its converted to MCP format  Tags and other metadata are stripped when finally returned to the MCP client Execution Operations on_call_tool, on_read_resource, on_get_prompt  Middleware runs before the component is executed  The middleware result is either the execution result or an error if the component wasnt found  Component metadata isnt directly available in the hook parameters  Accessing Component Metadata During Execution If you need to check component properties like tags during execution operations, use the FastMCP server instance available through the context python from fastmcp.server.middleware import Middleware, MiddlewareContext from fastmcp.exceptions import ToolError class TagBasedMiddlewareMiddleware async def on_call_toolself, context MiddlewareContext, call_next  Access the tool object to check its metadata if context.fastmcp_context try tool  await context.fastmcp_context.fastmcp.get_toolcontext.message.name  Check if this tool has a private tag if private in tool.tags raise ToolErrorAccess denied private tool  Check if tool is enabled if not tool.enabled raise ToolErrorTool is currently disabled except Exception  Tool not found or other error - let execution continue  and handle the error naturally pass return await call_nextcontext  The same pattern works for resources and prompts python from fastmcp.server.middleware import Middleware, MiddlewareContext from fastmcp.exceptions import ResourceError, PromptError class ComponentAccessMiddlewareMiddleware async def on_read_resourceself, context MiddlewareContext, call_next if context.fastmcp_context try resource  await context.fastmcp_context.fastmcp.get_resourcecontext.message.uri if restricted in resource.tags raise ResourceErrorAccess denied restricted resource except Exception pass return await call_nextcontext async def on_get_promptself, context MiddlewareContext, call_next if context.fastmcp_context try prompt  await context.fastmcp_context.fastmcp.get_promptcontext.message.name if not prompt.enabled raise PromptErrorPrompt is currently disabled except Exception pass return await call_nextcontext   Working with Listing Results For listing operations, you can inspect and modify the FastMCP components directly python from fastmcp.server.middleware import Middleware, MiddlewareContext, ListToolsResult class ListingFilterMiddlewareMiddleware async def on_list_toolsself, context MiddlewareContext, call_next result  await call_nextcontext  Filter out tools with private tag filtered_tools   name tool for name, tool in result.tools.items if private not in tool.tags   Return modified result return ListToolsResulttoolsfiltered_tools  This filtering happens before the components are converted to MCP format and returned to the client, so the tags which are FastMCP-specific are naturally stripped in the final response.  Anatomy of a Hook Every middleware hook follows the same pattern. Lets examine the on_message hook to understand the structure python async def on_messageself, context MiddlewareContext, call_next  1. Pre-processing Inspect and optionally modify the request printfProcessing context.method  2. Chain continuation Call the next middlewarehandler result  await call_nextcontext  3. Post-processing Inspect and optionally modify the response printfCompleted context.method  4. Return the result potentially modified return result   Hook Parameters Every hook receives two parameters 1. context MiddlewareContext - Contains information about the current request  context.method - The MCP method name e.g., toolscall  context.source - Where the request came from client or server  context.type - Message type request or notification  context.message - The MCP message data  context.timestamp - When the request was received  context.fastmcp_context - FastMCP Context object if available 2. call_next - A function that continues the middleware chain. You must call this to proceed, unless you want to stop processing entirely.  Control Flow You have complete control over the request flow  Continue processing Call await call_nextcontext to proceed  Modify the request Change the context before calling call_next  Modify the response Change the result after calling call_next  Stop the chain Dont call call_next rarely needed  Handle errors Wrap call_next in trycatch blocks  Creating Middleware FastMCP middleware is implemented by subclassing the Middleware base class and overriding the hooks you need. You only need to implement the hooks that are relevant to your use case. python from fastmcp import FastMCP from fastmcp.server.middleware import Middleware, MiddlewareContext class LoggingMiddlewareMiddleware Middleware that logs all MCP operations. async def on_messageself, context MiddlewareContext, call_next Called for all MCP messages. printfProcessing context.method from context.source result  await call_nextcontext printfCompleted context.method return result  Add middleware to your server mcp  FastMCPMyServer mcp.add_middlewareLoggingMiddleware  This creates a basic logging middleware that will print information about every request that flows through your server.  Adding Middleware to Your Server  Single Middleware Adding middleware to your server is straightforward python mcp  FastMCPMyServer mcp.add_middlewareLoggingMiddleware   Multiple Middleware Middleware executes in the order its added to the server. The first middleware added runs first on the way in, and last on the way out python mcp  FastMCPMyServer mcp.add_middlewareAuthenticationMiddlewaresecret-token mcp.add_middlewarePerformanceMiddleware mcp.add_middlewareLoggingMiddleware  This creates the following execution flow 1. AuthenticationMiddleware pre-processing 2. PerformanceMiddleware pre-processing 3. LoggingMiddleware pre-processing 4. Actual toolresource handler 5. LoggingMiddleware post-processing 6. PerformanceMiddleware post-processing 7. AuthenticationMiddleware post-processing  Server Composition and Middleware When using Server Compositionserverscomposition with mount or import_server, middleware behavior follows these rules 1. Parent server middleware runs for all requests, including those routed to mounted servers 2. Mounted server middleware only runs for requests handled by that specific server 3. Middleware order is preserved within each server This allows you to create layered middleware architectures where parent servers handle cross-cutting concerns like authentication, while child servers focus on domain-specific middleware. python  Parent server with middleware parent  FastMCPParent parent.add_middlewareAuthenticationMiddlewaretoken  Child server with its own middleware child  FastMCPChild child.add_middlewareLoggingMiddleware child.tool def child_tool - str return from child  Mount the child server parent.mountchild, prefixchild  When a client calls child_tool, the request will flow through the parents authentication middleware first, then route to the child server where it will go through the childs logging middleware.  Built-in Middleware Examples FastMCP includes several middleware implementations that demonstrate best practices and provide immediately useful functionality. Lets explore how each type works by building simplified versions, then see how to use the full implementations.  Timing Middleware Performance monitoring is essential for understanding your servers behavior and identifying bottlenecks. FastMCP includes timing middleware at fastmcp.server.middleware.timing. Heres an example of how it works python import time from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleTimingMiddlewareMiddleware async def on_requestself, context MiddlewareContext, call_next start_time  time.perf_counter try result  await call_nextcontext duration_ms  time.perf_counter - start_time  1000 printfRequest context.method completed in duration_ms.2fms return result except Exception as e duration_ms  time.perf_counter - start_time  1000 printfRequest context.method failed after duration_ms.2fms e raise  To use the full version with proper logging and configuration python from fastmcp.server.middleware.timing import  TimingMiddleware, DetailedTimingMiddleware   Basic timing for all requests mcp.add_middlewareTimingMiddleware  Detailed per-operation timing tools, resources, prompts mcp.add_middlewareDetailedTimingMiddleware  The built-in versions include custom logger support, proper formatting, and DetailedTimingMiddleware provides operation-specific hooks like on_call_tool and on_read_resource for granular timing.  Logging Middleware Request and response logging is crucial for debugging, monitoring, and understanding usage patterns in your MCP server. FastMCP provides comprehensive logging middleware at fastmcp.server.middleware.logging. Heres an example of how it works python from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleLoggingMiddlewareMiddleware async def on_messageself, context MiddlewareContext, call_next printfProcessing context.method from context.source try result  await call_nextcontext printfCompleted context.method return result except Exception as e printfFailed context.method e raise  To use the full versions with advanced features python from fastmcp.server.middleware.logging import  LoggingMiddleware, StructuredLoggingMiddleware   Human-readable logging with payload support mcp.add_middlewareLoggingMiddleware include_payloadsTrue, max_payload_length1000   JSON-structured logging for log aggregation tools mcp.add_middlewareStructuredLoggingMiddlewareinclude_payloadsTrue  The built-in versions include payload logging, structured JSON output, custom logger support, payload size limits, and operation-specific hooks for granular control.  Rate Limiting Middleware Rate limiting is essential for protecting your server from abuse, ensuring fair resource usage, and maintaining performance under load. FastMCP includes sophisticated rate limiting middleware at fastmcp.server.middleware.rate_limiting. Heres an example of how it works python import time from collections import defaultdict from fastmcp.server.middleware import Middleware, MiddlewareContext from mcp import McpError from mcp.types import ErrorData class SimpleRateLimitMiddlewareMiddleware def __init__self, requests_per_minute int  60 self.requests_per_minute  requests_per_minute self.client_requests  defaultdictlist async def on_requestself, context MiddlewareContext, call_next current_time  time.time client_id  default  In practice, extract from headers or context  Clean old requests and check limit cutoff_time  current_time - 60 self.client_requestsclient_id   req_time for req_time in self.client_requestsclient_id if req_time  cutoff_time  if lenself.client_requestsclient_id  self.requests_per_minute raise McpErrorErrorDatacode-32000, messageRate limit exceeded self.client_requestsclient_id.appendcurrent_time return await call_nextcontext  To use the full versions with advanced algorithms python from fastmcp.server.middleware.rate_limiting import  RateLimitingMiddleware, SlidingWindowRateLimitingMiddleware   Token bucket rate limiting allows controlled bursts mcp.add_middlewareRateLimitingMiddleware max_requests_per_second10.0, burst_capacity20   Sliding window rate limiting precise time-based control mcp.add_middlewareSlidingWindowRateLimitingMiddleware max_requests100, window_minutes1   The built-in versions include token bucket algorithms, per-client identification, global rate limiting, and async-safe implementations with configurable client identification functions.  Error Handling Middleware Consistent error handling and recovery is critical for robust MCP servers. FastMCP provides comprehensive error handling middleware at fastmcp.server.middleware.error_handling. Heres an example of how it works python import logging from fastmcp.server.middleware import Middleware, MiddlewareContext class SimpleErrorHandlingMiddlewareMiddleware def __init__self self.logger  logging.getLoggererrors self.error_counts   async def on_messageself, context MiddlewareContext, call_next try return await call_nextcontext except Exception as error  Log the error and track statistics error_key  ftypeerror.__name__context.method self.error_countserror_key  self.error_counts.geterror_key, 0  1 self.logger.errorfError in context.method typeerror.__name__ error raise  To use the full versions with advanced features python from fastmcp.server.middleware.error_handling import  ErrorHandlingMiddleware, RetryMiddleware   Comprehensive error logging and transformation mcp.add_middlewareErrorHandlingMiddleware include_tracebackTrue, transform_errorsTrue, error_callbackmy_error_callback   Automatic retry with exponential backoff mcp.add_middlewareRetryMiddleware max_retries3, retry_exceptionsConnectionError, TimeoutError   The built-in versions include error transformation, custom callbacks, configurable retry logic, and proper MCP error formatting.  Combining Middleware These middleware work together seamlessly python from fastmcp import FastMCP from fastmcp.server.middleware.timing import TimingMiddleware from fastmcp.server.middleware.logging import LoggingMiddleware from fastmcp.server.middleware.rate_limiting import RateLimitingMiddleware from fastmcp.server.middleware.error_handling import ErrorHandlingMiddleware mcp  FastMCPProduction Server  Add middleware in logical order mcp.add_middlewareErrorHandlingMiddleware  Handle errors first mcp.add_middlewareRateLimitingMiddlewaremax_requests_per_second50 mcp.add_middlewareTimingMiddleware  Time actual execution mcp.add_middlewareLoggingMiddleware  Log everything mcp.tool def my_tooldata str - str return fProcessed data  This configuration provides comprehensive monitoring, protection, and observability for your MCP server.  Custom Middleware Example You can also create custom middleware by extending the base class python from fastmcp.server.middleware import Middleware, MiddlewareContext class CustomHeaderMiddlewareMiddleware async def on_requestself, context MiddlewareContext, call_next  Add custom logic here printfProcessing context.method result  await call_nextcontext printfCompleted context.method return result mcp.add_middlewareCustomHeaderMiddleware   OpenAPI Integration Source httpsgofastmcp.comserversopenapi Generate MCP servers from OpenAPI specs and FastAPI apps export const VersionBadge  version   return New in versionversion   FastMCP can automatically generate an MCP server from an OpenAPI specification or FastAPI app. Instead of manually creating tools and resources, you provide an OpenAPI spec and FastMCP intelligently converts your API endpoints into the appropriate MCP components.  Quick Start To convert an OpenAPI specification to an MCP server, you can use the FastMCP.from_openapi class method. This method takes an OpenAPI specification and an async HTTPX client that can be used to make requests to the API, and returns an MCP server. Heres an example python 11-15 import httpx from fastmcp import FastMCP  Create an HTTP client for your API client  httpx.AsyncClientbase_urlhttpsapi.example.com  Load your OpenAPI spec openapi_spec  httpx.gethttpsapi.example.comopenapi.json.json  Create the MCP server mcp  FastMCP.from_openapi openapi_specopenapi_spec, clientclient, nameMy API Server  if __name__  __main__ mcp.run  Thats it! Your entire API is now available as an MCP server. Clients can discover and interact with your API endpoints through the MCP protocol, with full schema validation and type safety.  Route Mapping By default, FastMCP converts every endpoint in your OpenAPI specification into an MCP Tool. This provides a simple, predictable starting point that ensures all your APIs functionality is immediately available to the vast majority of LLM clients which only support MCP tools. While this is a pragmatic default for maximum compatibility, you can easily customize this behavior. Internally, FastMCP uses an ordered list of RouteMap objects to determine how to map OpenAPI routes to various MCP component types. Each RouteMap specifies a combination of methods, patterns, and tags, as well as a corresponding MCP component type. Each OpenAPI route is checked against each RouteMap in order, and the first one that matches every criteria is used to determine its converted MCP type. A special type, EXCLUDE, can be used to exclude routes from the MCP server entirely.  Methods HTTP methods to match e.g. GET, POST or  for all  Pattern Regex pattern to match the route path e.g. rusers. or r. for all  Tags A set of OpenAPI tags that must all be present. An empty set  means no tag filtering, so the route matches regardless of its tags.  MCP type What MCP component type to create TOOL, RESOURCE, RESOURCE_TEMPLATE, or EXCLUDE  MCP tags A set of custom tags to add to components created from matching routes Here is FastMCPs default rule python from fastmcp.server.openapi import RouteMap, MCPType DEFAULT_ROUTE_MAPPINGS    All routes become tools RouteMapmcp_typeMCPType.TOOL,    Custom Route Maps When creating your FastMCP server, you can customize routing behavior by providing your own list of RouteMap objects. Your custom maps are processed before the default route maps, and routes will be assigned to the first matching custom map. For example, prior to FastMCP 2.8.0, GET requests were automatically mapped to Resource and ResourceTemplate components based on whether they had path parameters. This was changed solely for client compatibility reasons. You can restore this behavior by providing custom route maps python 2, 5-10 from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType  Restore pre-2.8.0 semantic mapping semantic_maps    GET requests with path parameters become ResourceTemplates RouteMapmethodsGET, patternr..., mcp_typeMCPType.RESOURCE_TEMPLATE,  All other GET requests become Resources RouteMapmethodsGET, patternr., mcp_typeMCPType.RESOURCE,  mcp  FastMCP.from_openapi ..., route_mapssemantic_maps,   With these maps, GET requests are handled semantically, and all other methods POST, PUT, etc. will fall through to the default rule and become Tools. Here is a more complete example that uses custom route maps to convert all GET endpoints under analytics to tools while excluding all admin endpoints and all routes tagged internal. All other routes will be handled by the default rules python from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType mcp  FastMCP.from_openapi ..., route_maps  Analytics GET endpoints are tools RouteMap methodsGET, patternranalytics., mcp_typeMCPType.TOOL, ,  Exclude all admin endpoints RouteMap patternradmin., mcp_typeMCPType.EXCLUDE, ,  Exclude all routes tagged internal RouteMap tagsinternal, mcp_typeMCPType.EXCLUDE, , ,   The default route maps are always applied after your custom maps, so you do not have to create route maps for every possible route.  Excluding Routes To exclude routes from the MCP server, use a route map to assign them to MCPType.EXCLUDE. You can use this to remove sensitive or internal routes by targeting them specifically python 7,8 from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType mcp  FastMCP.from_openapi ..., route_maps RouteMappatternradmin., mcp_typeMCPType.EXCLUDE, RouteMaptagsinternal, mcp_typeMCPType.EXCLUDE, ,   Or you can use a catch-all rule to exclude everything that your maps dont handle explicitly python 10 from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType mcp  FastMCP.from_openapi ..., route_maps  custom mapping logic goes here ...,  exclude all remaining routes RouteMapmcp_typeMCPType.EXCLUDE, ,   Using a catch-all exclusion rule will prevent the default route mappings from being applied, since it will match every remaining route. This is useful if you want to explicitly allow-list certain routes.  Advanced Route Mapping For advanced use cases that require more complex logic, you can provide a route_map_fn callable. After the route map logic is applied, this function is called on each matched route and its assigned MCP component type. It can optionally return a different component type to override the mapped assignment. If it returns None, the assigned type is used. In addition to more precise targeting of methods, patterns, and tags, this function can access any additional OpenAPI metadata about the route. The route_map_fn is called on routes that matched MCPType.EXCLUDE in your custom maps, giving you an opportunity to override the exclusion. python from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType, HTTPRoute def custom_route_mapperroute HTTPRoute, mcp_type MCPType - MCPType  None Advanced route type mapping.  Convert all admin routes to tools regardless of HTTP method if admin in route.path return MCPType.TOOL elif internal in route.tags return MCPType.EXCLUDE  Convert user detail routes to templates even if theyre POST elif route.path.startswithusers and route.method  POST return MCPType.RESOURCE_TEMPLATE  Use defaults for all other routes return None mcp  FastMCP.from_openapi ..., route_map_fncustom_route_mapper,    Customizing MCP Components  Tags FastMCP provides several ways to add tags to your MCP components, allowing you to categorize and organize them for better discoverability and filtering. Tags are combined from multiple sources to create the final set of tags on each component.  RouteMap Tags You can add custom tags to components created from specific routes using the mcp_tags parameter in RouteMap. These tags will be applied to all components created from routes that match that particular route map. python 12, 20, 28 from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType mcp  FastMCP.from_openapi ..., route_maps  Add custom tags to all POST endpoints RouteMap methodsPOST, patternr., mcp_typeMCPType.TOOL, mcp_tagswrite-operation, api-mutation ,  Add different tags to detail view endpoints RouteMap methodsGET, patternr..., mcp_typeMCPType.RESOURCE_TEMPLATE, mcp_tagsdetail-view, parameterized ,  Add tags to list endpoints RouteMap methodsGET, patternr., mcp_typeMCPType.RESOURCE, mcp_tagslist-data, collection , ,    Global Tags You can add tags to all components by providing a tags parameter when creating your FastMCP server with from_openapi or from_fastapi. These global tags will be applied to every component created from your OpenAPI specification. python 6 from_openapi from fastmcp import FastMCP mcp  FastMCP.from_openapi openapi_specspec, clientclient, tagsapi-v2, production, external   python 5 from_fastapi from fastmcp import FastMCP mcp  FastMCP.from_fastapi appapp, tagsinternal-api, microservice    Names FastMCP automatically generates names for MCP components based on the OpenAPI specification. By default, it uses the operationId from your OpenAPI spec, up to the first double underscore __. All component names are automatically  Slugified Spaces and special characters are converted to underscores or removed  Truncated Limited to 56 characters maximum to ensure compatibility  Unique If multiple components have the same name, a number is automatically appended to make them unique For more control over component names, you can provide an mcp_names dictionary that maps operationId values to your desired names. The operationId must be exactly as it appears in the OpenAPI spec. The provided name will always be slugified and truncated. python 5-9 from fastmcp import FastMCP mcp  FastMCP.from_openapi ... mcp_names list_users__with_pagination user_list, create_user__admin_required create_user, get_user_details__admin_required user_detail,    Any operationId not found in mcp_names will use the default strategy operationId up to the first __.  Advanced Customization By default, FastMCP creates MCP components using a variety of metadata from the OpenAPI spec, such as incorporating the OpenAPI description into the MCP component description. At times you may want to modify those MCP components in a variety of ways, such as adding LLM-specific instructions or tags. For fine-grained customization, you can provide a mcp_component_fn when creating the MCP server. After each MCP component has been created, this function is called on it and has the opportunity to modify it in-place. Your mcp_component_fn is expected to modify the component in-place, not to return a new component. The result of the function is ignored. python 27 from fastmcp import FastMCP from fastmcp.server.openapi import  HTTPRoute, OpenAPITool, OpenAPIResource, OpenAPIResourceTemplate,  def customize_components route HTTPRoute, component OpenAPITool  OpenAPIResource  OpenAPIResourceTemplate,  - None  Add custom tags to all components component.tags.addopenapi  Customize based on component type if isinstancecomponent, OpenAPITool component.description  f component.description via API if isinstancecomponent, OpenAPIResource component.description  f component.description component.tags.adddata mcp  FastMCP.from_openapi ..., mcp_component_fncustomize_components,    Request Parameter Handling FastMCP intelligently handles different types of parameters in OpenAPI requests  Query Parameters By default, FastMCP only includes query parameters that have non-empty values. Parameters with None values or empty strings are automatically filtered out. python  When calling this tool... await client.call_toolsearch_products,  category electronics,   Included min_price 100,   Included max_price None,   Excluded brand ,   Excluded   The HTTP request will be GET products?categoryelectronicsmin_price100   Path Parameters Path parameters are typically required by REST APIs. FastMCP  Filters out None values  Validates that all required path parameters are provided  Raises clear errors for missing required parameters python   This works await client.call_toolget_user, user_id 123   This raises Missing required path parameters user_id await client.call_toolget_user, user_id None   Array Parameters FastMCP handles array parameters according to OpenAPI specifications  Query arrays Serialized based on the explode parameter default True  Path arrays Serialized as comma-separated values OpenAPI simple style python  Query array with explodetrue default  ?tagsredtagsbluetagsgreen  Query array with explodefalse  ?tagsred,blue,green  Path array always comma-separated  itemsred,blue,green   Headers Header parameters are automatically converted to strings and included in the HTTP request.  Auth If your API requires authentication, configure it on the HTTP client before creating the MCP server python import httpx from fastmcp import FastMCP  Bearer token authentication api_client  httpx.AsyncClient base_urlhttpsapi.example.com, headersAuthorization Bearer YOUR_TOKEN   Create MCP server with authenticated client mcp  FastMCP.from_openapi..., clientapi_client   Timeouts Set a timeout for all API requests python mcp  FastMCP.from_openapi openapi_specspec, clientapi_client, timeout30.0  30 second timeout for all requests    FastAPI Integration FastMCP can directly convert FastAPI applications into MCP servers by extracting their OpenAPI specifications FastMCP does not include FastAPI as a dependency you must install it separately to use this integration. python from fastapi import FastAPI from fastmcp import FastMCP  Your FastAPI app app  FastAPItitleMy API, version1.0.0 app.getitems, tagsitems, operation_idlist_items def list_items return id 1, name Item 1, id 2, name Item 2 app.getitemsitem_id, tagsitems, detail, operation_idget_item def get_itemitem_id int return id item_id, name fItem item_id app.postitems, tagsitems, create, operation_idcreate_item def create_itemname str return id 3, name name  Convert FastAPI app to MCP server mcp  FastMCP.from_fastapiappapp if __name__  __main__ mcp.run  Run as MCP server  Note that operation ids are optional, but are used to create component names. You can also provide custom names, just like with OpenAPI specs. FastMCP servers are not FastAPI apps, even when created from one. To learn how to deploy them as an ASGI app, see the ASGI Integrationdeploymentasgi documentation.  FastAPI Configuration All OpenAPI integration features work with FastAPI apps python from fastmcp.server.openapi import RouteMap, MCPType  Custom route mapping with FastAPI mcp  FastMCP.from_fastapi appapp, nameMy Custom Server, timeout5.0, tagsapi-v1, fastapi,  Global tags for all components mcp_namesoperationId friendly_name,  Custom component names route_maps  Admin endpoints become tools with custom tags RouteMap methods, patternradmin., mcp_typeMCPType.TOOL, mcp_tagsadmin, privileged ,  Internal endpoints are excluded RouteMapmethods, patternr., mcp_typeMCPType.EXCLUDE, tagsinternal, , route_map_fnmy_route_mapper, mcp_component_fnmy_component_customizer, mcp_names get_user_details_users__user_id__get get_user_details,     FastAPI Benefits  Zero code duplication Reuse existing FastAPI endpoints  Schema inheritance Pydantic models and validation are preserved  ASGI transport Direct in-memory communication no HTTP overhead  Full FastAPI features Dependencies, middleware, authentication all work  Prompts Source httpsgofastmcp.comserversprompts Create reusable, parameterized prompt templates for MCP clients. export const VersionBadge  version   return New in versionversion   Prompts are reusable message templates that help LLMs generate structured, purposeful responses. FastMCP simplifies defining these templates, primarily using the mcp.prompt decorator.  What Are Prompts? Prompts provide parameterized message templates for LLMs. When a client requests a prompt 1. FastMCP finds the corresponding prompt definition. 2. If it has parameters, they are validated against your function signature. 3. Your function executes with the validated inputs. 4. The generated messages are returned to the LLM to guide its response. This allows you to define consistent, reusable templates that LLMs can use across different clients and contexts.  Prompts  The prompt Decorator The most common way to define a prompt is by decorating a Python function. The decorator uses the function name as the prompts identifier. python from fastmcp import FastMCP from fastmcp.prompts.prompt import Message, PromptMessage, TextContent mcp  FastMCPnamePromptServer  Basic prompt returning a string converted to user message automatically mcp.prompt def ask_about_topictopic str - str Generates a user message asking for an explanation of a topic. return fCan you please explain the concept of topic?  Prompt returning a specific message type mcp.prompt def generate_code_requestlanguage str, task_description str - PromptMessage Generates a user message requesting code generation. content  fWrite a language function that performs the following task task_description return PromptMessageroleuser, contentTextContenttypetext, textcontent  Key Concepts  Name By default, the prompt name is taken from the function name.  Parameters The function parameters define the inputs needed to generate the prompt.  Inferred Metadata By default  Prompt Name Taken from the function name ask_about_topic.  Prompt Description Taken from the functions docstring. Functions with args or kwargs are not supported as prompts. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isnt possible with variable argument lists.  Decorator Arguments While FastMCP infers the name and description from your function, you can override these and add additional metadata using arguments to the mcp.prompt decorator python mcp.prompt nameanalyze_data_request,  Custom prompt name descriptionCreates a request to analyze data with specific parameters,  Custom description tagsanalysis, data  Optional categorization tags  def data_analysis_prompt data_uri str  FielddescriptionThe URI of the resource containing the data., analysis_type str  Fielddefaultsummary, descriptionType of analysis.  - str This docstring is ignored when description is provided. return fPlease perform a analysis_type analysis on the data found at data_uri.  Sets the explicit prompt name exposed via MCP. If not provided, uses the function name Provides the description exposed via MCP. If set, the functions docstring is ignored for this purpose A set of strings used to categorize the prompt. Clients might use tags to filter or group available prompts A boolean to enable or disable the prompt. See Disabling Promptsdisabling-prompts for more information  Argument Types The MCP specification requires that all prompt arguments be passed as strings, but FastMCP allows you to use typed annotations for better developer experience. When you use complex types like listint or dictstr, str, FastMCP 1. Automatically converts string arguments from MCP clients to the expected types 2. Generates helpful descriptions showing the exact JSON string format needed 3. Preserves direct usage - you can still call prompts with properly typed arguments Since the MCP specification only allows string arguments, clients need to know what string format to use for complex types. FastMCP solves this by automatically enhancing the argument descriptions with JSON schema information, making it clear to both humans and LLMs how to format their arguments. python Python Code mcp.prompt def analyze_data numbers listint, metadata dictstr, str, threshold float  - str Analyze numerical data. avg  sumnumbers  lennumbers return fAverage avg, above threshold avg  threshold  json Resulting MCP Prompt  name analyze_data, description Analyze numerical data., arguments   name numbers, description Provide as a JSON string matching the following schema itemstypeinteger,typearray, required true ,  name metadata, description Provide as a JSON string matching the following schema additionalPropertiestypestring,typeobject, required true ,  name threshold, description Provide as a JSON string matching the following schema typenumber, required true     MCP clients will call this prompt with string arguments json  numbers 1, 2, 3, 4, 5, metadata source api, version 1.0, threshold 2.5   But you can still call it directly with proper types python  This also works for direct calls result  await prompt.render numbers 1, 2, 3, 4, 5, metadata source api, version 1.0, threshold 2.5   Keep your type annotations simple when using this feature. Complex nested types or custom classes may not convert reliably from JSON strings. The automatically generated schema descriptions are the only guidance users receive about the expected format. Good choices listint, dictstr, str, float, bool Avoid Complex Pydantic models, deeply nested structures, custom classes  Return Values FastMCP intelligently handles different return types from your prompt function  str Automatically converted to a single PromptMessage.  PromptMessage Used directly as provided. Note a more user-friendly Message constructor is available that can accept raw strings instead of TextContent objects.  listPromptMessage  str Used as a sequence of messages a conversation.  Any If the return type is not one of the above, the return value is attempted to be converted to a string and used as a PromptMessage. python from fastmcp.prompts.prompt import Message mcp.prompt def roleplay_scenariocharacter str, situation str - listMessage Sets up a roleplaying scenario with initial messages. return  MessagefLets roleplay. You are character. The situation is situation, MessageOkay, I understand. I am ready. What happens next?, roleassistant    Required vs. Optional Parameters Parameters in your function signature are considered required unless they have a default value. python mcp.prompt def data_analysis_prompt data_uri str,  Required - no default value analysis_type str  summary,  Optional - has default value include_charts bool  False  Optional - has default value  - str Creates a request to analyze data with specific parameters. prompt  fPlease perform a analysis_type analysis on the data found at data_uri. if include_charts prompt   Include relevant charts and visualizations. return prompt  In this example, the client must provide data_uri. If analysis_type or include_charts are omitted, their default values will be used.  Disabling Prompts You can control the visibility and availability of prompts by enabling or disabling them. Disabled prompts will not appear in the list of available prompts, and attempting to call a disabled prompt will result in an Unknown prompt error. By default, all prompts are enabled. You can disable a prompt upon creation using the enabled parameter in the decorator python mcp.promptenabledFalse def experimental_prompt This prompt is not ready for use. return This is an experimental prompt.  You can also toggle a prompts state programmatically after it has been created python mcp.prompt def seasonal_prompt return Happy Holidays!  Disable and re-enable the prompt seasonal_prompt.disable seasonal_prompt.enable   Asynchronous Prompts FastMCP seamlessly supports both standard def and asynchronous async def functions as prompts. python  Synchronous prompt mcp.prompt def simple_questionquestion str - str Generates a simple question to ask the LLM. return fQuestion question  Asynchronous prompt mcp.prompt async def data_based_promptdata_id str - str Generates a prompt based on data that needs to be fetched.  In a real scenario, you might fetch data from a database or API async with aiohttp.ClientSession as session async with session.getfhttpsapi.example.comdatadata_id as response data  await response.json return fAnalyze this data datacontent  Use async def when your prompt function performs IO operations like network requests, database queries, file IO, or external service calls.  Accessing MCP Context Prompts can access additional MCP information and features through the Context object. To access it, add a parameter to your prompt function with a type annotation of Context python 6 from fastmcp import FastMCP, Context mcp  FastMCPnamePromptServer mcp.prompt async def generate_report_requestreport_type str, ctx Context - str Generates a request for a report. return fPlease create a report_type report. Request ID ctx.request_id  For full documentation on the Context object and all its capabilities, see the Context documentationserverscontext.  Server Behavior  Duplicate Prompts You can configure how the FastMCP server handles attempts to register multiple prompts with the same name. Use the on_duplicate_prompts setting during FastMCP initialization. python from fastmcp import FastMCP mcp  FastMCP namePromptServer, on_duplicate_promptserror  Raise an error if a prompt name is duplicated  mcp.prompt def greeting return Hello, how can I help you today?  This registration attempt will raise a ValueError because  greeting is already registered and the behavior is error.  mcp.prompt  def greeting return Hi there! What can I do for you?  The duplicate behavior options are  warn default Logs a warning, and the new prompt replaces the old one.  error Raises a ValueError, preventing the duplicate registration.  replace Silently replaces the existing prompt with the new one.  ignore Keeps the original prompt and ignores the new registration attempt.  Proxy Servers Source httpsgofastmcp.comserversproxy Use FastMCP to act as an intermediary or change transport for other MCP servers. export const VersionBadge  version   return New in versionversion   FastMCP provides a powerful proxying capability that allows one FastMCP server instance to act as a frontend for another MCP server which could be remote, running on a different transport, or even another FastMCP instance. This is achieved using the FastMCP.as_proxy class method. as_proxy accepts either an existing Client or any argument that can be passed to a Client as its transport parametersuch as another FastMCP instance, a URL to a remote server, or an MCP configuration dictionary.  What is Proxying? Proxying means setting up a FastMCP server that doesnt implement its own tools or resources directly. Instead, when it receives a request like toolscall or resourcesread, it forwards that request to a backend MCP server, receives the response, and then relays that response back to the original client. mermaid sequenceDiagram participant ClientApp as Your Client e.g., Claude Desktop participant FastMCPProxy as FastMCP Proxy Server participant BackendServer as Backend MCP Server e.g., remote SSE ClientApp-FastMCPProxy MCP Request e.g. stdio Note over FastMCPProxy, BackendServer Proxy forwards the request FastMCPProxy-BackendServer MCP Request e.g. sse BackendServer--FastMCPProxy MCP Response e.g. sse Note over ClientApp, FastMCPProxy Proxy relays the response FastMCPProxy--ClientApp MCP Response e.g. stdio   Use Cases  Transport Bridging Expose a server running on one transport e.g., a remote SSE server via a different transport e.g., local Stdio for Claude Desktop.  Adding Functionality Insert a layer in front of an existing server to add caching, logging, authentication, or modify requestsresponses though direct modification requires subclassing FastMCPProxy.  Security Boundary Use the proxy as a controlled gateway to an internal server.  Simplifying Client Configuration Provide a single, stable endpoint the proxy even if the backend servers location or transport changes.  Creating a Proxy The easiest way to create a proxy is using the FastMCP.as_proxy class method. This creates a standard FastMCP server that forwards requests to another MCP server. python from fastmcp import FastMCP  Provide the backend in any form accepted by Client proxy_server  FastMCP.as_proxy backend_server.py,  Could also be a FastMCP instance, config dict, or a remote URL nameMyProxyServer  Optional settings for the proxy   Or create the Client yourself for custom configuration backend_client  Clientbackend_server.py proxy_from_client  FastMCP.as_proxybackend_client  How as_proxy Works 1. It connects to the backend server using the provided client. 2. It discovers all the tools, resources, resource templates, and prompts available on the backend server. 3. It creates corresponding proxy components that forward requests to the backend. 4. It returns a standard FastMCP server instance that can be used like any other. Currently, proxying focuses primarily on exposing the major MCP objects tools, resources, templates, and prompts. Some advanced MCP features like notifications and sampling are not fully supported in proxies in the current version. Support for these additional features may be added in future releases.  Bridging Transports A common use case is to bridge transports. For example, making a remote SSE server available locally via Stdio python from fastmcp import FastMCP  Target a remote SSE server directly by URL proxy  FastMCP.as_proxyhttpexample.commcpsse, nameSSE to Stdio Proxy  The proxy can now be used with any transport  No special handling needed - it works like any FastMCP server   In-Memory Proxies You can also proxy an in-memory FastMCP instance, which is useful for adjusting the configuration or behavior of a server you dont completely control. python from fastmcp import FastMCP  Original server original_server  FastMCPnameOriginal original_server.tool def tool_a - str return A  Create a proxy of the original server directly proxy  FastMCP.as_proxy original_server, nameProxy Server   proxy is now a regular FastMCP server that forwards  requests to original_server   Configuration-Based Proxies You can create a proxy directly from a configuration dictionary that follows the MCPConfig schema. This is useful for quickly setting up proxies to remote servers without manually configuring each connection detail. python from fastmcp import FastMCP  Create a proxy directly from a config dictionary config   mcpServers  default   For single server configs, default is commonly used url httpsexample.commcp, transport http     Create a proxy to the configured server proxy  FastMCP.as_proxyconfig, nameConfig-Based Proxy  Run the proxy with stdio transport for local access if __name__  __main__ proxy.run  The MCPConfig format follows an emerging standard for MCP server configuration and may evolve as the specification matures. While FastMCP aims to maintain compatibility with future versions, be aware that field names or structure might change. You can also use MCPConfig to create a proxy to multiple servers. When multiple servers are specified, they are automatically mounted with their config names as prefixes, providing a unified interface to all servers python from fastmcp import FastMCP  Multi-server configuration config   mcpServers  weather  url httpsweather-api.example.commcp, transport http , calendar  url httpscalendar-api.example.commcp, transport http     Create a proxy to multiple servers composite_proxy  FastMCP.as_proxyconfig, nameComposite Proxy  Tools and resources are accessible with prefixes  - weather_get_forecast, calendar_add_event  - weatherweathericonssunny, calendarcalendareventstoday   FastMCPProxy Class Internally, FastMCP.as_proxy uses the FastMCPProxy class. You generally dont need to interact with this class directly, but its available if needed. Using the class directly might be necessary for advanced scenarios, like subclassing FastMCPProxy to add custom logic before or after forwarding requests.  Resources  Templates Source httpsgofastmcp.comserversresources Expose data sources and dynamic content generators to your MCP client. export const VersionBadge  version   return New in versionversion   Resources represent data or files that an MCP client can read, and resource templates extend this concept by allowing clients to request dynamically generated resources based on parameters passed in the URI. FastMCP simplifies defining both static and dynamic resources, primarily using the mcp.resource decorator.  What Are Resources? Resources provide read-only access to data for the LLM or client application. When a client requests a resource URI 1. FastMCP finds the corresponding resource definition. 2. If its dynamic defined by a function, the function is executed. 3. The content text, JSON, binary data is returned to the client. This allows LLMs to access files, database content, configuration, or dynamically generated information relevant to the conversation.  Resources  The resource Decorator The most common way to define a resource is by decorating a Python function. The decorator requires the resources unique URI. python import json from fastmcp import FastMCP mcp  FastMCPnameDataServer  Basic dynamic resource returning a string mcp.resourceresourcegreeting def get_greeting - str Provides a simple greeting message. return Hello from FastMCP Resources!  Resource returning JSON data dict is auto-serialized mcp.resourcedataconfig def get_config - dict Provides application configuration as JSON. return  theme dark, version 1.2.0, features tools, resources,   Key Concepts  URI The first argument to resource is the unique URI e.g., resourcegreeting clients use to request this data.  Lazy Loading The decorated function get_greeting, get_config is only executed when a client specifically requests that resource URI via resourcesread.  Inferred Metadata By default  Resource Name Taken from the function name get_greeting.  Resource Description Taken from the functions docstring.  Decorator Arguments You can customize the resources properties using arguments in the mcp.resource decorator python from fastmcp import FastMCP mcp  FastMCPnameDataServer  Example specifying metadata mcp.resource uridataapp-status,  Explicit URI required nameApplicationStatus,  Custom name descriptionProvides the current status of the application.,  Custom description mime_typeapplicationjson,  Explicit MIME type tagsmonitoring, status  Categorization tags  def get_application_status - dict Internal function description ignored if description is provided above. return status ok, uptime 12345, version mcp.settings.version  Example usage  The unique identifier for the resource A human-readable name. If not provided, defaults to function name Explanation of the resource. If not provided, defaults to docstring Specifies the content type. FastMCP often infers a default like textplain or applicationjson, but explicit is better for non-text types A set of strings for categorization, potentially used by clients for filtering A boolean to enable or disable the resource. See Disabling Resourcesdisabling-resources for more information  Return Values FastMCP automatically converts your functions return value into the appropriate MCP resource content  str Sent as TextResourceContents with mime_typetextplain by default.  dict, list, pydantic.BaseModel Automatically serialized to a JSON string and sent as TextResourceContents with mime_typeapplicationjson by default.  bytes Base64 encoded and sent as BlobResourceContents. You should specify an appropriate mime_type e.g., imagepng, applicationoctet-stream.  None Results in an empty resource content list being returned.  Disabling Resources You can control the visibility and availability of resources and templates by enabling or disabling them. Disabled resources will not appear in the list of available resources or templates, and attempting to read a disabled resource will result in an Unknown resource error. By default, all resources are enabled. You can disable a resource upon creation using the enabled parameter in the decorator python mcp.resourcedatasecret, enabledFalse def get_secret_data This resource is currently disabled. return Secret data  You can also toggle a resources state programmatically after it has been created python mcp.resourcedataconfig def get_config return version 1  Disable and re-enable the resource get_config.disable get_config.enable   Accessing MCP Context Resources and resource templates can access additional MCP information and features through the Context object. To access it, add a parameter to your resource function with a type annotation of Context python 6, 14 from fastmcp import FastMCP, Context mcp  FastMCPnameDataServer mcp.resourceresourcesystem-status async def get_system_statusctx Context - dict Provides system status information. return  status operational, request_id ctx.request_id  mcp.resourceresourcenamedetails async def get_detailsname str, ctx Context - dict Get details for a specific name. return  name name, accessed_at ctx.request_id   For full documentation on the Context object and all its capabilities, see the Context documentationserverscontext.  Asynchronous Resources Use async def for resource functions that perform IO operations e.g., reading from a database or network to avoid blocking the server. python import aiofiles from fastmcp import FastMCP mcp  FastMCPnameDataServer mcp.resourcefileappdataimportant_log.txt, mime_typetextplain async def read_important_log - str Reads content from a specific log file asynchronously. try async with aiofiles.openappdataimportant_log.txt, moder as f content  await f.read return content except FileNotFoundError return Log file not found.   Resource Classes While mcp.resource is ideal for dynamic content, you can directly register pre-defined resources like static files or simple text using mcp.add_resource and concrete Resource subclasses. python from pathlib import Path from fastmcp import FastMCP from fastmcp.resources import FileResource, TextResource, DirectoryResource mcp  FastMCPnameDataServer  1. Exposing a static file directly readme_path  Path.README.md.resolve if readme_path.exists  Use a file URI scheme readme_resource  FileResource uriffilereadme_path.as_posix, pathreadme_path,  Path to the actual file nameREADME File, descriptionThe projects README., mime_typetextmarkdown, tagsdocumentation  mcp.add_resourcereadme_resource  2. Exposing simple, predefined text notice_resource  TextResource uriresourcenotice, nameImportant Notice, textSystem maintenance scheduled for Sunday., tagsnotification  mcp.add_resourcenotice_resource  3. Using a custom key different from the URI special_resource  TextResource uriresourcecommon-notice, nameSpecial Notice, textThis is a special notice with a custom storage key.,  mcp.add_resourcespecial_resource, keyresourcecustom-key  4. Exposing a directory listing data_dir_path  Path.app_data.resolve if data_dir_path.is_dir data_listing_resource  DirectoryResource uriresourcedata-files, pathdata_dir_path,  Path to the directory nameData Directory Listing, descriptionLists files available in the data directory., recursiveFalse  Set to True to list subdirectories  mcp.add_resourcedata_listing_resource  Returns JSON list of files  Common Resource Classes  TextResource For simple string content.  BinaryResource For raw bytes content.  FileResource Reads content from a local file path. Handles textbinary modes and lazy reading.  HttpResource Fetches content from an HTTPS URL requires httpx.  DirectoryResource Lists files in a local directory returns JSON.  FunctionResource Internal class used by mcp.resource. Use these when the content is static or sourced directly from a fileURL, bypassing the need for a dedicated Python function.  Custom Resource Keys When adding resources directly with mcp.add_resource, you can optionally provide a custom storage key python  Creating a resource with standard URI as the key resource  TextResourceuriresourcedata mcp.add_resourceresource  Will be stored and accessed using resourcedata  Creating a resource with a custom key special_resource  TextResourceuriresourcespecial-data mcp.add_resourcespecial_resource, keyinternaldata-v2  Will be stored and accessed using internaldata-v2  Note that this parameter is only available when using add_resource directly and not through the resource decorator, as URIs are provided explicitly when using the decorator.  Resource Templates Resource Templates allow clients to request resources whose content depends on parameters embedded in the URI. Define a template using the same mcp.resource decorator, but include parameter_name placeholders in the URI string and add corresponding arguments to your function signature. Resource templates share most configuration options with regular resources name, description, mime_type, tags, but add the ability to define URI parameters that map to function parameters. Resource templates generate a new resource for each unique set of parameters, which means that resources can be dynamically created on-demand. For example, if the resource template userprofilename is registered, MCP clients could request userprofileford or userprofilemarvin to retrieve either of those two user profiles as resources, without having to register each resource individually. Functions with args are not supported as resource templates. However, unlike tools and prompts, resource templates do support kwargs because the URI template defines specific parameter names that will be collected and passed as keyword arguments. Here is a complete example that shows how to define two resource templates python from fastmcp import FastMCP mcp  FastMCPnameDataServer  Template URI includes city placeholder mcp.resourceweathercitycurrent def get_weathercity str - dict Provides weather information for a specific city.  In a real implementation, this would call a weather API  Here were using simplified logic for example purposes return  city city.capitalize, temperature 22, condition Sunny, unit celsius   Template with multiple parameters mcp.resourcereposownerrepoinfo def get_repo_infoowner str, repo str - dict Retrieves information about a GitHub repository.  In a real implementation, this would call the GitHub API return  owner owner, name repo, full_name fownerrepo, stars 120, forks 48   With these two templates defined, clients can request a variety of resources  weatherlondoncurrent  Returns weather for London  weatherpariscurrent  Returns weather for Paris  reposjlowinfastmcpinfo  Returns info about the jlowinfastmcp repository  reposprefecthqprefectinfo  Returns info about the prefecthqprefect repository  Wildcard Parameters Please note FastMCPs support for wildcard parameters is an extension of the Model Context Protocol standard, which otherwise follows RFC 6570. Since all template processing happens in the FastMCP server, this should not cause any compatibility issues with other MCP implementations. Resource templates support wildcard parameters that can match multiple path segments. While standard parameters param only match a single path segment and dont cross  boundaries, wildcard parameters param can capture multiple segments including slashes. Wildcards capture all subsequent path segments up until the defined part of the URI template whether literal or another parameter. This allows you to have multiple wildcard parameters in a single URI template. python 15, 23 from fastmcp import FastMCP mcp  FastMCPnameDataServer  Standard parameter only matches one segment mcp.resourcefilesfilename def get_filefilename str - str Retrieves a file by name.  Will only match files return fFile content for filename  Wildcard parameter can match multiple segments mcp.resourcepathfilepath def get_path_contentfilepath str - str Retrieves content at a specific path.  Can match pathdocsserverresources.mdx return fContent at path filepath  Mixing standard and wildcard parameters mcp.resourcerepoownerpathtemplate.py def get_template_fileowner str, path str - dict Retrieves a file from a specific repository and path, but only if the resource ends with template.py  Can match repojlowinfastmcpsrcresourcestemplate.py return  owner owner, path path  template.py, content fFile at pathtemplate.py in owners repository   Wildcard parameters are useful when  Working with file paths or hierarchical data  Creating APIs that need to capture variable-length path segments  Building URL-like patterns similar to REST APIs Note that like regular parameters, each wildcard parameter must still be a named parameter in your function signature, and all required function parameters must appear in the URI template.  Default Values When creating resource templates, FastMCP enforces two rules for the relationship between URI template parameters and function parameters 1. Required Function Parameters All function parameters without default values required parameters must appear in the URI template. 2. URI Parameters All URI template parameters must exist as function parameters. However, function parameters with default values dont need to be included in the URI template. When a client requests a resource, FastMCP will  Extract parameter values from the URI for parameters included in the template  Use default values for any function parameters not in the URI template This allows for flexible API designs. For example, a simple search template with optional parameters python from fastmcp import FastMCP mcp  FastMCPnameDataServer mcp.resourcesearchquery def search_resourcesquery str, max_results int  10, include_archived bool  False - dict Search for resources matching the query string.  Only query is required in the URI, the other parameters use their defaults results  perform_searchquery, limitmax_results, archivedinclude_archived return  query query, max_results max_results, include_archived include_archived, results results   With this template, clients can request searchpython and the function will be called with querypython, max_results10, include_archivedFalse. MCP Developers can still call the underlying search_resources function directly with more specific parameters. An even more powerful pattern is registering a single function with multiple URI templates, allowing different ways to access the same data python from fastmcp import FastMCP mcp  FastMCPnameDataServer  Define a user lookup function that can be accessed by different identifiers mcp.resourceusersemailemail mcp.resourceusersnamename def lookup_username str  None  None, email str  None  None - dict Look up a user by either name or email. if email return find_user_by_emailemail  pseudocode elif name return find_user_by_namename  pseudocode else return error No lookup parameters provided  Now an LLM or client can retrieve user information in two different ways  usersemailaliceexample.com  Looks up user by email with nameNone  usersnameBob  Looks up user by name with emailNone In this stacked decorator pattern  The name parameter is only provided when using the usersnamename template  The email parameter is only provided when using the usersemailemail template  Each parameter defaults to None when not included in the URI  The function logic handles whichever parameter is provided Templates provide a powerful way to expose parameterized data access points following REST-like principles.  Error Handling If your resource function encounters an error, you can raise a standard Python exception ValueError, TypeError, FileNotFoundError, custom exceptions, etc. or a FastMCP ResourceError. By default, all exceptions including their details are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately. If you want to mask internal error details for security reasons, you can 1. Use the mask_error_detailsTrue parameter when creating your FastMCP instance python mcp  FastMCPnameSecureServer, mask_error_detailsTrue  2. Or use ResourceError to explicitly control what error information is sent to clients python from fastmcp import FastMCP from fastmcp.exceptions import ResourceError mcp  FastMCPnameDataServer mcp.resourceresourcesafe-error def fail_with_details - str This resource provides detailed error information.  ResourceError contents are always sent back to clients,  regardless of mask_error_details setting raise ResourceErrorUnable to retrieve data file not found mcp.resourceresourcemasked-error def fail_with_masked_details - str This resource masks internal error details when mask_error_detailsTrue.  This message would be masked if mask_error_detailsTrue raise ValueErrorSensitive internal file path etcsecrets.conf mcp.resourcedataid def get_data_by_idid str - dict Template resources also support the same error handling pattern. if id  secure raise ValueErrorCannot access secure data elif id  missing raise ResourceErrorData ID missing not found in database return id id, value data  When mask_error_detailsTrue, only error messages from ResourceError will include details, other exceptions will be converted to a generic message.  Server Behavior  Duplicate Resources You can configure how the FastMCP server handles attempts to register multiple resources or templates with the same URI. Use the on_duplicate_resources setting during FastMCP initialization. python from fastmcp import FastMCP mcp  FastMCP nameResourceServer, on_duplicate_resourceserror  Raise error on duplicates  mcp.resourcedataconfig def get_config_v1 return version 1  This registration attempt will raise a ValueError because  dataconfig is already registered and the behavior is error.  mcp.resourcedataconfig  def get_config_v2 return version 2  The duplicate behavior options are  warn default Logs a warning, and the new resourcetemplate replaces the old one.  error Raises a ValueError, preventing the duplicate registration.  replace Silently replaces the existing resourcetemplate with the new one.  ignore Keeps the original resourcetemplate and ignores the new registration attempt.  The FastMCP Server Source httpsgofastmcp.comserversserver The core FastMCP server class for building MCP applications with tools, resources, and prompts. export const VersionBadge  version   return New in versionversion   The central piece of a FastMCP application is the FastMCP server class. This class acts as the main container for your applications tools, resources, and prompts, and manages communication with MCP clients.  Creating a Server Instantiating a server is straightforward. You typically provide a name for your server, which helps identify it in client applications or logs. python from fastmcp import FastMCP  Create a basic server instance mcp  FastMCPnameMyAssistantServer  You can also add instructions for how to interact with the server mcp_with_instructions  FastMCP nameHelpfulAssistant, instructions This server provides data analysis tools. Call get_average to analyze numerical data. ,   The FastMCP constructor accepts several arguments A human-readable name for your server Description of how to interact with this server. These instructions help clients understand the servers purpose and available functionality An async context manager function for server startup and shutdown logic A set of strings to tag the server itself A list of tools or functions to convert to tools to add to the server. In some cases, providing tools programmatically may be more convenient than using the mcp.tool decorator Keyword arguments corresponding to additional ServerSettings configuration  Components FastMCP servers expose several types of components to the client  Tools Tools are functions that the client can call to perform actions or access external systems. python mcp.tool def multiplya float, b float - float Multiplies two numbers together. return a  b  See Toolsserverstools for detailed documentation.  Resources Resources expose data sources that the client can read. python mcp.resourcedataconfig def get_config - dict Provides the application configuration. return theme dark, version 1.0  See Resources  Templatesserversresources for detailed documentation.  Resource Templates Resource templates are parameterized resources that allow the client to request specific data. python mcp.resourceusersuser_idprofile def get_user_profileuser_id int - dict Retrieves a users profile by ID.  The user_id in the URI is extracted and passed to this function return id user_id, name fUser user_id, status active  See Resources  Templatesserversresources for detailed documentation.  Prompts Prompts are reusable message templates for guiding the LLM. python mcp.prompt def analyze_datadata_points listfloat - str Creates a prompt asking for analysis of numerical data. formatted_data  , .joinstrpoint for point in data_points return fPlease analyze these data points formatted_data  See Promptsserversprompts for detailed documentation.  Tag-Based Filtering FastMCP supports tag-based filtering to selectively expose components based on configurable includeexclude tag sets. This is useful for creating different views of your server for different environments or users. Components can be tagged when defined using the tags parameter python mcp.tooltagspublic, utility def public_tool - str return This tool is public mcp.tooltagsinternal, admin def admin_tool - str return This tool is for admins only  The filtering logic works as follows  Include tags If specified, only components with at least one matching tag are exposed  Exclude tags Components with any matching tag are filtered out  Precedence Exclude tags always take priority over include tags To ensure a component is never exposed, you can set enabledFalse on the component itself. To learn more, see the component-specific documentation. You configure tag-based filtering when creating your server python  Only expose components tagged with public mcp  FastMCPinclude_tagspublic  Hide components tagged as internal or deprecated mcp  FastMCPexclude_tagsinternal, deprecated  Combine both show admin tools but hide deprecated ones mcp  FastMCPinclude_tagsadmin, exclude_tagsdeprecated  This filtering applies to all component types tools, resources, resource templates, and prompts and affects both listing and access.  Running the Server FastMCP servers need a transport mechanism to communicate with clients. You typically start your server by calling the mcp.run method on your FastMCP instance, often within an if __name__  __main__ block in your main server script. This pattern ensures compatibility with various MCP clients. python  my_server.py from fastmcp import FastMCP mcp  FastMCPnameMyServer mcp.tool def greetname str - str Greet a user by name. return fHello, name! if __name__  __main__  This runs the server, defaulting to STDIO transport mcp.run  To use a different transport, e.g., Streamable HTTP  mcp.runtransporthttp, host127.0.0.1, port9000  FastMCP supports several transport options  STDIO default, for local tools  Streamable HTTP recommended for web services  SSE legacy web transport, deprecated The server can also be run using the FastMCP CLI. For detailed information on each transport, how to configure them host, port, paths, and when to use which, please refer to the Running Your FastMCP Serverdeploymentrunning-server guide.  Composing Servers FastMCP supports composing multiple servers together using import_server static copy and mount live link. This allows you to organize large applications into modular components or reuse existing servers. See the Server Compositionserverscomposition guide for full details, best practices, and examples. python  Example Importing a subserver from fastmcp import FastMCP import asyncio main  FastMCPnameMain sub  FastMCPnameSub sub.tool def hello return hi  Mount directly main.mountsub, prefixsub   Proxying Servers FastMCP can act as a proxy for any MCP server local or remote using FastMCP.as_proxy, letting you bridge transports or add a frontend to existing servers. For example, you can expose a remote SSE server locally via stdio, or vice versa. See the Proxying Serversserversproxy guide for details and advanced usage. python from fastmcp import FastMCP, Client backend  Clienthttpexample.commcpsse proxy  FastMCP.as_proxybackend, nameProxyServer  Now use the proxy like any FastMCP server   Server Configuration Servers can be configured using a combination of initialization arguments, global settings, and transport-specific settings.  Server-Specific Configuration Server-specific settings are passed when creating the FastMCP instance and control server behavior python from fastmcp import FastMCP  Configure server-specific settings mcp  FastMCP nameConfiguredServer, dependenciesrequests, pandas2.0.0,  Optional server dependencies include_tagspublic, api,  Only expose these tagged components exclude_tagsinternal, deprecated,  Hide these tagged components on_duplicate_toolserror,  Handle duplicate registrations on_duplicate_resourceswarn, on_duplicate_promptsreplace,    Constructor Parameters Optional server dependencies list with package specifications Only expose components with at least one matching tag Hide components with any matching tag How to handle duplicate tool registrations How to handle duplicate resource registrations How to handle duplicate prompt registrations  Global Settings Global settings affect all FastMCP servers and can be configured via environment variables prefixed with FASTMCP_ or in a .env file python import fastmcp  Access global settings printfastmcp.settings.log_level  Default INFO printfastmcp.settings.mask_error_details  Default False printfastmcp.settings.resource_prefix_format  Default path  Common global settings include  log_level Logging level DEBUG, INFO, WARNING, ERROR, CRITICAL, set with FASTMCP_LOG_LEVEL  mask_error_details Whether to hide detailed error information from clients, set with FASTMCP_MASK_ERROR_DETAILS  resource_prefix_format How to format resource prefixes path or protocol, set with FASTMCP_RESOURCE_PREFIX_FORMAT  Transport-Specific Configuration Transport settings are provided when running the server and control network behavior python  Configure transport when running mcp.run transporthttp, host0.0.0.0,  Bind to all interfaces port9000,  Custom port log_levelDEBUG,  Override global log level   Or for async usage await mcp.run_async transporthttp, host127.0.0.1, port8080,    Environment Variables Settings can be configured via environment variables bash  Global settings export FASTMCP_LOG_LEVELDEBUG export FASTMCP_MASK_ERROR_DETAILSTrue export FASTMCP_RESOURCE_PREFIX_FORMATprotocol   Custom Tool Serialization By default, FastMCP serializes tool return values to JSON when they need to be converted to text. You can customize this behavior by providing a tool_serializer function when creating your server python import yaml from fastmcp import FastMCP  Define a custom serializer that formats dictionaries as YAML def yaml_serializerdata return yaml.dumpdata, sort_keysFalse  Create a server with the custom serializer mcp  FastMCPnameMyServer, tool_serializeryaml_serializer mcp.tool def get_config Returns configuration in YAML format. return api_key abc123, debug True, rate_limit 100  The serializer function takes any data object and returns a string representation. This is applied to all non-string return values from your tools. Tools that already return strings bypass the serializer. This customization is useful when you want to  Format data in a specific way like YAML or custom formats  Control specific serialization options like indentation or sorting  Add metadata or transform data before sending it to clients If the serializer function raises an exception, the tool will fall back to the default JSON serialization to avoid breaking the server.  Tools Source httpsgofastmcp.comserverstools Expose functions as executable capabilities for your MCP client. export const VersionBadge  version   return New in versionversion   Tools are the core building blocks that allow your LLM to interact with external systems, execute code, and access data that isnt in its training data. In FastMCP, tools are Python functions exposed to LLMs through the MCP protocol.  What Are Tools? Tools in FastMCP transform regular Python functions into capabilities that LLMs can invoke during conversations. When an LLM decides to use a tool 1. It sends a request with parameters based on the tools schema. 2. FastMCP validates these parameters against your functions signature. 3. Your function executes with the validated inputs. 4. The result is returned to the LLM, which can use it in its response. This allows LLMs to perform tasks like querying databases, calling APIs, making calculations, or accessing filesextending their capabilities beyond whats in their training data.  Tools  The tool Decorator Creating a tool is as simple as decorating a Python function with mcp.tool python from fastmcp import FastMCP mcp  FastMCPnameCalculatorServer mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b  When this tool is registered, FastMCP automatically  Uses the function name add as the tool name.  Uses the functions docstring Adds two integer numbers... as the tool description.  Generates an input schema based on the functions parameters and type annotations.  Handles parameter validation and error reporting. The way you define your Python function dictates how the tool appears and behaves for the LLM client. Functions with args or kwargs are not supported as tools. This restriction exists because FastMCP needs to generate a complete parameter schema for the MCP protocol, which isnt possible with variable argument lists.  Decorator Arguments While FastMCP infers the name and description from your function, you can override these and add additional metadata using arguments to the mcp.tool decorator python mcp.tool namefind_products,  Custom tool name for the LLM descriptionSearch the product catalog with optional category filtering.,  Custom description tagscatalog, search,  Optional tags for organizationfiltering  def search_products_implementationquery str, category str  None  None - listdict Internal function description ignored if description is provided above.  Implementation... printfSearching for query in category category return id 2, name Another Product  Sets the explicit tool name exposed via MCP. If not provided, uses the function name Provides the description exposed via MCP. If set, the functions docstring is ignored for this purpose A set of strings to categorize the tool. Clients might use tags to filter or group available tools A boolean to enable or disable the tool. See Disabling Toolsdisabling-tools for more information A list of argument names to exclude from the tool schema shown to the LLM. See Excluding Argumentsexcluding-arguments for more information An optional ToolAnnotations object or dictionary to add additional metadata about the tool. A human-readable title for the tool. If true, the tool does not modify its environment. If true, the tool may perform destructive updates to its environment. If true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment. If true, this tool may interact with an open world of external entities. If false, the tools domain of interaction is closed.  Tool Parameters  Type Annotations Type annotations for parameters are essential for proper tool functionality. They 1. Inform the LLM about the expected data types for each parameter 2. Enable FastMCP to validate input data from clients 3. Generate accurate JSON schemas for the MCP protocol Use standard Python type annotations for parameters python mcp.tool def analyze_text text str, max_tokens int  100, language str  None  None  - dict Analyze the provided text.  Implementation...   Parameter Metadata You can provide additional metadata about parameters using Pydantics Field class with Annotated. This approach is preferred as its more modern and keeps type hints separate from validation rules python from typing import Annotated from pydantic import Field mcp.tool def process_image image_url Annotatedstr, FielddescriptionURL of the image to process, resize Annotatedbool, FielddescriptionWhether to resize the image  False, width Annotatedint, FielddescriptionTarget width in pixels, ge1, le2000  800, format Annotated Literaljpeg, png, webp, FielddescriptionOutput image format   jpeg  - dict Process an image with optional resizing.  Implementation...  You can also use the Field as a default value, though the Annotated approach is preferred python mcp.tool def search_database query str  FielddescriptionSearch query string, limit int  Field10, descriptionMaximum number of results, ge1, le100  - list Search the database with the provided query.  Implementation...  Field provides several validation and documentation features  description Human-readable explanation of the parameter shown to LLMs  gegtlelt Greaterless than or equal constraints  min_lengthmax_length String or collection length constraints  pattern Regex pattern for string validation  default Default value if parameter is omitted  Supported Types FastMCP supports a wide range of type annotations, including all Pydantic types  Type Annotation  Example  Description   ----------------  ----------------------------------------  ----------------------------------------------------------------------------------------------   Basic types  int, float, str, bool  Simple scalar values - see Built-in Typesbuilt-in-types   Binary data  bytes  Binary content - see Binary Databinary-data   Date and Time  datetime, date, timedelta  Date and time objects - see Date and Time Typesdate-and-time-types   Collection types  liststr, dictstr, int, setint  Collections of items - see Collection Typescollection-types   Optional types  float  None, Optionalfloat  Parameters that may be nullomitted - see Union and Optional Typesunion-and-optional-types   Union types  str  int, Unionstr, int  Parameters accepting multiple types - see Union and Optional Typesunion-and-optional-types   Constrained types  LiteralA, B, Enum  Parameters with specific allowed values - see Constrained Typesconstrained-types   Paths  Path  File system paths - see Pathspaths   UUIDs  UUID  Universally unique identifiers - see UUIDsuuids   Pydantic models  UserData  Complex structured data - see Pydantic Modelspydantic-models  For additional type annotations not listed here, see the Parameter Typesparameter-types section below for more detailed information and examples.  Optional Arguments FastMCP follows Pythons standard function parameter conventions. Parameters without default values are required, while those with default values are optional. python mcp.tool def search_products query str,  Required - no default value max_results int  10,  Optional - has default value sort_by str  relevance,  Optional - has default value category str  None  None  Optional - can be None  - listdict Search the product catalog.  Implementation...  In this example, the LLM must provide a query parameter, while max_results, sort_by, and category will use their default values if not explicitly provided.  Excluding Arguments You can exclude certain arguments from the tool schema shown to the LLM. This is useful for arguments that are injected at runtime such as state, user_id, or credentials and should not be exposed to the LLM or client. Only arguments with default values can be excluded attempting to exclude a required argument will raise an error. Example python mcp.tool nameget_user_details, exclude_argsuser_id  def get_user_detailsuser_id str  None - str  user_id will be injected by the server, not provided by the LLM ...  With this configuration, user_id will not appear in the tools parameter schema, but can still be set by the server or framework at runtime. For more complex tool transformations, see Transforming Toolspatternstool-transformation.  Disabling Tools You can control the visibility and availability of tools by enabling or disabling them. This is useful for feature flagging, maintenance, or dynamically changing the toolset available to a client. Disabled tools will not appear in the list of available tools returned by list_tools, and attempting to call a disabled tool will result in an Unknown tool error, just as if the tool did not exist. By default, all tools are enabled. You can disable a tool upon creation using the enabled parameter in the decorator python mcp.toolenabledFalse def maintenance_tool This tool is currently under maintenance. return This tool is disabled.  You can also toggle a tools state programmatically after it has been created python mcp.tool def dynamic_tool return I am a dynamic tool.  Disable and re-enable the tool dynamic_tool.disable dynamic_tool.enable   Async Tools FastMCP seamlessly supports both standard def and asynchronous async def functions as tools. python  Synchronous tool suitable for CPU-bound or quick tasks mcp.tool def calculate_distancelat1 float, lon1 float, lat2 float, lon2 float - float Calculate the distance between two coordinates.  Implementation... return 42.5  Asynchronous tool ideal for IO-bound operations mcp.tool async def fetch_weathercity str - dict Retrieve current weather conditions for a city.  Use async def for operations involving network calls, file IO, etc.  This prevents blocking the server while waiting for external operations. async with aiohttp.ClientSession as session async with session.getfhttpsapi.example.comweathercity as response  Check response status before returning response.raise_for_status return await response.json  Use async def when your tool needs to perform operations that might wait for external systems network requests, database queries, file access to keep your server responsive.  Return Values FastMCP automatically converts the value returned by your function into the appropriate MCP content format for the client  str Sent as TextContent.  dict, list, Pydantic BaseModel Serialized to a JSON string and sent as TextContent.  bytes Base64 encoded and sent as BlobResourceContents often within an EmbeddedResource.  fastmcp.utilities.types.Image A helper class for easily returning image data. Sent as ImageContent.  fastmcp.utilities.types.Audio A helper class for easily returning audio data. Sent as AudioContent.  fastmcp.utilities.types.File A helper class for easily returning binary data as base64-encoded content. Sent as EmbeddedResource.  A list of any of the above Automatically converts each item appropriately.  None Results in an empty response no content is sent back to the client. FastMCP will attempt to serialize other types to a string if possible. At this time, FastMCP responds only to your tools return value, not its return annotation. python from fastmcp import FastMCP from fastmcp.utilities.types import Image import io try from PIL import Image as PILImage except ImportError raise ImportErrorPlease install the pillow library to run this example. mcp  FastMCPImage Demo mcp.tool def generate_imagewidth int, height int, color str - Image Generates a solid color image.  Create image using Pillow img  PILImage.newRGB, width, height, colorcolor  Save to a bytes buffer buffer  io.BytesIO img.savebuffer, formatPNG img_bytes  buffer.getvalue  Return using FastMCPs Image helper return Imagedataimg_bytes, formatpng mcp.tool def do_nothing - None This tool performs an action but returns no data. printPerforming a side effect... return None   Error Handling If your tool encounters an error, you can raise a standard Python exception ValueError, TypeError, FileNotFoundError, custom exceptions, etc. or a FastMCP ToolError. By default, all exceptions including their details are logged and converted into an MCP error response to be sent back to the client LLM. This helps the LLM understand failures and react appropriately. If you want to mask internal error details for security reasons, you can 1. Use the mask_error_detailsTrue parameter when creating your FastMCP instance python mcp  FastMCPnameSecureServer, mask_error_detailsTrue  2. Or use ToolError to explicitly control what error information is sent to clients python from fastmcp import FastMCP from fastmcp.exceptions import ToolError mcp.tool def dividea float, b float - float Divide a by b. if b  0  Error messages from ToolError are always sent to clients,  regardless of mask_error_details setting raise ToolErrorDivision by zero is not allowed.  If mask_error_detailsTrue, this message would be masked if not isinstancea, int, float or not isinstanceb, int, float raise TypeErrorBoth arguments must be numbers. return a  b  When mask_error_detailsTrue, only error messages from ToolError will include details, other exceptions will be converted to a generic message.  Annotations FastMCP allows you to add specialized metadata to your tools through annotations. These annotations communicate how tools behave to client applications without consuming token context in LLM prompts. Annotations serve several purposes in client applications  Adding user-friendly titles for display purposes  Indicating whether tools modify data or systems  Describing the safety profile of tools destructive vs. non-destructive  Signaling if tools interact with external systems You can add annotations to a tool using the annotations parameter in the mcp.tool decorator python mcp.tool annotations title Calculate Sum, readOnlyHint True, openWorldHint False   def calculate_suma float, b float - float Add two numbers together. return a  b  FastMCP supports these standard annotations  Annotation  Type  Default  Purpose   ----------------  ------  ------  --------------------------------------------------------------------------   title  string  -  Display name for user interfaces   readOnlyHint  boolean  false  Indicates if the tool only reads without making changes   destructiveHint  boolean  true  For non-readonly tools, signals if changes are destructive   idempotentHint  boolean  false  Indicates if repeated identical calls have the same effect as a single call   openWorldHint  boolean  true  Specifies if the tool interacts with external systems  Remember that annotations help make better user experiences but should be treated as advisory hints. They help client applications present appropriate UI elements and safety controls, but wont enforce security boundaries on their own. Always focus on making your annotations accurately represent what your tool actually does.  MCP Context Tools can access MCP features like logging, reading resources, or reporting progress through the Context object. To use it, add a parameter to your tool function with the type hint Context. python from fastmcp import FastMCP, Context mcp  FastMCPnameContextDemo mcp.tool async def process_datadata_uri str, ctx Context - dict Process data from a resource with progress reporting. await ctx.infofProcessing data from data_uri  Read a resource resource  await ctx.read_resourcedata_uri data  resource0.content if resource else   Report progress await ctx.report_progressprogress50, total100  Example request to the clients LLM for help summary  await ctx.samplefSummarize this in 10 words data200 await ctx.report_progressprogress100, total100 return  length lendata, summary summary.text   The Context object provides access to  Logging ctx.debug, ctx.info, ctx.warning, ctx.error  Progress Reporting ctx.report_progressprogress, total  Resource Access ctx.read_resourceuri  LLM Sampling ctx.sample...  Request Information ctx.request_id, ctx.client_id For full documentation on the Context object and all its capabilities, see the Context documentationserverscontext.  Parameter Types FastMCP supports a wide variety of parameter types to give you flexibility when designing your tools. FastMCP generally supports all types that Pydantic supports as fields, including all Pydantic custom types. This means you can use any type that can be validated and parsed by Pydantic in your tool parameters. FastMCP supports type coercion when possible. This means that if a client sends data that doesnt match the expected type, FastMCP will attempt to convert it to the appropriate type. For example, if a client sends a string for a parameter annotated as int, FastMCP will attempt to convert it to an integer. If the conversion is not possible, FastMCP will return a validation error.  Built-in Types The most common parameter types are Pythons built-in scalar types python mcp.tool def process_values name str,  Text data count int,  Integer numbers amount float,  Floating point numbers enabled bool  Boolean values TrueFalse  Process various value types.  Implementation...  These types provide clear expectations to the LLM about what values are acceptable and allow FastMCP to validate inputs properly. Even if a client provides a string like 42, it will be coerced to an integer for parameters annotated as int.  Date and Time Types FastMCP supports various date and time types from the datetime module python from datetime import datetime, date, timedelta mcp.tool def process_date_time event_date date,  ISO format date string or date object event_time datetime,  ISO format datetime string or datetime object duration timedelta  timedeltahours1  Integer seconds or timedelta  - str Process date and time information.  Types are automatically converted from strings assert isinstanceevent_date, date assert isinstanceevent_time, datetime assert isinstanceduration, timedelta return fEvent on event_date at event_time for duration   datetime - Accepts ISO format strings e.g., 2023-04-15T143000  date - Accepts ISO format date strings e.g., 2023-04-15  timedelta - Accepts integer seconds or timedelta objects  Collection Types FastMCP supports all standard Python collection types python mcp.tool def analyze_data values listfloat,  List of numbers properties dictstr, str,  Dictionary with string keys and values unique_ids setint,  Set of unique integers coordinates tuplefloat, float,  Tuple with fixed structure mixed_data dictstr, listint  Nested collections  Analyze collections of data.  Implementation...  All collection types can be used as parameter annotations  listT - Ordered sequence of items  dictK, V - Key-value mapping  setT - Unordered collection of unique items  tupleT1, T2, ... - Fixed-length sequence with potentially different types Collection types can be nested and combined to represent complex data structures. JSON strings that match the expected structure will be automatically parsed and converted to the appropriate Python collection type.  Union and Optional Types For parameters that can accept multiple types or may be omitted python mcp.tool def flexible_search query str  int,  Can be either string or integer filters dictstr, str  None  None,  Optional dictionary sort_field str  None  None  Optional string  Search with flexible parameter types.  Implementation...  Modern Python syntax str  int is preferred over older Unionstr, int forms. Similarly, str  None is preferred over Optionalstr.  Constrained Types When a parameter must be one of a predefined set of values, you can use either Literal types or Enums  Literals Literals constrain parameters to a specific set of values python from typing import Literal mcp.tool def sort_data data listfloat, order Literalascending, descending  ascending, algorithm Literalquicksort, mergesort, heapsort  quicksort  Sort data using specific options.  Implementation...  Literal types  Specify exact allowable values directly in the type annotation  Help LLMs understand exactly which values are acceptable  Provide input validation errors for invalid values  Create clear schemas for clients  Enums For more structured sets of constrained values, use Pythons Enum class python from enum import Enum class ColorEnum RED  red GREEN  green BLUE  blue mcp.tool def process_image image_path str, color_filter Color  Color.RED  Process an image with a color filter.  Implementation...  color_filter will be a Color enum member  When using Enum types  Clients should provide the enums value e.g., red, not the enum member name e.g., RED  FastMCP automatically coerces the string value into the appropriate Enum object  Your function receives the actual Enum member e.g., Color.RED  Validation errors are raised for values not in the enum  Binary Data There are two approaches to handling binary data in tool parameters  Bytes python mcp.tool def process_binarydata bytes Process binary data directly. The client can send a binary string, which will be converted directly to bytes.   Implementation using binary data data_length  lendata  ...  When you annotate a parameter as bytes, FastMCP will  Convert raw strings directly to bytes  Validate that the input can be properly represented as bytes FastMCP does not automatically decode base64-encoded strings for bytes parameters. If you need to accept base64-encoded data, you should handle the decoding manually as shown below.  Base64-encoded strings python from typing import Annotated from pydantic import Field mcp.tool def process_image_data image_data Annotatedstr, FielddescriptionBase64-encoded image data  Process an image from base64-encoded string. The client is expected to provide base64-encoded data as a string. Youll need to decode it manually.   Manual base64 decoding import base64 binary_data  base64.b64decodeimage_data  Process binary_data...  This approach is recommended when you expect to receive base64-encoded binary data from clients.  Paths The Path type from the pathlib module can be used for file system paths python from pathlib import Path mcp.tool def process_filepath Path - str Process a file at the given path. assert isinstancepath, Path  Path is properly converted return fProcessing file at path  When a client sends a string path, FastMCP automatically converts it to a Path object.  UUIDs The UUID type from the uuid module can be used for unique identifiers python import uuid mcp.tool def process_item item_id uuid.UUID  String UUID or UUID object  - str Process an item with the given UUID. assert isinstanceitem_id, uuid.UUID  Properly converted to UUID return fProcessing item item_id  When a client sends a string UUID e.g., 123e4567-e89b-12d3-a456-426614174000, FastMCP automatically converts it to a UUID object.  Pydantic Models For complex, structured data with nested fields and validation, use Pydantic models python from pydantic import BaseModel, Field from typing import Optional class UserBaseModel username str email str  FielddescriptionUsers email address age int  None  None is_active bool  True mcp.tool def create_useruser User Create a new user in the system.  The input is automatically validated against the User model  Even if provided as a JSON string or dict  Implementation...  Using Pydantic models provides  Clear, self-documenting structure for complex inputs  Built-in data validation  Automatic generation of detailed JSON schemas for the LLM  Automatic conversion from dictJSON input Clients can provide data for Pydantic model parameters as either  A JSON object string  A dictionary with the appropriate structure  Nested parameters in the appropriate format  Pydantic Fields FastMCP supports robust parameter validation through Pydantics Field class. This is especially useful to ensure that input values meet specific requirements beyond just their type. Note that fields can be used outside Pydantic models to provide metadata and validation constraints. The preferred approach is using Annotated with Field python from typing import Annotated from pydantic import Field mcp.tool def analyze_metrics  Numbers with range constraints count Annotatedint, Fieldge0, le100,  0  count  100 ratio Annotatedfloat, Fieldgt0, lt1.0,  0  ratio  1.0  String with pattern and length constraints user_id Annotatedstr, Field patternrA-Z2d4,  Must match regex pattern descriptionUser ID in format XX0000 ,  String with length constraints comment Annotatedstr, Fieldmin_length3, max_length500  ,  Numeric constraints factor Annotatedint, Fieldmultiple_of5  10,  Must be multiple of 5  Analyze metrics with validated parameters.  Implementation...  You can also use Field as a default value, though the Annotated approach is preferred python mcp.tool def validate_data  Value constraints age int  Fieldge0, lt120,  0  age  120  String constraints email str  Fieldpatternrw.-w.-.w,  Email pattern  Collection constraints tags liststr  Fieldmin_length1, max_length10  1-10 tags  Process data with field validations.  Implementation...  Common validation options include  Validation  Type  Description   -------------------------  -----------------  ---------------------------------------------   ge, gt  Number  Greater than or equal constraint   le, lt  Number  Less than or equal constraint   multiple_of  Number  Value must be a multiple of this number   min_length, max_length  String, List, etc.  Length constraints   pattern  String  Regular expression pattern constraint   description  Any  Human-readable description appears in schema  When a client sends invalid data, FastMCP will return a validation error explaining why the parameter failed validation.  Server Behavior  Duplicate Tools You can control how the FastMCP server behaves if you try to register multiple tools with the same name. This is configured using the on_duplicate_tools argument when creating the FastMCP instance. python from fastmcp import FastMCP mcp  FastMCP nameStrictServer,  Configure behavior for duplicate tool names on_duplicate_toolserror  mcp.tool def my_tool return Version 1  This will now raise a ValueError because my_tool already exists  and on_duplicate_tools is set to error.  mcp.tool  def my_tool return Version 2  The duplicate behavior options are  warn default Logs a warning and the new tool replaces the old one.  error Raises a ValueError, preventing the duplicate registration.  replace Silently replaces the existing tool with the new one.  ignore Keeps the original tool and ignores the new registration attempt.  Removing Tools You can dynamically remove tools from a server using the remove_tool method python from fastmcp import FastMCP mcp  FastMCPnameDynamicToolServer mcp.tool def calculate_suma int, b int - int Add two numbers together. return a  b mcp.remove_toolcalculate_sum   Legacy JSON Parsing FastMCP 1.0 and  2.2.10 relied on a crutch that attempted to work around LLM limitations by automatically parsing stringified JSON in tool arguments e.g., converting 1,2,3 to 1,2,3. As of FastMCP 2.2.10, this behavior is disabled by default because it circumvents type validation and can lead to unexpected type coercion issues e.g. parsing true as a bool and attempting to call a tool that expected a string, which would fail type validation. Most modern LLMs correctly format JSON, but if working with models that unnecessarily stringify JSON as was the case with Claude Desktop in late 2024, you can re-enable this behavior on your server by setting the environment variable FASTMCP_TOOL_ATTEMPT_PARSE_JSON_ARGS1. We strongly recommend leaving this disabled unless necessary.  How to Create an MCP Server in Python Source httpsgofastmcp.comtutorialscreate-mcp-server A step-by-step guide to building a Model Context Protocol MCP server using Python and FastMCP, from basic tools to dynamic resources. So you want to build a Model Context Protocol MCP server in Python. The goal is to create a service that can provide tools and data to AI models like Claude, Gemini, or others that support the protocol. While the MCP specificationhttpsmodelcontextprotocol.iospecification is powerful, implementing it from scratch involves a lot of boilerplate handling JSON-RPC, managing session state, and correctly formatting requests and responses. This is where FastMCP comes in. Its a high-level framework that handles all the protocol complexities for you, letting you focus on what matters writing the Python functions that power your server. This guide will walk you through creating a fully-featured MCP server from scratch using FastMCP. Every code block in this tutorial is a complete, runnable example. You can copy and paste it into a file and run it, or paste it directly into a Python REPL like IPython to try it out.  Prerequisites Make sure you have FastMCP installed. If not, follow the installation guidegetting-startedinstallation. bash pip install fastmcp   Step 1 Create the Basic Server Every FastMCP application starts with an instance of the FastMCP class. This object acts as the container for all your tools and resources. Create a new file called my_mcp_server.py python my_mcp_server.py from fastmcp import FastMCP  Create a server instance with a descriptive name mcp  FastMCPnameMy First MCP Server  Thats it! You have a valid though empty MCP server. Now, lets add some functionality.  Step 2 Add a Tool Tools are functions that an LLM can execute. Lets create a simple tool that adds two numbers. To do this, simply write a standard Python function and decorate it with mcp.tool. python my_mcp_server.py 5-8 from fastmcp import FastMCP mcp  FastMCPnameMy First MCP Server mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b  FastMCP automatically handles the rest  Tool Name It uses the function name add as the tools name.  Description It uses the functions docstring as the tools description for the LLM.  Schema It inspects the type hints a int, b int to generate a JSON schema for the inputs. This is the core philosophy of FastMCP write Python, not protocol boilerplate.  Step 3 Expose Data with Resources Resources provide read-only data to the LLM. You can define a resource by decorating a function with mcp.resource, providing a unique URI. Lets expose a simple configuration dictionary as a resource. python my_mcp_server.py 10-13 from fastmcp import FastMCP mcp  FastMCPnameMy First MCP Server mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b mcp.resourceresourceconfig def get_config - dict Provides the applications configuration. return version 1.0, author MyTeam  When a client requests the URI resourceconfig, FastMCP will execute the get_config function and return its output serialized as JSON to the client. The function is only called when the resource is requested, enabling lazy-loading of data.  Step 4 Generate Dynamic Content with Resource Templates Sometimes, you need to generate resources based on parameters. This is what Resource Templates are for. You define them using the same mcp.resource decorator but with placeholders in the URI. Lets create a template that provides a personalized greeting. python my_mcp_server.py 15-17 from fastmcp import FastMCP mcp  FastMCPnameMy First MCP Server mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b mcp.resourceresourceconfig def get_config - dict Provides the applications configuration. return version 1.0, author MyTeam mcp.resourcegreetingsname def personalized_greetingname str - str Generates a personalized greeting for the given name. return fHello, name! Welcome to the MCP server.  Now, clients can request dynamic URIs  greetingsFord will call personalized_greetingnameFord.  greetingsMarvin will call personalized_greetingnameMarvin. FastMCP automatically maps the name placeholder in the URI to the name parameter in your function.  Step 5 Run the Server To make your server executable, add a __main__ block to your script that calls mcp.run. python my_mcp_server.py 19-20 from fastmcp import FastMCP mcp  FastMCPnameMy First MCP Server mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b mcp.resourceresourceconfig def get_config - dict Provides the applications configuration. return version 1.0, author MyTeam mcp.resourcegreetingsname def personalized_greetingname str - str Generates a personalized greeting for the given name. return fHello, name! Welcome to the MCP server. if __name__  __main__ mcp.run  Now you can run your server from the command line bash python my_mcp_server.py  This starts the server using the default STDIO transport, which is how clients like Claude Desktop communicate with local servers. To learn about other transports, like HTTP, see the Running Your Serverdeploymentrunning-server guide.  The Complete Server Here is the full code for my_mcp_server.py click to expand python my_mcp_server.py expandable from fastmcp import FastMCP  1. Create the server mcp  FastMCPnameMy First MCP Server  2. Add a tool mcp.tool def adda int, b int - int Adds two integer numbers together. return a  b  3. Add a static resource mcp.resourceresourceconfig def get_config - dict Provides the applications configuration. return version 1.0, author MyTeam  4. Add a resource template for dynamic content mcp.resourcegreetingsname def personalized_greetingname str - str Generates a personalized greeting for the given name. return fHello, name! Welcome to the MCP server.  5. Make the server runnable if __name__  __main__ mcp.run   Next Steps Youve successfully built an MCP server! From here, you can explore more advanced topics  Tools in Depthserverstools Learn about asynchronous tools, error handling, and custom return types.  Resources  Templatesserversresources Discover different resource types, including files and HTTP endpoints.  Promptsserversprompts Create reusable prompt templates for your LLM.  Running Your Serverdeploymentrunning-server Deploy your server with different transports like HTTP.  What is the Model Context Protocol MCP? Source httpsgofastmcp.comtutorialsmcp An introduction to the core concepts of the Model Context Protocol MCP, explaining what it is, why its useful, and how it works. The Model Context Protocol MCP is an open standard designed to solve a fundamental problem in AI development how can Large Language Models LLMs reliably and securely interact with external tools, data, and services? Its the bridge between the probabilistic, non-deterministic world of AI and the deterministic, reliable world of your code and data. While you could build a custom REST API for your LLM, MCP provides a specialized, standardized port for AI-native communication. Think of it as USB-C for AI a single, well-defined interface for connecting any compliant LLM to any compliant tool or data source. This guide provides a high-level overview of the protocol itself. Well use FastMCP, the leading Python framework for MCP, to illustrate the concepts with simple code examples.  Why Do We Need a Protocol? With countless APIs already in existence, the most common question is Why do we need another one? The answer lies in standardization. The AI ecosystem is fragmented. Every model provider has its own way of defining and calling tools. MCPs goal is to create a common language that offers several key advantages 1. Interoperability Build one MCP server, and it can be used by any MCP-compliant client Claude, Gemini, OpenAI, custom agents, etc. without custom integration code. This is the protocols most important promise. 2. Discoverability Clients can dynamically ask a server what its capable of at runtime. They receive a structured, machine-readable menu of tools and resources. 3. Security  Safety MCP provides a clear, sandboxed boundary. An LLM cant execute arbitrary code on your server it can only request to run the specific, typed, and validated functions you explicitly expose. 4. Composability You can build small, specialized MCP servers and combine them to create powerful, complex applications.  Core MCP Components An MCP server exposes its capabilities through three primary components Tools, Resources, and Prompts.  Tools Executable Actions Tools are functions that the LLM can ask the server to execute. They are the action-oriented part of MCP. In the spirit of a REST API, you can think of Tools as being like POST requests. They are used to perform an action, change state, or trigger a side effect, like sending an email, adding a user to a database, or making a calculation. With FastMCP, creating a tool is as simple as decorating a Python function. python from fastmcp import FastMCP mcp  FastMCP  This function is now an MCP tool named get_weather mcp.tool def get_weathercity str - dict Gets the current weather for a specific city.  In a real app, this would call a weather API return city city, temperature 72F, forecast Sunny  Learn more about Tools serverstools  Resources Read-Only Data Resources are data sources that the LLM can read. They are used to load information into the LLMs context, providing it with knowledge it doesnt have from its training data. Following the REST API analogy, Resources are like GET requests. Their purpose is to retrieve information idempotently, ideally without causing side effects. A resource can be anything from a static text file to a dynamic piece of data from a database. Each resource is identified by a unique URI. python from fastmcp import FastMCP mcp  FastMCP  This function provides a resource at the URI systemstatus mcp.resourcesystemstatus def get_system_status - dict Returns the current operational status of the service. return status all systems normal   Resource Templates You can also create Resource Templates for dynamic data. A client could request users42profile to get the profile for a specific user. python from fastmcp import FastMCP mcp  FastMCP  This template provides user data for any given user ID mcp.resourceusersuser_idprofile def get_user_profileuser_id str - dict Returns the profile for a specific user.  Fetch user from a database... return id user_id, name Zaphod Beeblebrox  Learn more about Resources  Templates serversresources  Prompts Reusable Instructions Prompts are reusable, parameterized message templates. They provide a way to define consistent, structured instructions that a client can request to guide the LLMs behavior for a specific task. python from fastmcp import FastMCP mcp  FastMCP mcp.prompt def summarize_texttext_to_summarize str - str Creates a prompt asking the LLM to summarize a piece of text. return f Please provide a concise, one-paragraph summary of the following text text_to_summarize   Learn more about Prompts serversprompts  Advanced Capabilities Beyond the core components, MCP also supports more advanced interaction patterns, such as a server requesting that the clients LLM generate a completion known as sampling, or a server sending asynchronous notifications to a client. These features enable more complex, bidirectional workflows and are fully supported by FastMCP.  Next Steps Now that you understand the core concepts of the Model Context Protocol, youre ready to start building. The best place to begin is our step-by-step tutorial. Tutorial How to Create an MCP Server in Python tutorialscreate-mcp-server  How to Connect an LLM to a REST API Source httpsgofastmcp.comtutorialsrest-api A step-by-step guide to making any REST API with an OpenAPI spec available to LLMs using FastMCP. Youve built a powerful REST API, and now you want your LLM to be able to use it. Manually writing a wrapper function for every single endpoint is tedious, error-prone, and hard to maintain. This is where FastMCP shines. If your API has an OpenAPI or Swagger specification, FastMCP can automatically convert your entire API into a fully-featured MCP server, making every endpoint available as a secure, typed tool for your AI model. This guide will walk you through converting a public REST API into an MCP server in just a few lines of code. Every code block in this tutorial is a complete, runnable example. You can copy and paste it into a file and run it, or paste it directly into a Python REPL like IPython to try it out.  Prerequisites Make sure you have FastMCP installed. If not, follow the installation guidegetting-startedinstallation. bash pip install fastmcp   Step 1 Choose a Target API For this tutorial, well use the JSONPlaceholder APIhttpsjsonplaceholder.typicode.com, a free, fake online REST API for testing and prototyping. Its perfect because its simple and has a public OpenAPI specification.  API Base URL httpsjsonplaceholder.typicode.com  OpenAPI Spec URL Well use a community-provided spec for it.  Step 2 Create the MCP Server Now for the magic. Well use FastMCP.from_openapi. This method takes an httpx.AsyncClient configured for your API and its OpenAPI specification, and automatically converts every endpoint into a callable MCP Tool. Learn more about working with OpenAPI specs in the OpenAPI integration docsserversopenapi. For this tutorial, well use a simplified OpenAPI spec directly in the code. In a real project, you would typically load the spec from a URL or local file. Create a file named api_server.py python api_server.py 31-35 import httpx from fastmcp import FastMCP  Create an HTTP client for the target API client  httpx.AsyncClientbase_urlhttpsjsonplaceholder.typicode.com  Define a simplified OpenAPI spec for JSONPlaceholder openapi_spec   openapi 3.0.0, info title JSONPlaceholder API, version 1.0, paths  users  get  summary Get all users, operationId get_users, responses 200 description A list of users.  , usersid  get  summary Get a user by ID, operationId get_user_by_id, parameters name id, in path, required True, schema type integer, responses 200 description A single user.      Create the MCP server from the OpenAPI spec mcp  FastMCP.from_openapi openapi_specopenapi_spec, clientclient, nameJSONPlaceholder MCP Server  if __name__  __main__ mcp.runtransporthttp, port8000  And thats it! With just a few lines of code, youve created an MCP server that exposes the entire JSONPlaceholder API as a collection of tools.  Step 3 Test the Generated Server Lets verify that our new MCP server works. We can use the fastmcp.Client to connect to it and inspect its tools. Learn more about the FastMCP client in the client docsclientsclient. Create a separate file, api_client.py python api_client.py 2, 6, 9, 16 import asyncio from fastmcp import Client async def main  Connect to the MCP server we just created async with Clienthttp127.0.0.18000mcp as client  List the tools that were automatically generated tools  await client.list_tools printGenerated Tools for tool in tools printf- tool.name  Call one of the generated tools printnnCalling tool get_user_by_id... user  await client.call_toolget_user_by_id, id 1 printfResultnuser0.text if __name__  __main__ asyncio.runmain  First, run your server bash python api_server.py  Then, in another terminal, run the client bash python api_client.py  You should see a list of generated tools get_users, get_user_by_id and the result of calling the get_user_by_id tool, which fetches data from the live JSONPlaceholder API. !httpsmintlify.s3.us-west-1.amazonaws.comfastmcpassetsimagestutorial-rest-api-result.png  Step 4 Customizing Route Maps By default, FastMCP converts every API endpoint into an MCP Tool. This ensures maximum compatibility with contemporary LLM clients, many of which only support the tools part of the MCP specification. However, for clients that support the full MCP spec, representing GET requests as Resources can be more semantically correct and efficient. FastMCP allows users to customize this behavior using the concept of route maps. A RouteMap is a mapping of an API route to an MCP type. FastMCP checks each API route against your custom maps in order. If a route matches a map, its converted to the specified mcp_type. Any route that doesnt match your custom maps will fall back to the default behavior becoming a Tool. Learn more about route maps in the OpenAPI integration docsserversopenapiroute-mapping. Heres how you can add custom route maps to turn GET requests into Resources and ResourceTemplates if they have path parameters python api_server_with_resources.py 3, 37-42 import httpx from fastmcp import FastMCP from fastmcp.server.openapi import RouteMap, MCPType  Create an HTTP client for the target API client  httpx.AsyncClientbase_urlhttpsjsonplaceholder.typicode.com  Define a simplified OpenAPI spec for JSONPlaceholder openapi_spec   openapi 3.0.0, info title JSONPlaceholder API, version 1.0, paths  users  get  summary Get all users, operationId get_users, responses 200 description A list of users.  , usersid  get  summary Get a user by ID, operationId get_user_by_id, parameters name id, in path, required True, schema type integer, responses 200 description A single user.      Create the MCP server with custom route mapping mcp  FastMCP.from_openapi openapi_specopenapi_spec, clientclient, nameJSONPlaceholder MCP Server, route_maps  Map GET requests with path parameters e.g., usersid to ResourceTemplate RouteMapmethodsGET, patternr..., mcp_typeMCPType.RESOURCE_TEMPLATE,  Map all other GET requests to Resource RouteMapmethodsGET, mcp_typeMCPType.RESOURCE,   if __name__  __main__ mcp.runtransporthttp, port8000  With this configuration  GET usersid becomes a ResourceTemplate.  GET users becomes a Resource.  Any POST, PUT, etc. endpoints would still become Tools by default.  FastMCP Updates Source httpsgofastmcp.comupdates FastMCP 2.9 is a major release that, among other things, introduces two important features that push beyond the basic MCP protocol.  MCP Middleware brings a flexible middleware system for intercepting and controlling server operations - think authentication, logging, rate limiting, and custom business logic without touching core protocol code.  Server-side type conversion for prompts solves a major developer pain point while MCP requires string arguments, your functions can now work with native Python types like lists and dictionaries, with automatic conversion handling the complexity. These features transform FastMCP from a simple protocol implementation into a powerful framework for building sophisticated MCP applications. Combined with the new File utility for binary data and improvements to authentication and serialization, this release makes FastMCP significantly more flexible and developer-friendly while maintaining full protocol compliance. FastMCP 2.8 is here, and its all about taking control of your tools. This release is packed with new features for curating the perfect LLM experience  Tool Transformation The headline feature lets you wrap any toolfrom your own code, a third-party library, or an OpenAPI specto create an enhanced, LLM-friendly version. You can rename arguments, rewrite descriptions, and hide parameters without touching the original code. This feature was developed in close partnership with Bill Easton. As Bill brilliantly put ithttpswww.linkedin.compostswilliamseaston_huge-thanks-to-william-easton-for-providing-activity-7338011349525983232-Mw6T?utm_sourceshareutm_mediummember_desktoprcmACoAAAAd6d0B3uL9zpCsq9eYWKi3HIvb8eN_r_Q, Tool transformation flips Prompt Engineering on its head stop writing tool-friendly LLM prompts and start providing LLM-friendly tools.  Component Control Now that youre transforming tools, you need a way to hide the old ones! In FastMCP 2.8 you can programmatically enabledisable any component, and for everyone whos been asking what FastMCPs tags are forthey finally have a purpose! You can now use tags to declaratively filter which components are exposed to your clients.  Pragmatic by Default Lastly, to ensure maximum compatibility with the ecosystem, weve made the pragmatic decision to default all OpenAPI routes to Tools, making your entire API immediately accessible to any tool-using agent. When the industry catches up and supports resources, well restore the old default -- but no reason you should do extra work before OpenAI, Anthropic, or Google! FastMCP 2.7 has been released! Most notably, it introduces the highly requested and Pythonic naked decorator usage python 3 mcp  FastMCP mcp.tool def adda int, b int - int return a  b  In addition, decorators now return the objects they create, instead of the decorated function. This is an important usability enhancement. The bulk of the update is focused on improving the FastMCP internals, including a few breaking internal changes to private APIs. A number of functions that have clung on since 1.0 are now deprecated. FastMCP 2.6 is here! This release introduces first-class authentication for MCP servers and clients, including pragmatic Bearer token support and seamless OAuth 2.1 integration. This release aligns with how major AI platforms are adopting MCP today, making it easier than ever to securely connect your tools to real-world AI models. Dive into the update and secure your stack with minimal friction. Your tests are bad and you should feel bad. Stop vibe-testing your MCP server through LLM guesswork. FastMCP 2.0 introduces in-memory testing for fast, deterministic, and fully Pythonic validation of your MCP logicno network, no subprocesses, no vibes. In just six weeks since its relaunch, FastMCP has surpassed 10,000 GitHub starsbecoming the fastest-growing OSS project in our orbit. What started as a personal itch has become the backbone of Python-based MCP servers, powering a rapidly expanding ecosystem. While the protocol itself evolves, FastMCP continues to lead with clarity, developer experience, and opinionated tooling. Heres to whats next. FastMCP 2.3 introduces full support for Streamable HTTP, a modern alternative to SSE that simplifies MCP deployments over the web. Its efficient, reliable, and now the default HTTP transport. Just run your server with transporthttp and connect clients via a standard URLFastMCP handles the rest. No special setup required. This release makes deploying MCP servers easier and more portable than ever. Even AI needs a good travel adapter  FastMCP now supports proxying arbitrary MCP servers, letting you run a local FastMCP instance that transparently forwards requests to any remote or third-party serverregardless of transport. This enables transport bridging e.g., stdio  SSE, simplified client configuration, and powerful gateway patterns. Proxies are fully composable with other FastMCP servers, letting you mount or import them just like local servers. Use FastMCP.from_client to wrap any backend in a clean, Pythonic proxy. This major release reimagines FastMCP as a full ecosystem platform, with powerful new features for composition, integration, and client interaction. You can now compose local and remote servers, proxy arbitrary MCP servers with transport translation, and generate MCP servers from OpenAPI or FastAPI apps. A new client infrastructure supports advanced workflows like LLM sampling. FastMCP 2.0 builds on the success of v1 with a cleaner, more flexible foundationtry it out today! FastMCP 1.0 will become part of the official MCP Python SDK! Because lifes too short for boilerplate. This is where it all started. FastMCPs launch post introduced a clean, Pythonic way to build MCP servers without the protocol overhead. Just write functions FastMCP handles the rest. What began as a weekend project quickly became the foundation of a growing ecosystem.

Keywords: the, fastmcp, server, for, mcp, and, client, with, python, from

---

